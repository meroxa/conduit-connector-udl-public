// Package udl provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package udl

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AISAbridgedDataMode.
const (
	AISAbridgedDataModeEXERCISE  AISAbridgedDataMode = "EXERCISE"
	AISAbridgedDataModeREAL      AISAbridgedDataMode = "REAL"
	AISAbridgedDataModeSIMULATED AISAbridgedDataMode = "SIMULATED"
	AISAbridgedDataModeTEST      AISAbridgedDataMode = "TEST"
)

// Defines values for AISFullDataMode.
const (
	AISFullDataModeEXERCISE  AISFullDataMode = "EXERCISE"
	AISFullDataModeREAL      AISFullDataMode = "REAL"
	AISFullDataModeSIMULATED AISFullDataMode = "SIMULATED"
	AISFullDataModeTEST      AISFullDataMode = "TEST"
)

// Defines values for AISIngestDataMode.
const (
	AISIngestDataModeEXERCISE  AISIngestDataMode = "EXERCISE"
	AISIngestDataModeREAL      AISIngestDataMode = "REAL"
	AISIngestDataModeSIMULATED AISIngestDataMode = "SIMULATED"
	AISIngestDataModeTEST      AISIngestDataMode = "TEST"
)

// Defines values for AntennaDetailsFullDataMode.
const (
	AntennaDetailsFullDataModeEXERCISE  AntennaDetailsFullDataMode = "EXERCISE"
	AntennaDetailsFullDataModeREAL      AntennaDetailsFullDataMode = "REAL"
	AntennaDetailsFullDataModeSIMULATED AntennaDetailsFullDataMode = "SIMULATED"
	AntennaDetailsFullDataModeTEST      AntennaDetailsFullDataMode = "TEST"
)

// Defines values for AntennaDetailsFullMode.
const (
	AntennaDetailsFullModeRX AntennaDetailsFullMode = "RX"
	AntennaDetailsFullModeTX AntennaDetailsFullMode = "TX"
)

// Defines values for AntennaFullDataMode.
const (
	AntennaFullDataModeEXERCISE  AntennaFullDataMode = "EXERCISE"
	AntennaFullDataModeREAL      AntennaFullDataMode = "REAL"
	AntennaFullDataModeSIMULATED AntennaFullDataMode = "SIMULATED"
	AntennaFullDataModeTEST      AntennaFullDataMode = "TEST"
)

// Defines values for AttitudeDataAbridgedDataMode.
const (
	AttitudeDataAbridgedDataModeEXERCISE  AttitudeDataAbridgedDataMode = "EXERCISE"
	AttitudeDataAbridgedDataModeREAL      AttitudeDataAbridgedDataMode = "REAL"
	AttitudeDataAbridgedDataModeSIMULATED AttitudeDataAbridgedDataMode = "SIMULATED"
	AttitudeDataAbridgedDataModeTEST      AttitudeDataAbridgedDataMode = "TEST"
)

// Defines values for AttitudeDataFullDataMode.
const (
	AttitudeDataFullDataModeEXERCISE  AttitudeDataFullDataMode = "EXERCISE"
	AttitudeDataFullDataModeREAL      AttitudeDataFullDataMode = "REAL"
	AttitudeDataFullDataModeSIMULATED AttitudeDataFullDataMode = "SIMULATED"
	AttitudeDataFullDataModeTEST      AttitudeDataFullDataMode = "TEST"
)

// Defines values for AttitudeDataIngestDataMode.
const (
	AttitudeDataIngestDataModeEXERCISE  AttitudeDataIngestDataMode = "EXERCISE"
	AttitudeDataIngestDataModeREAL      AttitudeDataIngestDataMode = "REAL"
	AttitudeDataIngestDataModeSIMULATED AttitudeDataIngestDataMode = "SIMULATED"
	AttitudeDataIngestDataModeTEST      AttitudeDataIngestDataMode = "TEST"
)

// Defines values for AttitudeSetAbridgedDataMode.
const (
	AttitudeSetAbridgedDataModeEXERCISE  AttitudeSetAbridgedDataMode = "EXERCISE"
	AttitudeSetAbridgedDataModeREAL      AttitudeSetAbridgedDataMode = "REAL"
	AttitudeSetAbridgedDataModeSIMULATED AttitudeSetAbridgedDataMode = "SIMULATED"
	AttitudeSetAbridgedDataModeTEST      AttitudeSetAbridgedDataMode = "TEST"
)

// Defines values for AttitudeSetFullDataMode.
const (
	AttitudeSetFullDataModeEXERCISE  AttitudeSetFullDataMode = "EXERCISE"
	AttitudeSetFullDataModeREAL      AttitudeSetFullDataMode = "REAL"
	AttitudeSetFullDataModeSIMULATED AttitudeSetFullDataMode = "SIMULATED"
	AttitudeSetFullDataModeTEST      AttitudeSetFullDataMode = "TEST"
)

// Defines values for AttitudeSetIngestDataMode.
const (
	AttitudeSetIngestDataModeEXERCISE  AttitudeSetIngestDataMode = "EXERCISE"
	AttitudeSetIngestDataModeREAL      AttitudeSetIngestDataMode = "REAL"
	AttitudeSetIngestDataModeSIMULATED AttitudeSetIngestDataMode = "SIMULATED"
	AttitudeSetIngestDataModeTEST      AttitudeSetIngestDataMode = "TEST"
)

// Defines values for BatteryDetailsFullDataMode.
const (
	BatteryDetailsFullDataModeEXERCISE  BatteryDetailsFullDataMode = "EXERCISE"
	BatteryDetailsFullDataModeREAL      BatteryDetailsFullDataMode = "REAL"
	BatteryDetailsFullDataModeSIMULATED BatteryDetailsFullDataMode = "SIMULATED"
	BatteryDetailsFullDataModeTEST      BatteryDetailsFullDataMode = "TEST"
)

// Defines values for BatteryFullDataMode.
const (
	BatteryFullDataModeEXERCISE  BatteryFullDataMode = "EXERCISE"
	BatteryFullDataModeREAL      BatteryFullDataMode = "REAL"
	BatteryFullDataModeSIMULATED BatteryFullDataMode = "SIMULATED"
	BatteryFullDataModeTEST      BatteryFullDataMode = "TEST"
)

// Defines values for DataMode.
const (
	DataModeEXERCISE  DataMode = "EXERCISE"
	DataModeREAL      DataMode = "REAL"
	DataModeSIMULATED DataMode = "SIMULATED"
	DataModeTEST      DataMode = "TEST"
)

// Defines values for ElsetAbridgedDataMode.
const (
	ElsetAbridgedDataModeEXERCISE  ElsetAbridgedDataMode = "EXERCISE"
	ElsetAbridgedDataModeREAL      ElsetAbridgedDataMode = "REAL"
	ElsetAbridgedDataModeSIMULATED ElsetAbridgedDataMode = "SIMULATED"
	ElsetAbridgedDataModeTEST      ElsetAbridgedDataMode = "TEST"
)

// Defines values for ElsetFullDataMode.
const (
	ElsetFullDataModeEXERCISE  ElsetFullDataMode = "EXERCISE"
	ElsetFullDataModeREAL      ElsetFullDataMode = "REAL"
	ElsetFullDataModeSIMULATED ElsetFullDataMode = "SIMULATED"
	ElsetFullDataModeTEST      ElsetFullDataMode = "TEST"
)

// Defines values for ElsetFullSourcedDataTypes.
const (
	ElsetFullSourcedDataTypesDOA   ElsetFullSourcedDataTypes = "DOA"
	ElsetFullSourcedDataTypesELSET ElsetFullSourcedDataTypes = "ELSET"
	ElsetFullSourcedDataTypesEO    ElsetFullSourcedDataTypes = "EO"
	ElsetFullSourcedDataTypesRADAR ElsetFullSourcedDataTypes = "RADAR"
	ElsetFullSourcedDataTypesRF    ElsetFullSourcedDataTypes = "RF"
	ElsetFullSourcedDataTypesSV    ElsetFullSourcedDataTypes = "SV"
)

// Defines values for ElsetIngestDataMode.
const (
	ElsetIngestDataModeEXERCISE  ElsetIngestDataMode = "EXERCISE"
	ElsetIngestDataModeREAL      ElsetIngestDataMode = "REAL"
	ElsetIngestDataModeSIMULATED ElsetIngestDataMode = "SIMULATED"
	ElsetIngestDataModeTEST      ElsetIngestDataMode = "TEST"
)

// Defines values for ElsetIngestSourcedDataTypes.
const (
	ElsetIngestSourcedDataTypesDOA   ElsetIngestSourcedDataTypes = "DOA"
	ElsetIngestSourcedDataTypesELSET ElsetIngestSourcedDataTypes = "ELSET"
	ElsetIngestSourcedDataTypesEO    ElsetIngestSourcedDataTypes = "EO"
	ElsetIngestSourcedDataTypesRADAR ElsetIngestSourcedDataTypes = "RADAR"
	ElsetIngestSourcedDataTypesRF    ElsetIngestSourcedDataTypes = "RF"
	ElsetIngestSourcedDataTypesSV    ElsetIngestSourcedDataTypes = "SV"
)

// Defines values for EngineDetailsFullDataMode.
const (
	EngineDetailsFullDataModeEXERCISE  EngineDetailsFullDataMode = "EXERCISE"
	EngineDetailsFullDataModeREAL      EngineDetailsFullDataMode = "REAL"
	EngineDetailsFullDataModeSIMULATED EngineDetailsFullDataMode = "SIMULATED"
	EngineDetailsFullDataModeTEST      EngineDetailsFullDataMode = "TEST"
)

// Defines values for EngineFullDataMode.
const (
	EngineFullDataModeEXERCISE  EngineFullDataMode = "EXERCISE"
	EngineFullDataModeREAL      EngineFullDataMode = "REAL"
	EngineFullDataModeSIMULATED EngineFullDataMode = "SIMULATED"
	EngineFullDataModeTEST      EngineFullDataMode = "TEST"
)

// Defines values for EntityAbridgedDataMode.
const (
	EntityAbridgedDataModeEXERCISE  EntityAbridgedDataMode = "EXERCISE"
	EntityAbridgedDataModeREAL      EntityAbridgedDataMode = "REAL"
	EntityAbridgedDataModeSIMULATED EntityAbridgedDataMode = "SIMULATED"
	EntityAbridgedDataModeTEST      EntityAbridgedDataMode = "TEST"
)

// Defines values for EntityAbridgedOwnerType.
const (
	EntityAbridgedOwnerTypeAcademic   EntityAbridgedOwnerType = "Academic"
	EntityAbridgedOwnerTypeCommercial EntityAbridgedOwnerType = "Commercial"
	EntityAbridgedOwnerTypeConsortium EntityAbridgedOwnerType = "Consortium"
	EntityAbridgedOwnerTypeGovernment EntityAbridgedOwnerType = "Government"
	EntityAbridgedOwnerTypeOther      EntityAbridgedOwnerType = "Other"
)

// Defines values for EntityAbridgedType.
const (
	EntityAbridgedTypeAIRCRAFT   EntityAbridgedType = "AIRCRAFT"
	EntityAbridgedTypeBUS        EntityAbridgedType = "BUS"
	EntityAbridgedTypeCOMM       EntityAbridgedType = "COMM"
	EntityAbridgedTypeIR         EntityAbridgedType = "IR"
	EntityAbridgedTypeNAVIGATION EntityAbridgedType = "NAVIGATION"
	EntityAbridgedTypeONORBIT    EntityAbridgedType = "ONORBIT"
	EntityAbridgedTypeRFEMITTER  EntityAbridgedType = "RFEMITTER"
	EntityAbridgedTypeSCIENTIFIC EntityAbridgedType = "SCIENTIFIC"
	EntityAbridgedTypeSENSOR     EntityAbridgedType = "SENSOR"
	EntityAbridgedTypeSITE       EntityAbridgedType = "SITE"
)

// Defines values for EntityFullDataMode.
const (
	EntityFullDataModeEXERCISE  EntityFullDataMode = "EXERCISE"
	EntityFullDataModeREAL      EntityFullDataMode = "REAL"
	EntityFullDataModeSIMULATED EntityFullDataMode = "SIMULATED"
	EntityFullDataModeTEST      EntityFullDataMode = "TEST"
)

// Defines values for EntityFullOwnerType.
const (
	EntityFullOwnerTypeAcademic   EntityFullOwnerType = "Academic"
	EntityFullOwnerTypeCommercial EntityFullOwnerType = "Commercial"
	EntityFullOwnerTypeConsortium EntityFullOwnerType = "Consortium"
	EntityFullOwnerTypeGovernment EntityFullOwnerType = "Government"
	EntityFullOwnerTypeOther      EntityFullOwnerType = "Other"
)

// Defines values for EntityFullType.
const (
	EntityFullTypeAIRCRAFT   EntityFullType = "AIRCRAFT"
	EntityFullTypeBUS        EntityFullType = "BUS"
	EntityFullTypeCOMM       EntityFullType = "COMM"
	EntityFullTypeIR         EntityFullType = "IR"
	EntityFullTypeNAVIGATION EntityFullType = "NAVIGATION"
	EntityFullTypeONORBIT    EntityFullType = "ONORBIT"
	EntityFullTypeRFEMITTER  EntityFullType = "RFEMITTER"
	EntityFullTypeSCIENTIFIC EntityFullType = "SCIENTIFIC"
	EntityFullTypeSENSOR     EntityFullType = "SENSOR"
	EntityFullTypeSITE       EntityFullType = "SITE"
)

// Defines values for EphemFormatType.
const (
	GOO    EphemFormatType = "GOO"
	ModITC EphemFormatType = "ModITC"
	NASA   EphemFormatType = "NASA"
	OASYS  EphemFormatType = "OASYS"
	OEM    EphemFormatType = "OEM"
)

// Defines values for EphemerisSetAbridgedCovReferenceFrame.
const (
	EphemerisSetAbridgedCovReferenceFrameJ2000 EphemerisSetAbridgedCovReferenceFrame = "J2000"
	EphemerisSetAbridgedCovReferenceFrameUVW   EphemerisSetAbridgedCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetAbridgedDataMode.
const (
	EphemerisSetAbridgedDataModeEXERCISE  EphemerisSetAbridgedDataMode = "EXERCISE"
	EphemerisSetAbridgedDataModeREAL      EphemerisSetAbridgedDataMode = "REAL"
	EphemerisSetAbridgedDataModeSIMULATED EphemerisSetAbridgedDataMode = "SIMULATED"
	EphemerisSetAbridgedDataModeTEST      EphemerisSetAbridgedDataMode = "TEST"
)

// Defines values for EphemerisSetAbridgedReferenceFrame.
const (
	EphemerisSetAbridgedReferenceFrameECRECEF EphemerisSetAbridgedReferenceFrame = "ECR/ECEF"
	EphemerisSetAbridgedReferenceFrameEFGTDR  EphemerisSetAbridgedReferenceFrame = "EFG/TDR"
	EphemerisSetAbridgedReferenceFrameGCRF    EphemerisSetAbridgedReferenceFrame = "GCRF"
	EphemerisSetAbridgedReferenceFrameITRF    EphemerisSetAbridgedReferenceFrame = "ITRF"
	EphemerisSetAbridgedReferenceFrameJ2000   EphemerisSetAbridgedReferenceFrame = "J2000"
	EphemerisSetAbridgedReferenceFrameTEME    EphemerisSetAbridgedReferenceFrame = "TEME"
)

// Defines values for EphemerisSetFullCovReferenceFrame.
const (
	EphemerisSetFullCovReferenceFrameJ2000 EphemerisSetFullCovReferenceFrame = "J2000"
	EphemerisSetFullCovReferenceFrameUVW   EphemerisSetFullCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetFullDataMode.
const (
	EphemerisSetFullDataModeEXERCISE  EphemerisSetFullDataMode = "EXERCISE"
	EphemerisSetFullDataModeREAL      EphemerisSetFullDataMode = "REAL"
	EphemerisSetFullDataModeSIMULATED EphemerisSetFullDataMode = "SIMULATED"
	EphemerisSetFullDataModeTEST      EphemerisSetFullDataMode = "TEST"
)

// Defines values for EphemerisSetFullReferenceFrame.
const (
	EphemerisSetFullReferenceFrameECRECEF EphemerisSetFullReferenceFrame = "ECR/ECEF"
	EphemerisSetFullReferenceFrameEFGTDR  EphemerisSetFullReferenceFrame = "EFG/TDR"
	EphemerisSetFullReferenceFrameGCRF    EphemerisSetFullReferenceFrame = "GCRF"
	EphemerisSetFullReferenceFrameITRF    EphemerisSetFullReferenceFrame = "ITRF"
	EphemerisSetFullReferenceFrameJ2000   EphemerisSetFullReferenceFrame = "J2000"
	EphemerisSetFullReferenceFrameTEME    EphemerisSetFullReferenceFrame = "TEME"
)

// Defines values for EphemerisSetIngestCovReferenceFrame.
const (
	EphemerisSetIngestCovReferenceFrameJ2000 EphemerisSetIngestCovReferenceFrame = "J2000"
	EphemerisSetIngestCovReferenceFrameUVW   EphemerisSetIngestCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetIngestDataMode.
const (
	EphemerisSetIngestDataModeEXERCISE  EphemerisSetIngestDataMode = "EXERCISE"
	EphemerisSetIngestDataModeREAL      EphemerisSetIngestDataMode = "REAL"
	EphemerisSetIngestDataModeSIMULATED EphemerisSetIngestDataMode = "SIMULATED"
	EphemerisSetIngestDataModeTEST      EphemerisSetIngestDataMode = "TEST"
)

// Defines values for EphemerisSetIngestReferenceFrame.
const (
	EphemerisSetIngestReferenceFrameECRECEF EphemerisSetIngestReferenceFrame = "ECR/ECEF"
	EphemerisSetIngestReferenceFrameEFGTDR  EphemerisSetIngestReferenceFrame = "EFG/TDR"
	EphemerisSetIngestReferenceFrameGCRF    EphemerisSetIngestReferenceFrame = "GCRF"
	EphemerisSetIngestReferenceFrameITRF    EphemerisSetIngestReferenceFrame = "ITRF"
	EphemerisSetIngestReferenceFrameJ2000   EphemerisSetIngestReferenceFrame = "J2000"
	EphemerisSetIngestReferenceFrameTEME    EphemerisSetIngestReferenceFrame = "TEME"
)

// Defines values for EphemerisAbridgedDataMode.
const (
	EphemerisAbridgedDataModeEXERCISE  EphemerisAbridgedDataMode = "EXERCISE"
	EphemerisAbridgedDataModeREAL      EphemerisAbridgedDataMode = "REAL"
	EphemerisAbridgedDataModeSIMULATED EphemerisAbridgedDataMode = "SIMULATED"
	EphemerisAbridgedDataModeTEST      EphemerisAbridgedDataMode = "TEST"
)

// Defines values for EphemerisFullDataMode.
const (
	EphemerisFullDataModeEXERCISE  EphemerisFullDataMode = "EXERCISE"
	EphemerisFullDataModeREAL      EphemerisFullDataMode = "REAL"
	EphemerisFullDataModeSIMULATED EphemerisFullDataMode = "SIMULATED"
	EphemerisFullDataModeTEST      EphemerisFullDataMode = "TEST"
)

// Defines values for EphemerisIngestDataMode.
const (
	EphemerisIngestDataModeEXERCISE  EphemerisIngestDataMode = "EXERCISE"
	EphemerisIngestDataModeREAL      EphemerisIngestDataMode = "REAL"
	EphemerisIngestDataModeSIMULATED EphemerisIngestDataMode = "SIMULATED"
	EphemerisIngestDataModeTEST      EphemerisIngestDataMode = "TEST"
)

// Defines values for LocationAbridgedDataMode.
const (
	LocationAbridgedDataModeEXERCISE  LocationAbridgedDataMode = "EXERCISE"
	LocationAbridgedDataModeREAL      LocationAbridgedDataMode = "REAL"
	LocationAbridgedDataModeSIMULATED LocationAbridgedDataMode = "SIMULATED"
	LocationAbridgedDataModeTEST      LocationAbridgedDataMode = "TEST"
)

// Defines values for LocationFullDataMode.
const (
	LocationFullDataModeEXERCISE  LocationFullDataMode = "EXERCISE"
	LocationFullDataModeREAL      LocationFullDataMode = "REAL"
	LocationFullDataModeSIMULATED LocationFullDataMode = "SIMULATED"
	LocationFullDataModeTEST      LocationFullDataMode = "TEST"
)

// Defines values for OnorbitAntennaFullDataMode.
const (
	OnorbitAntennaFullDataModeEXERCISE  OnorbitAntennaFullDataMode = "EXERCISE"
	OnorbitAntennaFullDataModeREAL      OnorbitAntennaFullDataMode = "REAL"
	OnorbitAntennaFullDataModeSIMULATED OnorbitAntennaFullDataMode = "SIMULATED"
	OnorbitAntennaFullDataModeTEST      OnorbitAntennaFullDataMode = "TEST"
)

// Defines values for OnorbitBatteryFullDataMode.
const (
	OnorbitBatteryFullDataModeEXERCISE  OnorbitBatteryFullDataMode = "EXERCISE"
	OnorbitBatteryFullDataModeREAL      OnorbitBatteryFullDataMode = "REAL"
	OnorbitBatteryFullDataModeSIMULATED OnorbitBatteryFullDataMode = "SIMULATED"
	OnorbitBatteryFullDataModeTEST      OnorbitBatteryFullDataMode = "TEST"
)

// Defines values for OnorbitDetailsFullDataMode.
const (
	OnorbitDetailsFullDataModeEXERCISE  OnorbitDetailsFullDataMode = "EXERCISE"
	OnorbitDetailsFullDataModeREAL      OnorbitDetailsFullDataMode = "REAL"
	OnorbitDetailsFullDataModeSIMULATED OnorbitDetailsFullDataMode = "SIMULATED"
	OnorbitDetailsFullDataModeTEST      OnorbitDetailsFullDataMode = "TEST"
)

// Defines values for OnorbitSolarArrayFullDataMode.
const (
	OnorbitSolarArrayFullDataModeEXERCISE  OnorbitSolarArrayFullDataMode = "EXERCISE"
	OnorbitSolarArrayFullDataModeREAL      OnorbitSolarArrayFullDataMode = "REAL"
	OnorbitSolarArrayFullDataModeSIMULATED OnorbitSolarArrayFullDataMode = "SIMULATED"
	OnorbitSolarArrayFullDataModeTEST      OnorbitSolarArrayFullDataMode = "TEST"
)

// Defines values for OnorbitThrusterFullDataMode.
const (
	OnorbitThrusterFullDataModeEXERCISE  OnorbitThrusterFullDataMode = "EXERCISE"
	OnorbitThrusterFullDataModeREAL      OnorbitThrusterFullDataMode = "REAL"
	OnorbitThrusterFullDataModeSIMULATED OnorbitThrusterFullDataMode = "SIMULATED"
	OnorbitThrusterFullDataModeTEST      OnorbitThrusterFullDataMode = "TEST"
)

// Defines values for OnorbitAbridgedCategory.
const (
	OnorbitAbridgedCategoryAnalystSatellite      OnorbitAbridgedCategory = "Analyst Satellite"
	OnorbitAbridgedCategoryCatalogedWithoutState OnorbitAbridgedCategory = "Cataloged Without State"
	OnorbitAbridgedCategoryCislunar              OnorbitAbridgedCategory = "Cislunar"
	OnorbitAbridgedCategoryDecayed               OnorbitAbridgedCategory = "Decayed"
	OnorbitAbridgedCategoryDocked                OnorbitAbridgedCategory = "Docked"
	OnorbitAbridgedCategoryHeliocentric          OnorbitAbridgedCategory = "Heliocentric"
	OnorbitAbridgedCategoryHyperbolic            OnorbitAbridgedCategory = "Hyperbolic"
	OnorbitAbridgedCategoryInterplanetary        OnorbitAbridgedCategory = "Interplanetary"
	OnorbitAbridgedCategoryLagrangian            OnorbitAbridgedCategory = "Lagrangian"
	OnorbitAbridgedCategoryLaunchNominal         OnorbitAbridgedCategory = "Launch Nominal"
	OnorbitAbridgedCategoryLunar                 OnorbitAbridgedCategory = "Lunar"
	OnorbitAbridgedCategoryOnOrbit               OnorbitAbridgedCategory = "On-Orbit"
	OnorbitAbridgedCategoryUnknown               OnorbitAbridgedCategory = "Unknown"
)

// Defines values for OnorbitAbridgedDataMode.
const (
	OnorbitAbridgedDataModeEXERCISE  OnorbitAbridgedDataMode = "EXERCISE"
	OnorbitAbridgedDataModeREAL      OnorbitAbridgedDataMode = "REAL"
	OnorbitAbridgedDataModeSIMULATED OnorbitAbridgedDataMode = "SIMULATED"
	OnorbitAbridgedDataModeTEST      OnorbitAbridgedDataMode = "TEST"
)

// Defines values for OnorbitAbridgedObjectType.
const (
	OnorbitAbridgedObjectTypeDEBRIS     OnorbitAbridgedObjectType = "DEBRIS"
	OnorbitAbridgedObjectTypeMANNED     OnorbitAbridgedObjectType = "MANNED"
	OnorbitAbridgedObjectTypePAYLOAD    OnorbitAbridgedObjectType = "PAYLOAD"
	OnorbitAbridgedObjectTypePLATFORM   OnorbitAbridgedObjectType = "PLATFORM"
	OnorbitAbridgedObjectTypeROCKETBODY OnorbitAbridgedObjectType = "ROCKET BODY"
	OnorbitAbridgedObjectTypeUNKNOWN    OnorbitAbridgedObjectType = "UNKNOWN"
)

// Defines values for OnorbitFullCategory.
const (
	OnorbitFullCategoryAnalystSatellite      OnorbitFullCategory = "Analyst Satellite"
	OnorbitFullCategoryCatalogedWithoutState OnorbitFullCategory = "Cataloged Without State"
	OnorbitFullCategoryCislunar              OnorbitFullCategory = "Cislunar"
	OnorbitFullCategoryDecayed               OnorbitFullCategory = "Decayed"
	OnorbitFullCategoryDocked                OnorbitFullCategory = "Docked"
	OnorbitFullCategoryHeliocentric          OnorbitFullCategory = "Heliocentric"
	OnorbitFullCategoryHyperbolic            OnorbitFullCategory = "Hyperbolic"
	OnorbitFullCategoryInterplanetary        OnorbitFullCategory = "Interplanetary"
	OnorbitFullCategoryLagrangian            OnorbitFullCategory = "Lagrangian"
	OnorbitFullCategoryLaunchNominal         OnorbitFullCategory = "Launch Nominal"
	OnorbitFullCategoryLunar                 OnorbitFullCategory = "Lunar"
	OnorbitFullCategoryOnOrbit               OnorbitFullCategory = "On-Orbit"
	OnorbitFullCategoryUnknown               OnorbitFullCategory = "Unknown"
)

// Defines values for OnorbitFullDataMode.
const (
	OnorbitFullDataModeEXERCISE  OnorbitFullDataMode = "EXERCISE"
	OnorbitFullDataModeREAL      OnorbitFullDataMode = "REAL"
	OnorbitFullDataModeSIMULATED OnorbitFullDataMode = "SIMULATED"
	OnorbitFullDataModeTEST      OnorbitFullDataMode = "TEST"
)

// Defines values for OnorbitFullObjectType.
const (
	OnorbitFullObjectTypeDEBRIS     OnorbitFullObjectType = "DEBRIS"
	OnorbitFullObjectTypeMANNED     OnorbitFullObjectType = "MANNED"
	OnorbitFullObjectTypePAYLOAD    OnorbitFullObjectType = "PAYLOAD"
	OnorbitFullObjectTypePLATFORM   OnorbitFullObjectType = "PLATFORM"
	OnorbitFullObjectTypeROCKETBODY OnorbitFullObjectType = "ROCKET BODY"
	OnorbitFullObjectTypeUNKNOWN    OnorbitFullObjectType = "UNKNOWN"
)

// Defines values for OperatingunitFullDataMode.
const (
	OperatingunitFullDataModeEXERCISE  OperatingunitFullDataMode = "EXERCISE"
	OperatingunitFullDataModeREAL      OperatingunitFullDataMode = "REAL"
	OperatingunitFullDataModeSIMULATED OperatingunitFullDataMode = "SIMULATED"
	OperatingunitFullDataModeTEST      OperatingunitFullDataMode = "TEST"
)

// Defines values for OrganizationDetailsFullDataMode.
const (
	OrganizationDetailsFullDataModeEXERCISE  OrganizationDetailsFullDataMode = "EXERCISE"
	OrganizationDetailsFullDataModeREAL      OrganizationDetailsFullDataMode = "REAL"
	OrganizationDetailsFullDataModeSIMULATED OrganizationDetailsFullDataMode = "SIMULATED"
	OrganizationDetailsFullDataModeTEST      OrganizationDetailsFullDataMode = "TEST"
)

// Defines values for OrganizationFullDataMode.
const (
	OrganizationFullDataModeEXERCISE  OrganizationFullDataMode = "EXERCISE"
	OrganizationFullDataModeREAL      OrganizationFullDataMode = "REAL"
	OrganizationFullDataModeSIMULATED OrganizationFullDataMode = "SIMULATED"
	OrganizationFullDataModeTEST      OrganizationFullDataMode = "TEST"
)

// Defines values for RFBandFullDataMode.
const (
	RFBandFullDataModeEXERCISE  RFBandFullDataMode = "EXERCISE"
	RFBandFullDataModeREAL      RFBandFullDataMode = "REAL"
	RFBandFullDataModeSIMULATED RFBandFullDataMode = "SIMULATED"
	RFBandFullDataModeTEST      RFBandFullDataMode = "TEST"
)

// Defines values for RFBandFullMode.
const (
	RFBandFullModeRX RFBandFullMode = "RX"
	RFBandFullModeTX RFBandFullMode = "TX"
)

// Defines values for RFBandFullPolarization.
const (
	H RFBandFullPolarization = "H"
	L RFBandFullPolarization = "L"
	R RFBandFullPolarization = "R"
	V RFBandFullPolarization = "V"
)

// Defines values for RFBandFullPurpose.
const (
	COMM  RFBandFullPurpose = "COMM"
	OPS   RFBandFullPurpose = "OPS"
	OTHER RFBandFullPurpose = "OTHER"
	TTC   RFBandFullPurpose = "TTC"
)

// Defines values for SensorStatsAbridgedDataMode.
const (
	SensorStatsAbridgedDataModeEXERCISE  SensorStatsAbridgedDataMode = "EXERCISE"
	SensorStatsAbridgedDataModeREAL      SensorStatsAbridgedDataMode = "REAL"
	SensorStatsAbridgedDataModeSIMULATED SensorStatsAbridgedDataMode = "SIMULATED"
	SensorStatsAbridgedDataModeTEST      SensorStatsAbridgedDataMode = "TEST"
)

// Defines values for SensorStatsFullDataMode.
const (
	SensorStatsFullDataModeEXERCISE  SensorStatsFullDataMode = "EXERCISE"
	SensorStatsFullDataModeREAL      SensorStatsFullDataMode = "REAL"
	SensorStatsFullDataModeSIMULATED SensorStatsFullDataMode = "SIMULATED"
	SensorStatsFullDataModeTEST      SensorStatsFullDataMode = "TEST"
)

// Defines values for SensorAbridgedDataMode.
const (
	SensorAbridgedDataModeEXERCISE  SensorAbridgedDataMode = "EXERCISE"
	SensorAbridgedDataModeREAL      SensorAbridgedDataMode = "REAL"
	SensorAbridgedDataModeSIMULATED SensorAbridgedDataMode = "SIMULATED"
	SensorAbridgedDataModeTEST      SensorAbridgedDataMode = "TEST"
)

// Defines values for SensorFullDataMode.
const (
	SensorFullDataModeEXERCISE  SensorFullDataMode = "EXERCISE"
	SensorFullDataModeREAL      SensorFullDataMode = "REAL"
	SensorFullDataModeSIMULATED SensorFullDataMode = "SIMULATED"
	SensorFullDataModeTEST      SensorFullDataMode = "TEST"
)

// Defines values for SensorcharacteristicsAbridgedDataMode.
const (
	SensorcharacteristicsAbridgedDataModeEXERCISE  SensorcharacteristicsAbridgedDataMode = "EXERCISE"
	SensorcharacteristicsAbridgedDataModeREAL      SensorcharacteristicsAbridgedDataMode = "REAL"
	SensorcharacteristicsAbridgedDataModeSIMULATED SensorcharacteristicsAbridgedDataMode = "SIMULATED"
	SensorcharacteristicsAbridgedDataModeTEST      SensorcharacteristicsAbridgedDataMode = "TEST"
)

// Defines values for SensorcharacteristicsFullDataMode.
const (
	SensorcharacteristicsFullDataModeEXERCISE  SensorcharacteristicsFullDataMode = "EXERCISE"
	SensorcharacteristicsFullDataModeREAL      SensorcharacteristicsFullDataMode = "REAL"
	SensorcharacteristicsFullDataModeSIMULATED SensorcharacteristicsFullDataMode = "SIMULATED"
	SensorcharacteristicsFullDataModeTEST      SensorcharacteristicsFullDataMode = "TEST"
)

// Defines values for SensorlimitsAbridgedDataMode.
const (
	SensorlimitsAbridgedDataModeEXERCISE  SensorlimitsAbridgedDataMode = "EXERCISE"
	SensorlimitsAbridgedDataModeREAL      SensorlimitsAbridgedDataMode = "REAL"
	SensorlimitsAbridgedDataModeSIMULATED SensorlimitsAbridgedDataMode = "SIMULATED"
	SensorlimitsAbridgedDataModeTEST      SensorlimitsAbridgedDataMode = "TEST"
)

// Defines values for SensorlimitsFullDataMode.
const (
	SensorlimitsFullDataModeEXERCISE  SensorlimitsFullDataMode = "EXERCISE"
	SensorlimitsFullDataModeREAL      SensorlimitsFullDataMode = "REAL"
	SensorlimitsFullDataModeSIMULATED SensorlimitsFullDataMode = "SIMULATED"
	SensorlimitsFullDataModeTEST      SensorlimitsFullDataMode = "TEST"
)

// Defines values for SensorobservationtypeFullDataMode.
const (
	SensorobservationtypeFullDataModeEXERCISE  SensorobservationtypeFullDataMode = "EXERCISE"
	SensorobservationtypeFullDataModeREAL      SensorobservationtypeFullDataMode = "REAL"
	SensorobservationtypeFullDataModeSIMULATED SensorobservationtypeFullDataMode = "SIMULATED"
	SensorobservationtypeFullDataModeTEST      SensorobservationtypeFullDataMode = "TEST"
)

// Defines values for SensortypeFullDataMode.
const (
	SensortypeFullDataModeEXERCISE  SensortypeFullDataMode = "EXERCISE"
	SensortypeFullDataModeREAL      SensortypeFullDataMode = "REAL"
	SensortypeFullDataModeSIMULATED SensortypeFullDataMode = "SIMULATED"
	SensortypeFullDataModeTEST      SensortypeFullDataMode = "TEST"
)

// Defines values for SolarArrayDetailsFullDataMode.
const (
	SolarArrayDetailsFullDataModeEXERCISE  SolarArrayDetailsFullDataMode = "EXERCISE"
	SolarArrayDetailsFullDataModeREAL      SolarArrayDetailsFullDataMode = "REAL"
	SolarArrayDetailsFullDataModeSIMULATED SolarArrayDetailsFullDataMode = "SIMULATED"
	SolarArrayDetailsFullDataModeTEST      SolarArrayDetailsFullDataMode = "TEST"
)

// Defines values for SolarArrayFullDataMode.
const (
	SolarArrayFullDataModeEXERCISE  SolarArrayFullDataMode = "EXERCISE"
	SolarArrayFullDataModeREAL      SolarArrayFullDataMode = "REAL"
	SolarArrayFullDataModeSIMULATED SolarArrayFullDataMode = "SIMULATED"
	SolarArrayFullDataModeTEST      SolarArrayFullDataMode = "TEST"
)

// Defines values for StateVectorFullCovReferenceFrame.
const (
	StateVectorFullCovReferenceFrameJ2000 StateVectorFullCovReferenceFrame = "J2000"
	StateVectorFullCovReferenceFrameUVW   StateVectorFullCovReferenceFrame = "UVW"
)

// Defines values for StateVectorFullDataMode.
const (
	StateVectorFullDataModeEXERCISE  StateVectorFullDataMode = "EXERCISE"
	StateVectorFullDataModeREAL      StateVectorFullDataMode = "REAL"
	StateVectorFullDataModeSIMULATED StateVectorFullDataMode = "SIMULATED"
	StateVectorFullDataModeTEST      StateVectorFullDataMode = "TEST"
)

// Defines values for StateVectorFullReferenceFrame.
const (
	StateVectorFullReferenceFrameECRECEF StateVectorFullReferenceFrame = "ECR/ECEF"
	StateVectorFullReferenceFrameEFGTDR  StateVectorFullReferenceFrame = "EFG/TDR"
	StateVectorFullReferenceFrameGCRF    StateVectorFullReferenceFrame = "GCRF"
	StateVectorFullReferenceFrameITRF    StateVectorFullReferenceFrame = "ITRF"
	StateVectorFullReferenceFrameJ2000   StateVectorFullReferenceFrame = "J2000"
	StateVectorFullReferenceFrameTEME    StateVectorFullReferenceFrame = "TEME"
)

// Defines values for StateVectorFullSourcedDataTypes.
const (
	DOA   StateVectorFullSourcedDataTypes = "DOA"
	ELSET StateVectorFullSourcedDataTypes = "ELSET"
	EO    StateVectorFullSourcedDataTypes = "EO"
	RADAR StateVectorFullSourcedDataTypes = "RADAR"
	RF    StateVectorFullSourcedDataTypes = "RF"
	SV    StateVectorFullSourcedDataTypes = "SV"
)

// Defines values for StatusFullDataMode.
const (
	StatusFullDataModeEXERCISE  StatusFullDataMode = "EXERCISE"
	StatusFullDataModeREAL      StatusFullDataMode = "REAL"
	StatusFullDataModeSIMULATED StatusFullDataMode = "SIMULATED"
	StatusFullDataModeTEST      StatusFullDataMode = "TEST"
)

// Defines values for StatusFullOpsCap.
const (
	StatusFullOpsCapFMC StatusFullOpsCap = "FMC"
	StatusFullOpsCapNMC StatusFullOpsCap = "NMC"
	StatusFullOpsCapPMC StatusFullOpsCap = "PMC"
	StatusFullOpsCapUNK StatusFullOpsCap = "UNK"
)

// Defines values for StatusFullState.
const (
	ACTIVE   StatusFullState = "ACTIVE"
	DEAD     StatusFullState = "DEAD"
	RFACTIVE StatusFullState = "RF ACTIVE"
	STANDBY  StatusFullState = "STANDBY"
	UNKNOWN  StatusFullState = "UNKNOWN"
)

// Defines values for StatusFullSysCap.
const (
	StatusFullSysCapFMC StatusFullSysCap = "FMC"
	StatusFullSysCapNMC StatusFullSysCap = "NMC"
	StatusFullSysCapPMC StatusFullSysCap = "PMC"
	StatusFullSysCapUNK StatusFullSysCap = "UNK"
)

// Defines values for SubStatusFullDataMode.
const (
	EXERCISE  SubStatusFullDataMode = "EXERCISE"
	REAL      SubStatusFullDataMode = "REAL"
	SIMULATED SubStatusFullDataMode = "SIMULATED"
	TEST      SubStatusFullDataMode = "TEST"
)

// Defines values for SubStatusFullStatus.
const (
	FMC SubStatusFullStatus = "FMC"
	NMC SubStatusFullStatus = "NMC"
	PMC SubStatusFullStatus = "PMC"
	UNK SubStatusFullStatus = "UNK"
)

// Defines values for SubStatusFullType.
const (
	MdCap SubStatusFullType = "mdCap"
	MwCap SubStatusFullType = "mwCap"
	SsCap SubStatusFullType = "ssCap"
)

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISAbridged struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISAbridgedDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName *string `json:"shipName,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISAbridgedDataMode string

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISFull struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISFullDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName *string `json:"shipName,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISFullDataMode string

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISIngest struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISIngestDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"currentVoyage.draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lastPositionUpdate.longitude,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"staticData.mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"lastPositionUpdate.navigationalStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName string `json:"staticData.name,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"staticData.shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"updateTimestamp"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISIngestDataMode string

// Detailed information for a spacecraft communication antenna. One antenna may have multiple AntennaDetails records, compiled by various sources.
type AntennaDetailsFull struct {
	// Boolean indicating if this is a beam forming antenna
	BeamForming *bool `json:"beamForming,omitempty"`

	// Array of angles between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaDetailsFullDataMode `json:"dataMode"`

	// Antenna description
	Description *string `json:"description,omitempty"`

	// Antenna diameter in meters
	Diameter *float64 `json:"diameter,omitempty"`

	// Antenna end of frequency range in Mhz
	EndFrequency *float64 `json:"endFrequency,omitempty"`

	// Antenna maximum gain in dBi
	Gain *float64 `json:"gain,omitempty"`

	// Antenna gain tolerance in dB
	GainTolerance *float64 `json:"gainTolerance,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Antenna
	IdAntenna string `json:"idAntenna"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the antenna
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Antenna mode (e.g. TX,RX)
	Mode *AntennaDetailsFullMode `json:"mode,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Antenna polarization in degrees
	Polarization *float64 `json:"polarization,omitempty"`

	// Antenna position (e.g. Top, Nadir, Side)
	Position *string `json:"position,omitempty"`

	// Array with 1-2 values specifying the length and width (for rectangular) and just length for dipole antennas in meters
	Size *[]float64 `json:"size,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Antenna start of frequency range in Mhz
	StartFrequency *float64 `json:"startFrequency,omitempty"`

	// Boolean indicating if this antenna is steerable
	Steerable *bool `json:"steerable,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of antenna (e.g. Reflector, Double Reflector, Shaped Reflector, Horn, Parabolic, etc.)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaDetailsFullDataMode string

// Antenna mode (e.g. TX,RX)
type AntennaDetailsFullMode string

// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
type AntennaFull struct {
	// Read-only collection of additional AntennaDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/antennadetails operations.
	AntennaDetails *[]AntennaDetailsFull `json:"antennaDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Antenna name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaFullDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataAbridged struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataAbridgedDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataFull struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataFullDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataIngest struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataIngestDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataIngestDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetAbridgedDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetAbridgedDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetFull struct {
	// Array of UDL UUIDs of one or more AttitudeSet records associated with this set.  For example, a spacecraft Attitude Ephemeris Set might include a reference to an Attitude Parameter Message defining the sensor to body frame transformation for a sensor onboard the spacecraft, which allows for calculation of the sensor orientation in frame2 of the attitude ephemeris.
	AsRef *[]string `json:"asRef,omitempty"`

	// Collection of attitude data associated with this Attitude Set
	AttitudeList *[]AttitudeDataFull `json:"attitudeList,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetFullDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetFullDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetIngest struct {
	// Array of UDL UUIDs of one or more AttitudeSet records associated with this set.  For example, a spacecraft Attitude Ephemeris Set might include a reference to an Attitude Parameter Message defining the sensor to body frame transformation for a sensor onboard the spacecraft, which allows for calculation of the sensor orientation in frame2 of the attitude ephemeris.
	AsRef *[]string `json:"asRef,omitempty"`

	// Collection of attitude data associated with this Attitude Set
	AttitudeList *[]AttitudeDataIngest `json:"attitudeList,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetIngestDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetIngestDataMode string

// Detailed information on a spacecraft battery type compiled by a particular source. A Battery record may have multiple details records from several sources.
type BatteryDetailsFull struct {
	// Battery capacity in Ah
	Capacity *float64 `json:"capacity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryDetailsFullDataMode `json:"dataMode"`

	// Battery description/notes
	Description *string `json:"description,omitempty"`

	// Depth of discharge as a percentage/fraction
	DischargeDepth *float64 `json:"dischargeDepth,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent battery type record
	IdBattery string `json:"idBattery"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the battery
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Battery model number or name
	Model *string `json:"model,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of battery technology (e.g. Ni-Cd, Ni-H2, Li-ion, etc.)
	Technology *string `json:"technology,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryDetailsFullDataMode string

// Model representation of specific spacecraft battery types
type BatteryFull struct {
	// Read-only collection of additional BatteryDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/batterydetails operations.
	BatteryDetails *[]BatteryDetailsFull `json:"batteryDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Battery name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryFullDataMode string

// DataMode defines model for DataMode.
type DataMode string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetAbridged struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetAbridgedDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetAbridgedDataMode string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetFull struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// Read-only start time at which this elset was the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// Read-only end time at which this elset was no longer the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetFullDataMode string

// ElsetFullSourcedDataTypes defines model for ElsetFull.SourcedDataTypes.
type ElsetFullSourcedDataTypes string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetIngest struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetIngestDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetIngestSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetIngestDataMode string

// ElsetIngestSourcedDataTypes defines model for ElsetIngest.SourcedDataTypes.
type ElsetIngestSourcedDataTypes string

// Known launch vehicle engine details and performance characteristics and limits compiled by a particular source.  A launch vehicle engine may have several details records from multiple sources.
type EngineDetailsFull struct {
	// Launch engine maximum burn time in seconds
	BurnTime *float64 `json:"burnTime,omitempty"`

	// Engine chamber pressure in bars
	ChamberPressure *float64 `json:"chamberPressure,omitempty"`

	// Engine characteristic type (e.g. Electric, Mono-propellant, Bi-propellant, etc.)
	CharacteristicType *string `json:"characteristicType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Engine cycle type (e.g. Electrostatic Ion, Pressure Fed, Hall, Catalytic Decomposition, etc.)
	CycleType *string `json:"cycleType,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineDetailsFullDataMode `json:"dataMode"`

	// Engine type or family
	Family *string `json:"family,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent engine record
	IdEngine string `json:"idEngine"`

	// Organization ID of the engine manufacturer
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Engine maximum number of firings
	MaxFirings *int32 `json:"maxFirings,omitempty"`

	// Notes/Description of the engine
	Notes *string `json:"notes,omitempty"`

	// Engine nozzle expansion ratio
	NozzleExpansionRatio *float64 `json:"nozzleExpansionRatio,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Oxidizer type (e.g. Nitrogen Tetroxide, Liquid Oxygen, etc)
	Oxidizer *string `json:"oxidizer,omitempty"`

	// Propellant/fuel type of the engine (e.g. Liquid Hydrogen, Kerosene, Aerozine, etc).
	Propellant *string `json:"propellant,omitempty"`

	// Engine maximum thrust at sea level in Kilo-Newtons
	SeaLevelThrust *float64 `json:"seaLevelThrust,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Launch engine specific impulse in seconds
	SpecificImpulse *float64 `json:"specificImpulse,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Engine maximum thrust in a vacuum in Kilo-Newtons
	VacuumThrust *float64 `json:"vacuumThrust,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineDetailsFullDataMode string

// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
type EngineFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineFullDataMode `json:"dataMode"`

	// Read-only collection of additional EngineDetails by various sources for this engine, ignored on create/update. These details must be created separately via the /udl/enginedetails operations.
	EngineDetails *[]EngineDetailsFull `json:"engineDetails,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Engine name/variant
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineFullDataMode string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationAbridged `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitAbridged `json:"onOrbit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityAbridgedOwnerType `json:"ownerType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityAbridgedType `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityAbridgedDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityAbridgedOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityAbridgedType string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityFullDataMode `json:"dataMode"`

	// Unique identifier of the record
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
	OperatingUnit *OperatingunitFull `json:"operatingUnit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityFullOwnerType `json:"ownerType,omitempty"`

	// Read-only collection of RF bands utilized by this entity for communication and/or operation
	RfBands *[]RFBandFull `json:"rfBands,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of statuses which can be collected by multiple sources
	StatusCollection *[]StatusFull `json:"statusCollection,omitempty"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityFullType `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// List of URLs to additional details/documents for this entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityFullDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityFullOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityFullType string

// EphemFormatType defines model for EphemFormatType.
type EphemFormatType string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetAbridged struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetAbridgedCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetAbridgedDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetAbridgedReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetAbridgedDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetFull struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetFullDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisFull `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
	StateVector *StateVectorFull `json:"stateVector,omitempty"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetFullReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetIngest struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetIngestCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetIngestDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisIngest `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetIngestReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetIngestCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetIngestDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetIngestReferenceFrame string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisAbridgedDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisFullDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisFullDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisIngestDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisIngestDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationAbridged struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationAbridgedDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationFull struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationFullDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationFullDataMode string

// Read-only collection of antennas on this on-orbit object
type OnorbitAntennaFull struct {
	// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
	Antenna *AntennaFull `json:"antenna,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the antenna
	IdAntenna string `json:"idAntenna"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAntennaFullDataMode string

// Read-only collection of batteries on this on-orbit object
type OnorbitBatteryFull struct {
	// Model representation of specific spacecraft battery types
	Battery *BatteryFull `json:"battery,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitBatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the battery
	IdBattery string `json:"idBattery"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of batteries on the spacecraft of the type identified by idBattery
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitBatteryFullDataMode string

// Contains details of the OnOrbit object
type OnorbitDetailsFull struct {
	// Mass of fuel and disposables at launch time in kg
	AdditionalMass *float64 `json:"additionalMass,omitempty"`

	// The radius used for long-term debris environment projection analyses that is not as conservative as COLA Radius, in meters
	AdeptRadius *float64 `json:"adeptRadius,omitempty"`

	// Spacecraft beginning of life fuel mass, in orbit, in kg
	BolFuelMass *float64 `json:"bolFuelMass,omitempty"`

	// Average cross sectional area of the bus in meters squared
	BusCrossSection *float64 `json:"busCrossSection,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Maximum dimension of the box circumscribing the spacecraft (d = sqrt(a*a + b*b + c*c) where a is the tip-to-tip dimension, b and c are perpendicular to that.) in meters
	ColaRadius *float64 `json:"colaRadius,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Average cross sectional area in meters squared
	CrossSection *float64 `json:"crossSection,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitDetailsFullDataMode `json:"dataMode"`

	// GEO drift rate, if applicable in degrees per day
	DriftRate *float64 `json:"driftRate,omitempty"`

	// Spacecraft dry mass (without fuel or disposables) in kg
	DryMass *float64 `json:"dryMass,omitempty"`

	// Estimated maxmimum burn duration for the object
	EstDeltaVDuration *float64 `json:"estDeltaVDuration,omitempty"`

	// Estimated remaining fuel for the object in kg
	FuelRemaining *float64 `json:"fuelRemaining,omitempty"`

	// GEO slot if applicable, in degrees. -180 (West of Prime Meridian) to 180 degrees (East of Prime Meridian). Prime Meridian is 0.
	GeoSlot *float64 `json:"geoSlot,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// UUID of the parent Onorbit record
	IdOnOrbit string `json:"idOnOrbit"`

	// The name of the source who last provided an observation for this idOnOrbit
	LastObSource *string `json:"lastObSource,omitempty"`

	// Time of last reported observation for this object in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Nominal mass of spacecraft and fuel at launch time, in kg
	LaunchMass *float64 `json:"launchMass,omitempty"`

	// Maximum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMax *float64 `json:"launchMassMax,omitempty"`

	// Minimum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMin *float64 `json:"launchMassMin,omitempty"`

	// Maximum delta V available for this on-orbit spacecraft
	MaxDeltaV *float64 `json:"maxDeltaV,omitempty"`

	// Maximum dimension across the spacecraft (e.g., tip-to-tip across the solar panel arrays) in meters
	MaxRadius *float64 `json:"maxRadius,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Current/latest radar cross section in meters squared
	Rcs *float64 `json:"rcs,omitempty"`

	// Maximum radar cross section in meters squared
	RcsMax *float64 `json:"rcsMax,omitempty"`

	// Mean radar cross section in meters squared
	RcsMean *float64 `json:"rcsMean,omitempty"`

	// Minimum radar cross section in meters squared
	RcsMin *float64 `json:"rcsMin,omitempty"`

	// Spacecraft deployed area of solar array in sq meters
	SolarArrayArea *float64 `json:"solarArrayArea,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Current/latest visual magnitude in M
	Vismag *float64 `json:"vismag,omitempty"`

	// Maximum visual magnitude in M
	VismagMax *float64 `json:"vismagMax,omitempty"`

	// Mean visual magnitude in M
	VismagMean *float64 `json:"vismagMean,omitempty"`

	// Minimum visual magnitude in M
	VismagMin *float64 `json:"vismagMin,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitDetailsFullDataMode string

// Read-only collection of solar arrays on this on-orbit object
type OnorbitSolarArrayFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitSolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// ID of the SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of solar arrays on the spacecraft of the type identified by idSolarArray
	Quantity *int32 `json:"quantity,omitempty"`

	// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
	SolarArray *SolarArrayFull `json:"solarArray,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitSolarArrayFullDataMode string

// Read-only collection of thrusters (engines) on this on-orbit object
type OnorbitThrusterFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitThrusterFullDataMode `json:"dataMode"`

	// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
	Engine *EngineFull `json:"engine,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Engine
	IdEngine string `json:"idEngine"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of engines/thrusters on the spacecraft of the type identified by idEngine
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitThrusterFullDataMode string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitAbridged struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitAbridgedCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAbridgedDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitAbridgedObjectType `json:"objectType,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Source of the data
	Source string `json:"source"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitAbridgedCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAbridgedDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitAbridgedObjectType string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitFull struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Read-only collection of antennas on this on-orbit object
	Antennas *[]OnorbitAntennaFull `json:"antennas,omitempty"`

	// Read-only collection of batteries on this on-orbit object
	Batteries *[]OnorbitBatteryFull `json:"batteries,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitFullCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitFullDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// Read-only entity details (only returned/used on detail queries).
	EntityCollection *[]EntityFull `json:"entityCollection,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitFullObjectType `json:"objectType,omitempty"`

	// Read-only collection of details for this on-orbit object
	OnorbitDetails *[]OnorbitDetailsFull `json:"onorbitDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Read-only collection of solar arrays on this on-orbit object
	SolarArrays *[]OnorbitSolarArrayFull `json:"solarArrays,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of thrusters (engines) on this on-orbit object
	Thrusters *[]OnorbitThrusterFull `json:"thrusters,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitFullCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitFullDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitFullObjectType string

// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
type OperatingunitFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OperatingunitFullDataMode `json:"dataMode"`

	// Description of the operating unit
	Description *string `json:"description,omitempty"`

	// Unique identifier of the contact for this operating unit
	IdContact *string `json:"idContact,omitempty"`

	// Unique identifier of the location record for this operating unit
	IdLocation *string `json:"idLocation,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Unique identifier of the organization record for this operating unit
	IdOrganization *string `json:"idOrganization,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Name of the operating unit
	Name string `json:"name"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	Organization *OrganizationFull `json:"organization,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OperatingunitFullDataMode string

// Model representation of additional detailed organization data as collected by a particular source.
type OrganizationDetailsFull struct {
	// Designated broker for this organization.
	Broker *string `json:"broker,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Executive Officer.
	Ceo *string `json:"ceo,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Financial Officer.
	Cfo *string `json:"cfo,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Technology Officer.
	Cto *string `json:"cto,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationDetailsFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// For organizations of type CORPORATION, the company EBITDA value as of financialYearEndDate in US Dollars.
	Ebitda *float64 `json:"ebitda,omitempty"`

	// For organizations of type CORPORATION, notes on company financials.
	FinancialNotes *string `json:"financialNotes,omitempty"`

	// For organizations of type CORPORATION, the effective financial year end date for revenue, EBITDA, and profit values.
	FinancialYearEndDate *time.Time `json:"financialYearEndDate,omitempty"`

	// Satellite fleet planning notes for this organization.
	FleetPlanNotes *string `json:"fleetPlanNotes,omitempty"`

	// Former organization ID (if this organization previously existed as another organization)
	FormerOrgId *string `json:"formerOrgId,omitempty"`

	// Total number of FTEs in this organization.
	Ftes *int32 `json:"ftes,omitempty"`

	// Unique identifier of the parent organization.
	IdOrganization string `json:"idOrganization"`

	// Mass ranking for this organization.
	MassRanking *int32 `json:"massRanking,omitempty"`

	// Organization details name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Parent organization ID of this organization if it is a child organization
	ParentOrgId *string `json:"parentOrgId,omitempty"`

	// For organizations of type CORPORATION, total annual profit as of financialYearEndDate in US Dollars.
	Profit *float64 `json:"profit,omitempty"`

	// For organizations of type CORPORATION, total annual revenue as of financialYearEndDate in US Dollars.
	Revenue *float64 `json:"revenue,omitempty"`

	// Revenue ranking for this organization.
	RevenueRanking *int32 `json:"revenueRanking,omitempty"`

	// The name of the risk manager for the organization.
	RiskManager *string `json:"riskManager,omitempty"`

	// Notes on the services provided by the organization.
	ServicesNotes *string `json:"servicesNotes,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationDetailsFullDataMode string

// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
type OrganizationFull struct {
	// Boolean indicating if this organization is currently active.
	Active *bool `json:"active,omitempty"`

	// Subtype or category of the organization (e.g. Private company, stock market quoted company, subsidiary, goverment department/agency, etc).
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code of this organization's headquarters.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// Optional externally provided identifier for this row
	ExternalId *string `json:"externalId,omitempty"`

	// Organization name
	Name string `json:"name"`

	// Read-only collection of additional OrganizationDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/organizationdetails operations.
	OrganizationDetails *[]OrganizationDetailsFull `json:"organizationDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Type of organization (e.g. GOVERNMENT, CORPORATION, CONSORTIUM, ACADEMIC)
	Type string `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationFullDataMode string

// Details on a particular Radio Frequency (RF) band, also known as a carrier, which may be in use by any type of Entity for communications or operations.
type RFBandFull struct {
	// Name of the band of this RF range (e.g. X,K,Ku,Ka,L,S,C,UHF,VHF,EHF,SHF,UNK,VLF,HF,E,Q,V,W). See RFBandType for more details and descriptions of each band name.
	Band *string `json:"band,omitempty"`

	// RF Band frequency range bandwidth in Mhz
	Bandwidth *float64 `json:"bandwidth,omitempty"`

	// Angle between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Center frequency of RF frequency range, if applicable, in Mhz
	CenterFreq *float64 `json:"centerFreq,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode RFBandFullDataMode `json:"dataMode"`

	// RF Range edge gain, in dBi
	EdgeGain *float64 `json:"edgeGain,omitempty"`

	// ERP is defined as the RMS power input in decibel watts required to a lossless half-wave dipole antenna to give the same maximum power density far from the antenna as the actual transmitter. It is equal to the power input to the transmitter''s antenna multiplied by the antenna gain relative to a half-wave dipole. Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Eirp *float64 `json:"eirp,omitempty"`

	// Effective Radiated Power (ERP) is the total power in decibel watts radiated by an actual antenna relative to a half-wave dipole rather than a theoretical isotropic antenna. A half-wave dipole has a gain of 2.15 dB compared to an isotropic antenna.  EIRP(dB) = ERP (dB)+2.15 Db or EIRP (W) = 1.64*ERP(W). Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Erp *float64 `json:"erp,omitempty"`

	// End/maximum of transmit RF frequency range, if applicable, in Mhz
	FreqMax *float64 `json:"freqMax,omitempty"`

	// Start/minimum of transmit RF frequency range, if applicable, in Mhz
	FreqMin *float64 `json:"freqMin,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Entity which uses this band
	IdEntity string `json:"idEntity"`

	// RF Band mode (e.g. TX, RX)
	Mode *RFBandFullMode `json:"mode,omitempty"`

	// Optional RF Band name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// RF Range maximum gain, in dBi
	PeakGain *float64 `json:"peakGain,omitempty"`

	// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
	Polarization *RFBandFullPolarization `json:"polarization,omitempty"`

	// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
	Purpose *RFBandFullPurpose `json:"purpose,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type RFBandFullDataMode string

// RF Band mode (e.g. TX, RX)
type RFBandFullMode string

// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
type RFBandFullPolarization string

// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
type RFBandFullPurpose string

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsAbridgedDataMode string

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsFullDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorAbridged struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorAbridgedDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityAbridged `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeAbridged `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsAbridged `json:"sensorStats,omitempty"`
	SensorType  *SensortypeAbridged    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsAbridged `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsAbridged `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorAbridgedDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorFull struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorFullDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityFull `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeFull `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsFull `json:"sensorStats,omitempty"`
	SensorType  *SensortypeFull    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsFull `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsFull `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorFullDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsAbridged struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsAbridgedDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsAbridgedDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsFull struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsFullDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent sensor
	IdSensor string `json:"idSensor"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsFullDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsAbridgedDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsFullDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsFullDataMode string

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorobservationtypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorobservationtypeFullDataMode string

// SensortypeAbridged defines model for Sensortype_Abridged.
type SensortypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32            `json:"id,omitempty"`
	SensorCollection *[]SensorAbridged `json:"sensorCollection,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// SensortypeFull defines model for Sensortype_Full.
type SensortypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensortypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32        `json:"id,omitempty"`
	SensorCollection *[]SensorFull `json:"sensorCollection,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensortypeFullDataMode string

// Model representation of Information on spacecraft SolarArrayDetails. A SolarArray may have multiple details records compiled by various sources.
type SolarArrayDetailsFull struct {
	// Solar Array area in square meters
	Area *float64 `json:"area,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayDetailsFullDataMode `json:"dataMode"`

	// Solar array description/notes
	Description *string `json:"description,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Unique identifier of the parent SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Solar array junction technology (e.g. Triple)
	JunctionTechnology *string `json:"junctionTechnology,omitempty"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the solar array
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Solar Array span in meters
	Span *float64 `json:"span,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Solar array technology (e.g. Ga-As)
	Technology *string `json:"technology,omitempty"`

	// Type of solar array (e.g. U Shaped)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayDetailsFullDataMode string

// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
type SolarArrayFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Solar Array name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Read-only collection of additional SolarArrayDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/solararraydetails operations.
	SolarArrayDetails *[]SolarArrayDetailsFull `json:"solarArrayDetails,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayFullDataMode string

// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
type StateVectorFull struct {
	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// First derivative of drag/ballistic coefficient (m2/kg-s).
	BDot *float64 `json:"bDot,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Model parameter value for center of mass offset (m).
	CmOffset *float64 `json:"cmOffset,omitempty"`

	// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	Cov *[]float64 `json:"cov,omitempty"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *StateVectorFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StateVectorFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
	DragCoeff *float64 `json:"dragCoeff,omitempty"`

	// Drag model used for this vector (e.g. HARRIS-PRIESTER, JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR) (w/kg).
	Edr *float64 `json:"edr,omitempty"`

	// Start time at which this state vector was the 'current' state vector for its satellite.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// End time at which this state vector was no longer the 'current' state vector for its satellite.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
	//
	// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
	//
	// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	//
	//
	//
	// The ordering of values is as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
	//
	// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
	//
	// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
	//
	// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
	//
	// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
	//
	// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
	//
	// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
	//
	// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
	//
	// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
	//
	// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
	//
	// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
	//
	// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
	//
	// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
	//
	// :
	//
	// :
	//
	// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
	EqCov *[]float64 `json:"eqCov,omitempty"`

	// Integrator error control.
	ErrorControl *float64 `json:"errorControl,omitempty"`

	// Boolean indicating use of fixed step size for this vector.
	FixedStep *bool `json:"fixedStep,omitempty"`

	// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
	Iau1980Terms *int32 `json:"iau1980Terms,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Boolean indicating use of in-track thrust perturbations for this vector.
	InTrackThrust *bool `json:"inTrackThrust,omitempty"`

	// Integrator Mode
	IntegratorMode *string `json:"integratorMode,omitempty"`

	// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
	LeapSecondTime *time.Time `json:"leapSecondTime,omitempty"`

	// Boolean indicating use of lunar/solar perturbations for this vector.
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
	Partials *string `json:"partials,omitempty"`

	// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN)
	Pedigree *string `json:"pedigree,omitempty"`

	// Polar Wander Motion X (arc seconds).
	PolarMotionX *float64 `json:"polarMotionX,omitempty"`

	// Polar Wander Motion Y (arc seconds).
	PolarMotionY *float64 `json:"polarMotionY,omitempty"`

	// Approximate position uncertainty (kilometers)
	PosUnc *float64 `json:"posUnc,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *StateVectorFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Epoch revolution number.
	RevNo *int32 `json:"revNo,omitempty"`

	// Weighted Root Mean Squared (RMS) of last differential correction on the target object.
	Rms *float64 `json:"rms,omitempty"`

	// Satellite/Catalog number of the target OnOrbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
	SigmaPosUVW *[]float64 `json:"sigmaPosUVW,omitempty"`

	// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
	SigmaVelUVW *[]float64 `json:"sigmaVelUVW,omitempty"`

	// Average solar flux geomagnetic index.
	SolarFluxAPAvg *float64 `json:"solarFluxAPAvg,omitempty"`

	// F10 (10.7 cm) solar flux value.
	SolarFluxF10 *float64 `json:"solarFluxF10,omitempty"`

	// F10 (10.7 cm) solar flux 81-day average value.
	SolarFluxF10Avg *float64 `json:"solarFluxF10Avg,omitempty"`

	// Boolean indicating use of solar radiation pressure perturbations for this vector.
	SolarRadPress *bool `json:"solarRadPress,omitempty"`

	// Area-to-mass ratio coefficient for solar radiation pressure
	SolarRadPressCoeff *float64 `json:"solarRadPressCoeff,omitempty"`

	// Boolean indicating use of solid earth tide perturbations for this vector.
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *StateVectorFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Integrator step mode (AUTO, TIME, or S).
	StepMode *string `json:"stepMode,omitempty"`

	// Initial integration step size (seconds).
	StepSize *float64 `json:"stepSize,omitempty"`

	// Initial step size selection (AUTO or MANUAL).
	StepSizeSelection *string `json:"stepSizeSelection,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
	TaiUtc *float64 `json:"taiUtc,omitempty"`

	// Model parameter value for thrust acceleration (m/s2).
	ThrustAccel *float64 `json:"thrustAccel,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`

	// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
	Ut1Rate *float64 `json:"ut1Rate,omitempty"`

	// Universal Time-1 (UT1) minus UTC offset, in seconds.
	Ut1Utc *float64 `json:"ut1Utc,omitempty"`

	// Approximate velocity uncertainty
	VelUnc *float64 `json:"velUnc,omitempty"`

	// Cartesian X position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos *float64 `json:"xpos,omitempty"`

	// Cartesian X velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel *float64 `json:"xvel,omitempty"`

	// Cartesian Y position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos *float64 `json:"ypos,omitempty"`

	// Cartesian Y velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel *float64 `json:"yvel,omitempty"`

	// Cartesian Z position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zpos *float64 `json:"zpos,omitempty"`

	// Cartesian Z velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel *float64 `json:"zvel,omitempty"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type StateVectorFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StateVectorFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type StateVectorFullReferenceFrame string

// StateVectorFullSourcedDataTypes defines model for StateVectorFull.SourcedDataTypes.
type StateVectorFullSourcedDataTypes string

// Status for a particular Entity. An entity may have multiple status records collected by various sources.
type StatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StatusFullDataMode `json:"dataMode"`

	// The declassification date of this data, in ISO 8601 UTC format.
	DeclassificationDate *time.Time `json:"declassificationDate,omitempty"`

	// Declassification string of this data.
	DeclassificationString *string `json:"declassificationString,omitempty"`

	// The sources or SCG references from which the classification of this data is derived.
	DerivedFrom *string `json:"derivedFrom,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent entity
	IdEntity string `json:"idEntity"`

	// Comments describing the status creation and or updates to an entity
	Notes *string `json:"notes,omitempty"`

	// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	OpsCap *StatusFullOpsCap `json:"opsCap,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
	State               *StatusFullState `json:"state,omitempty"`
	SubStatusCollection *[]SubStatusFull `json:"subStatusCollection,omitempty"`

	// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	SysCap *StatusFullSysCap `json:"sysCap,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StatusFullDataMode string

// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullOpsCap string

// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
type StatusFullState string

// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullSysCap string

// Additional sub-system or capability status for the parent entity.
type SubStatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SubStatusFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Descriptions and/or comments associated with the sub-status
	Notes string `json:"notes"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
	Status SubStatusFullStatus `json:"status"`

	// Id of the parent status
	StatusId string `json:"statusId"`

	// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
	Type SubStatusFullType `json:"type"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SubStatusFullDataMode string

// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
type SubStatusFullStatus string

// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
type SubStatusFullType string

// FiledropEphemPostIdParams defines parameters for FiledropEphemPostId.
type FiledropEphemPostIdParams struct {
	// Unique identifier of the on-orbit satellite object.
	IdOnOrbit string `form:"idOnOrbit" json:"idOnOrbit"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	Classification string `form:"classification" json:"classification"`

	// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
	DataMode DataMode `form:"dataMode" json:"dataMode"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
	HasMnvr bool `form:"hasMnvr" json:"hasMnvr"`

	// Ephemeris type.
	Type string `form:"type" json:"type"`

	// Ephemeris category.
	Category string `form:"category" json:"category"`

	// Ephemeris format as documented in Flight Safety Handbook.
	EphemFormatType EphemFormatType `form:"ephemFormatType" json:"ephemFormatType"`

	// Optional origin of the Ephemeris.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`

	// Source of the Ephemeris data.
	Source string `form:"source" json:"source"`
}

// FiledropUdlAisPostIdJSONBody defines parameters for FiledropUdlAisPostId.
type FiledropUdlAisPostIdJSONBody = []AISIngest

// FiledropUdlAttitudesetPostIdJSONBody defines parameters for FiledropUdlAttitudesetPostId.
type FiledropUdlAttitudesetPostIdJSONBody = AttitudeSetIngest

// FiledropUdlElsetPostIdJSONBody defines parameters for FiledropUdlElsetPostId.
type FiledropUdlElsetPostIdJSONBody = []ElsetIngest

// FiledropUdlEphsetPostIdJSONBody defines parameters for FiledropUdlEphsetPostId.
type FiledropUdlEphsetPostIdJSONBody = EphemerisSetIngest

// FindAllParams defines parameters for FindAll.
type FindAllParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateJSONBody defines parameters for Create.
type CreateJSONBody = AISIngest

// CountDuplicateParams defines parameters for CountDuplicate.
type CountDuplicateParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulksJSONBody defines parameters for CreateBulks.
type CreateBulksJSONBody = []AISIngest

// FindAllHistoryParams defines parameters for FindAllHistory.
type FindAllHistoryParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodrParams defines parameters for FindAllHistoryAodr.
type FindAllHistoryAodrParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistoryParams defines parameters for CountHistory.
type CountHistoryParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuplesParams defines parameters for FindAllTuples.
type FindAllTuplesParams struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllWithStream1Params defines parameters for FindAllWithStream1.
type FindAllWithStream1Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// CountDuplicate2Params defines parameters for CountDuplicate2.
type CountDuplicate2Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllHistory4Params defines parameters for FindAllHistory4.
type FindAllHistory4Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllHistoryAodr4Params defines parameters for FindAllHistoryAodr4.
type FindAllHistoryAodr4Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// CountHistory4Params defines parameters for CountHistory4.
type CountHistory4Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllTuples7Params defines parameters for FindAllTuples7.
type FindAllTuples7Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllWithStream2Params defines parameters for FindAllWithStream2.
type FindAllWithStream2Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// Create7JSONBody defines parameters for Create7.
type Create7JSONBody = AttitudeSetIngest

// CountREST5Params defines parameters for CountREST5.
type CountREST5Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllHistory5Params defines parameters for FindAllHistory5.
type FindAllHistory5Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllHistoryAodr5Params defines parameters for FindAllHistoryAodr5.
type FindAllHistoryAodr5Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// CountHistory5Params defines parameters for CountHistory5.
type CountHistory5Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllTuples8Params defines parameters for FindAllTuples8.
type FindAllTuples8Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllWithStream8Params defines parameters for FindAllWithStream8.
type FindAllWithStream8Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// Create28JSONBody defines parameters for Create28.
type Create28JSONBody = ElsetIngest

// CountREST24Params defines parameters for CountREST24.
type CountREST24Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// CreateBulks8JSONBody defines parameters for CreateBulks8.
type CreateBulks8JSONBody = []ElsetIngest

// CreateBulks8Params defines parameters for CreateBulks8.
type CreateBulks8Params struct {
	// Boolean indicating if these elsets should be checked for duplicates, default is not to
	DupeCheck *bool `form:"dupeCheck,omitempty" json:"dupeCheck,omitempty"`
}

// CreateBulkFromTLEParams defines parameters for CreateBulkFromTLE.
type CreateBulkFromTLEParams struct {
	// Data mode of the passed elsets (REAL, TEST, etc)
	DataMode string `form:"dataMode" json:"dataMode"`

	// Dissemination control of the passed elsets (e.g. to support tagging with proprietary markings)
	Control *string `form:"control,omitempty" json:"control,omitempty"`

	// Boolean indicating if these elsets should be set as the 'current' for their corresponding on-orbit/satellite numbers.
	MakeCurrent bool `form:"makeCurrent" json:"makeCurrent"`

	// Source of the elset data.
	Source string `form:"source" json:"source"`

	// Origin of the elset data.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`

	// Boolean indicating if a shell Onorbit/satellite should be created if the passed satellite number doesn't exist.
	AutoCreateSats *bool `form:"autoCreateSats,omitempty" json:"autoCreateSats,omitempty"`

	// Optional comma-delineated list of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// CurrentTupleParams defines parameters for CurrentTuple.
type CurrentTupleParams struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// FindAllHistory16Params defines parameters for FindAllHistory16.
type FindAllHistory16Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllHistoryAodr16Params defines parameters for FindAllHistoryAodr16.
type FindAllHistoryAodr16Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// CountHistory16Params defines parameters for CountHistory16.
type CountHistory16Params struct {
	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllTuples29Params defines parameters for FindAllTuples29.
type FindAllTuples29Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// FindAllWithStream9Params defines parameters for FindAllWithStream9.
type FindAllWithStream9Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountDuplicate6Params defines parameters for CountDuplicate6.
type CountDuplicate6Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistory17Params defines parameters for FindAllHistory17.
type FindAllHistory17Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistoryAodr17Params defines parameters for FindAllHistoryAodr17.
type FindAllHistoryAodr17Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountHistory17Params defines parameters for CountHistory17.
type CountHistory17Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllTuples32Params defines parameters for FindAllTuples32.
type FindAllTuples32Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllWithStream10Params defines parameters for FindAllWithStream10.
type FindAllWithStream10Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// Create32JSONBody defines parameters for Create32.
type Create32JSONBody = EphemerisSetIngest

// CountREST27Params defines parameters for CountREST27.
type CountREST27Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistory18Params defines parameters for FindAllHistory18.
type FindAllHistory18Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistoryAodr18Params defines parameters for FindAllHistoryAodr18.
type FindAllHistoryAodr18Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// CountHistory18Params defines parameters for CountHistory18.
type CountHistory18Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllTuples33Params defines parameters for FindAllTuples33.
type FindAllTuples33Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FiledropUdlAisPostIdJSONRequestBody defines body for FiledropUdlAisPostId for application/json ContentType.
type FiledropUdlAisPostIdJSONRequestBody = FiledropUdlAisPostIdJSONBody

// FiledropUdlAttitudesetPostIdJSONRequestBody defines body for FiledropUdlAttitudesetPostId for application/json ContentType.
type FiledropUdlAttitudesetPostIdJSONRequestBody = FiledropUdlAttitudesetPostIdJSONBody

// FiledropUdlElsetPostIdJSONRequestBody defines body for FiledropUdlElsetPostId for application/json ContentType.
type FiledropUdlElsetPostIdJSONRequestBody = FiledropUdlElsetPostIdJSONBody

// FiledropUdlEphsetPostIdJSONRequestBody defines body for FiledropUdlEphsetPostId for application/json ContentType.
type FiledropUdlEphsetPostIdJSONRequestBody = FiledropUdlEphsetPostIdJSONBody

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = CreateJSONBody

// CreateBulksJSONRequestBody defines body for CreateBulks for application/json ContentType.
type CreateBulksJSONRequestBody = CreateBulksJSONBody

// Create7JSONRequestBody defines body for Create7 for application/json ContentType.
type Create7JSONRequestBody = Create7JSONBody

// Create28JSONRequestBody defines body for Create28 for application/json ContentType.
type Create28JSONRequestBody = Create28JSONBody

// CreateBulks8JSONRequestBody defines body for CreateBulks8 for application/json ContentType.
type CreateBulks8JSONRequestBody = CreateBulks8JSONBody

// Create32JSONRequestBody defines body for Create32 for application/json ContentType.
type Create32JSONRequestBody = Create32JSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAisPostId request with any body
	FiledropUdlAisPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAisPostId(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAttitudesetPostId request with any body
	FiledropUdlAttitudesetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAttitudesetPostId(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll request
	FindAll(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create request with any body
	CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate request
	CountDuplicate(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks request with any body
	CreateBulksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory request
	FindAllHistory(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr request
	FindAllHistoryAodr(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory request
	CountHistory(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp request
	Queryhelp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples request
	FindAllTuples(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream1 request
	FindAllWithStream1(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate2 request
	CountDuplicate2(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory4 request
	FindAllHistory4(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr4 request
	FindAllHistoryAodr4(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory4 request
	CountHistory4(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp7 request
	Queryhelp7(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples7 request
	FindAllTuples7(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream2 request
	FindAllWithStream2(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create7 request with any body
	Create7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create7(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST5 request
	CountREST5(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory5 request
	FindAllHistory5(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr5 request
	FindAllHistoryAodr5(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory5 request
	CountHistory5(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp8 request
	Queryhelp8(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples8 request
	FindAllTuples8(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find6 request
	Find6(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Current request
	Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp21 request
	Queryhelp21(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create28 request with any body
	Create28WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create28(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST24 request
	CountREST24(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Current1 request
	Current1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentTuple request
	CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory16 request
	FindAllHistory16(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr16 request
	FindAllHistoryAodr16(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory16 request
	CountHistory16(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp31 request
	Queryhelp31(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples29 request
	FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find25 request
	Find25(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream9 request
	FindAllWithStream9(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate6 request
	CountDuplicate6(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory17 request
	FindAllHistory17(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr17 request
	FindAllHistoryAodr17(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory17 request
	CountHistory17(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp34 request
	Queryhelp34(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples32 request
	FindAllTuples32(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream10 request
	FindAllWithStream10(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create32 request with any body
	Create32WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create32(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST27 request
	CountREST27(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile1 request
	GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory18 request
	FindAllHistory18(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr18 request
	FindAllHistoryAodr18(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory18 request
	CountHistory18(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp35 request
	Queryhelp35(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples33 request
	FindAllTuples33(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find29 request
	Find29(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropEphemPostIdRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAisPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	
	req, err := NewFiledropUdlAisPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAisPostId(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	fmt.Println(fmt.Sprintf("client.server: %s", c.Server))
	// fmt.Println(fmt.Sprintf("body: %w", body[0]))
	fmt.Println("request.body:")
	fmt.Println(body[0])
	req, err := NewFiledropUdlAisPostIdRequest(c.Server, body)
	fmt.Println(fmt.Sprintf("client.req: %s", req.URL))
	fmt.Println(fmt.Sprintf("client.body: %s", req.Body))
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAttitudesetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAttitudesetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAttitudesetPostId(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAttitudesetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodrRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelpRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuplesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream1(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate2(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory4(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr4(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory4(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp7(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp7Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples7(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples7Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream2(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate7RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create7(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate7Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST5(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory5(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr5(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory5(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp8(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp8Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples8(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find6(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind6Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp21(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp21Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create28WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate28RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create28(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate28Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST24(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST24Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8RequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8Request(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulkFromTLERequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Current1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrent1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentTupleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory16(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr16(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory16(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp31(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp31Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples29Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find25(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind25Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream9(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream9Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate6(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate6Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory17(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr17(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory17(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp34(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp34Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples32(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream10(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream10Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create32WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate32RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create32(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate32Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST27(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST27Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFile1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory18(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr18(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory18(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp35(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp35Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples33(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples33Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find29(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind29Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewFiledropEphemPostIdRequestWithBody generates requests for FiledropEphemPostId with any type of body
func NewFiledropEphemPostIdRequestWithBody(server string, params *FiledropEphemPostIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/ephem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idOnOrbit", runtime.ParamLocationQuery, params.IdOnOrbit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classification", runtime.ParamLocationQuery, params.Classification); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasMnvr", runtime.ParamLocationQuery, params.HasMnvr); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, params.Category); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ephemFormatType", runtime.ParamLocationQuery, params.EphemFormatType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAisPostIdRequest calls the generic FiledropUdlAisPostId builder with application/json body
func NewFiledropUdlAisPostIdRequest(server string, body FiledropUdlAisPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAisPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAisPostIdRequestWithBody generates requests for FiledropUdlAisPostId with any type of body
func NewFiledropUdlAisPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAttitudesetPostIdRequest calls the generic FiledropUdlAttitudesetPostId builder with application/json body
func NewFiledropUdlAttitudesetPostIdRequest(server string, body FiledropUdlAttitudesetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAttitudesetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAttitudesetPostIdRequestWithBody generates requests for FiledropUdlAttitudesetPostId with any type of body
func NewFiledropUdlAttitudesetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlElsetPostIdRequest calls the generic FiledropUdlElsetPostId builder with application/json body
func NewFiledropUdlElsetPostIdRequest(server string, body FiledropUdlElsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlElsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlElsetPostIdRequestWithBody generates requests for FiledropUdlElsetPostId with any type of body
func NewFiledropUdlElsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlEphsetPostIdRequest calls the generic FiledropUdlEphsetPostId builder with application/json body
func NewFiledropUdlEphsetPostIdRequest(server string, body FiledropUdlEphsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlEphsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlEphsetPostIdRequestWithBody generates requests for FiledropUdlEphsetPostId with any type of body
func NewFiledropUdlEphsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-ephset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllRequest generates requests for FindAll
func NewFindAllRequest(server string, params *FindAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDuplicateRequest generates requests for CountDuplicate
func NewCountDuplicateRequest(server string, params *CountDuplicateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulksRequest calls the generic CreateBulks builder with application/json body
func NewCreateBulksRequest(server string, body CreateBulksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulksRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulksRequestWithBody generates requests for CreateBulks with any type of body
func NewCreateBulksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistoryRequest generates requests for FindAllHistory
func NewFindAllHistoryRequest(server string, params *FindAllHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodrRequest generates requests for FindAllHistoryAodr
func NewFindAllHistoryAodrRequest(server string, params *FindAllHistoryAodrParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistoryRequest generates requests for CountHistory
func NewCountHistoryRequest(server string, params *CountHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelpRequest generates requests for Queryhelp
func NewQueryhelpRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuplesRequest generates requests for FindAllTuples
func NewFindAllTuplesRequest(server string, params *FindAllTuplesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream1Request generates requests for FindAllWithStream1
func NewFindAllWithStream1Request(server string, params *FindAllWithStream1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate2Request generates requests for CountDuplicate2
func NewCountDuplicate2Request(server string, params *CountDuplicate2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory4Request generates requests for FindAllHistory4
func NewFindAllHistory4Request(server string, params *FindAllHistory4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr4Request generates requests for FindAllHistoryAodr4
func NewFindAllHistoryAodr4Request(server string, params *FindAllHistoryAodr4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory4Request generates requests for CountHistory4
func NewCountHistory4Request(server string, params *CountHistory4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp7Request generates requests for Queryhelp7
func NewQueryhelp7Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples7Request generates requests for FindAllTuples7
func NewFindAllTuples7Request(server string, params *FindAllTuples7Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream2Request generates requests for FindAllWithStream2
func NewFindAllWithStream2Request(server string, params *FindAllWithStream2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate7Request calls the generic Create7 builder with application/json body
func NewCreate7Request(server string, body Create7JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate7RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate7RequestWithBody generates requests for Create7 with any type of body
func NewCreate7RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST5Request generates requests for CountREST5
func NewCountREST5Request(server string, params *CountREST5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory5Request generates requests for FindAllHistory5
func NewFindAllHistory5Request(server string, params *FindAllHistory5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr5Request generates requests for FindAllHistoryAodr5
func NewFindAllHistoryAodr5Request(server string, params *FindAllHistoryAodr5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory5Request generates requests for CountHistory5
func NewCountHistory5Request(server string, params *CountHistory5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp8Request generates requests for Queryhelp8
func NewQueryhelp8Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples8Request generates requests for FindAllTuples8
func NewFindAllTuples8Request(server string, params *FindAllTuples8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind6Request generates requests for Find6
func NewFind6Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentRequest generates requests for Current
func NewCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/currentelset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp21Request generates requests for Queryhelp21
func NewQueryhelp21Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/currentelset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream8Request generates requests for FindAllWithStream8
func NewFindAllWithStream8Request(server string, params *FindAllWithStream8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate28Request calls the generic Create28 builder with application/json body
func NewCreate28Request(server string, body Create28JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate28RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate28RequestWithBody generates requests for Create28 with any type of body
func NewCreate28RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST24Request generates requests for CountREST24
func NewCountREST24Request(server string, params *CountREST24Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks8Request calls the generic CreateBulks8 builder with application/json body
func NewCreateBulks8Request(server string, params *CreateBulks8Params, body CreateBulks8JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks8RequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBulks8RequestWithBody generates requests for CreateBulks8 with any type of body
func NewCreateBulks8RequestWithBody(server string, params *CreateBulks8Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DupeCheck != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dupeCheck", runtime.ParamLocationQuery, *params.DupeCheck); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBulkFromTLERequestWithBody generates requests for CreateBulkFromTLE with any type of body
func NewCreateBulkFromTLERequestWithBody(server string, params *CreateBulkFromTLEParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulkFromTLE")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Control != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "control", runtime.ParamLocationQuery, *params.Control); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "makeCurrent", runtime.ParamLocationQuery, params.MakeCurrent); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AutoCreateSats != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoCreateSats", runtime.ParamLocationQuery, *params.AutoCreateSats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrent1Request generates requests for Current1
func NewCurrent1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentTupleRequest generates requests for CurrentTuple
func NewCurrentTupleRequest(server string, params *CurrentTupleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory16Request generates requests for FindAllHistory16
func NewFindAllHistory16Request(server string, params *FindAllHistory16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr16Request generates requests for FindAllHistoryAodr16
func NewFindAllHistoryAodr16Request(server string, params *FindAllHistoryAodr16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory16Request generates requests for CountHistory16
func NewCountHistory16Request(server string, params *CountHistory16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp31Request generates requests for Queryhelp31
func NewQueryhelp31Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples29Request generates requests for FindAllTuples29
func NewFindAllTuples29Request(server string, params *FindAllTuples29Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind25Request generates requests for Find25
func NewFind25Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream9Request generates requests for FindAllWithStream9
func NewFindAllWithStream9Request(server string, params *FindAllWithStream9Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate6Request generates requests for CountDuplicate6
func NewCountDuplicate6Request(server string, params *CountDuplicate6Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory17Request generates requests for FindAllHistory17
func NewFindAllHistory17Request(server string, params *FindAllHistory17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr17Request generates requests for FindAllHistoryAodr17
func NewFindAllHistoryAodr17Request(server string, params *FindAllHistoryAodr17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory17Request generates requests for CountHistory17
func NewCountHistory17Request(server string, params *CountHistory17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp34Request generates requests for Queryhelp34
func NewQueryhelp34Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples32Request generates requests for FindAllTuples32
func NewFindAllTuples32Request(server string, params *FindAllTuples32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream10Request generates requests for FindAllWithStream10
func NewFindAllWithStream10Request(server string, params *FindAllWithStream10Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate32Request calls the generic Create32 builder with application/json body
func NewCreate32Request(server string, body Create32JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate32RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate32RequestWithBody generates requests for Create32 with any type of body
func NewCreate32RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST27Request generates requests for CountREST27
func NewCountREST27Request(server string, params *CountREST27Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFile1Request generates requests for GetFile1
func NewGetFile1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/getFile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory18Request generates requests for FindAllHistory18
func NewFindAllHistory18Request(server string, params *FindAllHistory18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr18Request generates requests for FindAllHistoryAodr18
func NewFindAllHistoryAodr18Request(server string, params *FindAllHistoryAodr18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory18Request generates requests for CountHistory18
func NewCountHistory18Request(server string, params *CountHistory18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp35Request generates requests for Queryhelp35
func NewQueryhelp35Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples33Request generates requests for FindAllTuples33
func NewFindAllTuples33Request(server string, params *FindAllTuples33Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind29Request generates requests for Find29
func NewFind29Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error)

	// FiledropUdlAisPostId request with any body
	FiledropUdlAisPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error)

	FiledropUdlAisPostIdWithResponse(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error)

	// FiledropUdlAttitudesetPostId request with any body
	FiledropUdlAttitudesetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error)

	FiledropUdlAttitudesetPostIdWithResponse(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	// FindAll request
	FindAllWithResponse(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*FindAllResponse, error)

	// Create request with any body
	CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// CountDuplicate request
	CountDuplicateWithResponse(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*CountDuplicateResponse, error)

	// CreateBulks request with any body
	CreateBulksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error)

	CreateBulksWithResponse(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error)

	// FindAllHistory request
	FindAllHistoryWithResponse(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*FindAllHistoryResponse, error)

	// FindAllHistoryAodr request
	FindAllHistoryAodrWithResponse(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*FindAllHistoryAodrResponse, error)

	// CountHistory request
	CountHistoryWithResponse(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*CountHistoryResponse, error)

	// Queryhelp request
	QueryhelpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryhelpResponse, error)

	// FindAllTuples request
	FindAllTuplesWithResponse(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*FindAllTuplesResponse, error)

	// FindAllWithStream1 request
	FindAllWithStream1WithResponse(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*FindAllWithStream1Response, error)

	// CountDuplicate2 request
	CountDuplicate2WithResponse(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*CountDuplicate2Response, error)

	// FindAllHistory4 request
	FindAllHistory4WithResponse(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*FindAllHistory4Response, error)

	// FindAllHistoryAodr4 request
	FindAllHistoryAodr4WithResponse(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr4Response, error)

	// CountHistory4 request
	CountHistory4WithResponse(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*CountHistory4Response, error)

	// Queryhelp7 request
	Queryhelp7WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp7Response, error)

	// FindAllTuples7 request
	FindAllTuples7WithResponse(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*FindAllTuples7Response, error)

	// FindAllWithStream2 request
	FindAllWithStream2WithResponse(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*FindAllWithStream2Response, error)

	// Create7 request with any body
	Create7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create7Response, error)

	Create7WithResponse(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*Create7Response, error)

	// CountREST5 request
	CountREST5WithResponse(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*CountREST5Response, error)

	// FindAllHistory5 request
	FindAllHistory5WithResponse(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*FindAllHistory5Response, error)

	// FindAllHistoryAodr5 request
	FindAllHistoryAodr5WithResponse(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr5Response, error)

	// CountHistory5 request
	CountHistory5WithResponse(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*CountHistory5Response, error)

	// Queryhelp8 request
	Queryhelp8WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp8Response, error)

	// FindAllTuples8 request
	FindAllTuples8WithResponse(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*FindAllTuples8Response, error)

	// Find6 request
	Find6WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find6Response, error)

	// Current request
	CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error)

	// Queryhelp21 request
	Queryhelp21WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp21Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error)

	// Create28 request with any body
	Create28WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create28Response, error)

	Create28WithResponse(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*Create28Response, error)

	// CountREST24 request
	CountREST24WithResponse(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*CountREST24Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error)

	// Current1 request
	Current1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Current1Response, error)

	// CurrentTuple request
	CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error)

	// FindAllHistory16 request
	FindAllHistory16WithResponse(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*FindAllHistory16Response, error)

	// FindAllHistoryAodr16 request
	FindAllHistoryAodr16WithResponse(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr16Response, error)

	// CountHistory16 request
	CountHistory16WithResponse(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*CountHistory16Response, error)

	// Queryhelp31 request
	Queryhelp31WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp31Response, error)

	// FindAllTuples29 request
	FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error)

	// Find25 request
	Find25WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find25Response, error)

	// FindAllWithStream9 request
	FindAllWithStream9WithResponse(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*FindAllWithStream9Response, error)

	// CountDuplicate6 request
	CountDuplicate6WithResponse(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*CountDuplicate6Response, error)

	// FindAllHistory17 request
	FindAllHistory17WithResponse(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*FindAllHistory17Response, error)

	// FindAllHistoryAodr17 request
	FindAllHistoryAodr17WithResponse(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr17Response, error)

	// CountHistory17 request
	CountHistory17WithResponse(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*CountHistory17Response, error)

	// Queryhelp34 request
	Queryhelp34WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp34Response, error)

	// FindAllTuples32 request
	FindAllTuples32WithResponse(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*FindAllTuples32Response, error)

	// FindAllWithStream10 request
	FindAllWithStream10WithResponse(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*FindAllWithStream10Response, error)

	// Create32 request with any body
	Create32WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create32Response, error)

	Create32WithResponse(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*Create32Response, error)

	// CountREST27 request
	CountREST27WithResponse(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*CountREST27Response, error)

	// GetFile1 request
	GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error)

	// FindAllHistory18 request
	FindAllHistory18WithResponse(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*FindAllHistory18Response, error)

	// FindAllHistoryAodr18 request
	FindAllHistoryAodr18WithResponse(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr18Response, error)

	// CountHistory18 request
	CountHistory18WithResponse(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*CountHistory18Response, error)

	// Queryhelp35 request
	Queryhelp35WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp35Response, error)

	// FindAllTuples33 request
	FindAllTuples33WithResponse(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*FindAllTuples33Response, error)

	// Find29 request
	Find29WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find29Response, error)
}

type FiledropEphemPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropEphemPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropEphemPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAisPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAisPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAisPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAttitudesetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAttitudesetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAttitudesetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlElsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlElsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlElsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlEphsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlEphsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlEphsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryhelpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueryhelpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryhelpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp7Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create7Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp8Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r Find6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r CurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp21Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create28Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create28Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create28Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST24Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST24Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST24Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks8Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulkFromTLEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulkFromTLEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulkFromTLEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Current1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r Current1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Current1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentTupleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r CurrentTupleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentTupleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory16Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr16Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory16Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp31Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp31Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp31Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples29Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find25Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElsetFull
}

// Status returns HTTPResponse.Status
func (r Find25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream9Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream9Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream9Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate6Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory17Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr17Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory17Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp34Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp34Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp34Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples32Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream10Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create32Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST27Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST27Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST27Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFile1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFile1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFile1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory18Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp35Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp35Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp35Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples33Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples33Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples33Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find29Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r Find29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// FiledropEphemPostIdWithBodyWithResponse request with arbitrary body returning *FiledropEphemPostIdResponse
func (c *ClientWithResponses) FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error) {
	rsp, err := c.FiledropEphemPostIdWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropEphemPostIdResponse(rsp)
}

// FiledropUdlAisPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAisPostIdResponse
func (c *ClientWithResponses) FiledropUdlAisPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error) {
	rsp, err := c.FiledropUdlAisPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAisPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAisPostIdWithResponse(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error) {
	rsp, err := c.FiledropUdlAisPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAisPostIdResponse(rsp)
}

// FiledropUdlAttitudesetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAttitudesetPostIdResponse
func (c *ClientWithResponses) FiledropUdlAttitudesetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error) {
	rsp, err := c.FiledropUdlAttitudesetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAttitudesetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAttitudesetPostIdWithResponse(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error) {
	rsp, err := c.FiledropUdlAttitudesetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAttitudesetPostIdResponse(rsp)
}

// FiledropUdlElsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlElsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

// FiledropUdlEphsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlEphsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

// FindAllWithResponse request returning *FindAllResponse
func (c *ClientWithResponses) FindAllWithResponse(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*FindAllResponse, error) {
	rsp, err := c.FindAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// CountDuplicateWithResponse request returning *CountDuplicateResponse
func (c *ClientWithResponses) CountDuplicateWithResponse(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*CountDuplicateResponse, error) {
	rsp, err := c.CountDuplicate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicateResponse(rsp)
}

// CreateBulksWithBodyWithResponse request with arbitrary body returning *CreateBulksResponse
func (c *ClientWithResponses) CreateBulksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error) {
	rsp, err := c.CreateBulksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulksResponse(rsp)
}

func (c *ClientWithResponses) CreateBulksWithResponse(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error) {
	rsp, err := c.CreateBulks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulksResponse(rsp)
}

// FindAllHistoryWithResponse request returning *FindAllHistoryResponse
func (c *ClientWithResponses) FindAllHistoryWithResponse(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*FindAllHistoryResponse, error) {
	rsp, err := c.FindAllHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryResponse(rsp)
}

// FindAllHistoryAodrWithResponse request returning *FindAllHistoryAodrResponse
func (c *ClientWithResponses) FindAllHistoryAodrWithResponse(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*FindAllHistoryAodrResponse, error) {
	rsp, err := c.FindAllHistoryAodr(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodrResponse(rsp)
}

// CountHistoryWithResponse request returning *CountHistoryResponse
func (c *ClientWithResponses) CountHistoryWithResponse(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*CountHistoryResponse, error) {
	rsp, err := c.CountHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistoryResponse(rsp)
}

// QueryhelpWithResponse request returning *QueryhelpResponse
func (c *ClientWithResponses) QueryhelpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryhelpResponse, error) {
	rsp, err := c.Queryhelp(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelpResponse(rsp)
}

// FindAllTuplesWithResponse request returning *FindAllTuplesResponse
func (c *ClientWithResponses) FindAllTuplesWithResponse(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*FindAllTuplesResponse, error) {
	rsp, err := c.FindAllTuples(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuplesResponse(rsp)
}

// FindAllWithStream1WithResponse request returning *FindAllWithStream1Response
func (c *ClientWithResponses) FindAllWithStream1WithResponse(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*FindAllWithStream1Response, error) {
	rsp, err := c.FindAllWithStream1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream1Response(rsp)
}

// CountDuplicate2WithResponse request returning *CountDuplicate2Response
func (c *ClientWithResponses) CountDuplicate2WithResponse(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*CountDuplicate2Response, error) {
	rsp, err := c.CountDuplicate2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate2Response(rsp)
}

// FindAllHistory4WithResponse request returning *FindAllHistory4Response
func (c *ClientWithResponses) FindAllHistory4WithResponse(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*FindAllHistory4Response, error) {
	rsp, err := c.FindAllHistory4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory4Response(rsp)
}

// FindAllHistoryAodr4WithResponse request returning *FindAllHistoryAodr4Response
func (c *ClientWithResponses) FindAllHistoryAodr4WithResponse(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr4Response, error) {
	rsp, err := c.FindAllHistoryAodr4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr4Response(rsp)
}

// CountHistory4WithResponse request returning *CountHistory4Response
func (c *ClientWithResponses) CountHistory4WithResponse(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*CountHistory4Response, error) {
	rsp, err := c.CountHistory4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory4Response(rsp)
}

// Queryhelp7WithResponse request returning *Queryhelp7Response
func (c *ClientWithResponses) Queryhelp7WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp7Response, error) {
	rsp, err := c.Queryhelp7(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp7Response(rsp)
}

// FindAllTuples7WithResponse request returning *FindAllTuples7Response
func (c *ClientWithResponses) FindAllTuples7WithResponse(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*FindAllTuples7Response, error) {
	rsp, err := c.FindAllTuples7(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples7Response(rsp)
}

// FindAllWithStream2WithResponse request returning *FindAllWithStream2Response
func (c *ClientWithResponses) FindAllWithStream2WithResponse(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*FindAllWithStream2Response, error) {
	rsp, err := c.FindAllWithStream2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream2Response(rsp)
}

// Create7WithBodyWithResponse request with arbitrary body returning *Create7Response
func (c *ClientWithResponses) Create7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create7Response, error) {
	rsp, err := c.Create7WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate7Response(rsp)
}

func (c *ClientWithResponses) Create7WithResponse(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*Create7Response, error) {
	rsp, err := c.Create7(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate7Response(rsp)
}

// CountREST5WithResponse request returning *CountREST5Response
func (c *ClientWithResponses) CountREST5WithResponse(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*CountREST5Response, error) {
	rsp, err := c.CountREST5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST5Response(rsp)
}

// FindAllHistory5WithResponse request returning *FindAllHistory5Response
func (c *ClientWithResponses) FindAllHistory5WithResponse(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*FindAllHistory5Response, error) {
	rsp, err := c.FindAllHistory5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory5Response(rsp)
}

// FindAllHistoryAodr5WithResponse request returning *FindAllHistoryAodr5Response
func (c *ClientWithResponses) FindAllHistoryAodr5WithResponse(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr5Response, error) {
	rsp, err := c.FindAllHistoryAodr5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr5Response(rsp)
}

// CountHistory5WithResponse request returning *CountHistory5Response
func (c *ClientWithResponses) CountHistory5WithResponse(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*CountHistory5Response, error) {
	rsp, err := c.CountHistory5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory5Response(rsp)
}

// Queryhelp8WithResponse request returning *Queryhelp8Response
func (c *ClientWithResponses) Queryhelp8WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp8Response, error) {
	rsp, err := c.Queryhelp8(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp8Response(rsp)
}

// FindAllTuples8WithResponse request returning *FindAllTuples8Response
func (c *ClientWithResponses) FindAllTuples8WithResponse(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*FindAllTuples8Response, error) {
	rsp, err := c.FindAllTuples8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples8Response(rsp)
}

// Find6WithResponse request returning *Find6Response
func (c *ClientWithResponses) Find6WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find6Response, error) {
	rsp, err := c.Find6(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind6Response(rsp)
}

// CurrentWithResponse request returning *CurrentResponse
func (c *ClientWithResponses) CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error) {
	rsp, err := c.Current(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentResponse(rsp)
}

// Queryhelp21WithResponse request returning *Queryhelp21Response
func (c *ClientWithResponses) Queryhelp21WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp21Response, error) {
	rsp, err := c.Queryhelp21(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp21Response(rsp)
}

// FindAllWithStream8WithResponse request returning *FindAllWithStream8Response
func (c *ClientWithResponses) FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error) {
	rsp, err := c.FindAllWithStream8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream8Response(rsp)
}

// Create28WithBodyWithResponse request with arbitrary body returning *Create28Response
func (c *ClientWithResponses) Create28WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create28Response, error) {
	rsp, err := c.Create28WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate28Response(rsp)
}

func (c *ClientWithResponses) Create28WithResponse(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*Create28Response, error) {
	rsp, err := c.Create28(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate28Response(rsp)
}

// CountREST24WithResponse request returning *CountREST24Response
func (c *ClientWithResponses) CountREST24WithResponse(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*CountREST24Response, error) {
	rsp, err := c.CountREST24(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST24Response(rsp)
}

// CreateBulks8WithBodyWithResponse request with arbitrary body returning *CreateBulks8Response
func (c *ClientWithResponses) CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8WithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

func (c *ClientWithResponses) CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

// CreateBulkFromTLEWithBodyWithResponse request with arbitrary body returning *CreateBulkFromTLEResponse
func (c *ClientWithResponses) CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error) {
	rsp, err := c.CreateBulkFromTLEWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulkFromTLEResponse(rsp)
}

// Current1WithResponse request returning *Current1Response
func (c *ClientWithResponses) Current1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Current1Response, error) {
	rsp, err := c.Current1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrent1Response(rsp)
}

// CurrentTupleWithResponse request returning *CurrentTupleResponse
func (c *ClientWithResponses) CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error) {
	rsp, err := c.CurrentTuple(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentTupleResponse(rsp)
}

// FindAllHistory16WithResponse request returning *FindAllHistory16Response
func (c *ClientWithResponses) FindAllHistory16WithResponse(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*FindAllHistory16Response, error) {
	rsp, err := c.FindAllHistory16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory16Response(rsp)
}

// FindAllHistoryAodr16WithResponse request returning *FindAllHistoryAodr16Response
func (c *ClientWithResponses) FindAllHistoryAodr16WithResponse(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr16Response, error) {
	rsp, err := c.FindAllHistoryAodr16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr16Response(rsp)
}

// CountHistory16WithResponse request returning *CountHistory16Response
func (c *ClientWithResponses) CountHistory16WithResponse(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*CountHistory16Response, error) {
	rsp, err := c.CountHistory16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory16Response(rsp)
}

// Queryhelp31WithResponse request returning *Queryhelp31Response
func (c *ClientWithResponses) Queryhelp31WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp31Response, error) {
	rsp, err := c.Queryhelp31(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp31Response(rsp)
}

// FindAllTuples29WithResponse request returning *FindAllTuples29Response
func (c *ClientWithResponses) FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error) {
	rsp, err := c.FindAllTuples29(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples29Response(rsp)
}

// Find25WithResponse request returning *Find25Response
func (c *ClientWithResponses) Find25WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find25Response, error) {
	rsp, err := c.Find25(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind25Response(rsp)
}

// FindAllWithStream9WithResponse request returning *FindAllWithStream9Response
func (c *ClientWithResponses) FindAllWithStream9WithResponse(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*FindAllWithStream9Response, error) {
	rsp, err := c.FindAllWithStream9(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream9Response(rsp)
}

// CountDuplicate6WithResponse request returning *CountDuplicate6Response
func (c *ClientWithResponses) CountDuplicate6WithResponse(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*CountDuplicate6Response, error) {
	rsp, err := c.CountDuplicate6(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate6Response(rsp)
}

// FindAllHistory17WithResponse request returning *FindAllHistory17Response
func (c *ClientWithResponses) FindAllHistory17WithResponse(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*FindAllHistory17Response, error) {
	rsp, err := c.FindAllHistory17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory17Response(rsp)
}

// FindAllHistoryAodr17WithResponse request returning *FindAllHistoryAodr17Response
func (c *ClientWithResponses) FindAllHistoryAodr17WithResponse(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr17Response, error) {
	rsp, err := c.FindAllHistoryAodr17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr17Response(rsp)
}

// CountHistory17WithResponse request returning *CountHistory17Response
func (c *ClientWithResponses) CountHistory17WithResponse(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*CountHistory17Response, error) {
	rsp, err := c.CountHistory17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory17Response(rsp)
}

// Queryhelp34WithResponse request returning *Queryhelp34Response
func (c *ClientWithResponses) Queryhelp34WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp34Response, error) {
	rsp, err := c.Queryhelp34(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp34Response(rsp)
}

// FindAllTuples32WithResponse request returning *FindAllTuples32Response
func (c *ClientWithResponses) FindAllTuples32WithResponse(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*FindAllTuples32Response, error) {
	rsp, err := c.FindAllTuples32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples32Response(rsp)
}

// FindAllWithStream10WithResponse request returning *FindAllWithStream10Response
func (c *ClientWithResponses) FindAllWithStream10WithResponse(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*FindAllWithStream10Response, error) {
	rsp, err := c.FindAllWithStream10(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream10Response(rsp)
}

// Create32WithBodyWithResponse request with arbitrary body returning *Create32Response
func (c *ClientWithResponses) Create32WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create32Response, error) {
	rsp, err := c.Create32WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate32Response(rsp)
}

func (c *ClientWithResponses) Create32WithResponse(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*Create32Response, error) {
	rsp, err := c.Create32(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate32Response(rsp)
}

// CountREST27WithResponse request returning *CountREST27Response
func (c *ClientWithResponses) CountREST27WithResponse(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*CountREST27Response, error) {
	rsp, err := c.CountREST27(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST27Response(rsp)
}

// GetFile1WithResponse request returning *GetFile1Response
func (c *ClientWithResponses) GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error) {
	rsp, err := c.GetFile1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFile1Response(rsp)
}

// FindAllHistory18WithResponse request returning *FindAllHistory18Response
func (c *ClientWithResponses) FindAllHistory18WithResponse(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*FindAllHistory18Response, error) {
	rsp, err := c.FindAllHistory18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory18Response(rsp)
}

// FindAllHistoryAodr18WithResponse request returning *FindAllHistoryAodr18Response
func (c *ClientWithResponses) FindAllHistoryAodr18WithResponse(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr18Response, error) {
	rsp, err := c.FindAllHistoryAodr18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr18Response(rsp)
}

// CountHistory18WithResponse request returning *CountHistory18Response
func (c *ClientWithResponses) CountHistory18WithResponse(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*CountHistory18Response, error) {
	rsp, err := c.CountHistory18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory18Response(rsp)
}

// Queryhelp35WithResponse request returning *Queryhelp35Response
func (c *ClientWithResponses) Queryhelp35WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp35Response, error) {
	rsp, err := c.Queryhelp35(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp35Response(rsp)
}

// FindAllTuples33WithResponse request returning *FindAllTuples33Response
func (c *ClientWithResponses) FindAllTuples33WithResponse(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*FindAllTuples33Response, error) {
	rsp, err := c.FindAllTuples33(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples33Response(rsp)
}

// Find29WithResponse request returning *Find29Response
func (c *ClientWithResponses) Find29WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find29Response, error) {
	rsp, err := c.Find29(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind29Response(rsp)
}

// ParseFiledropEphemPostIdResponse parses an HTTP response from a FiledropEphemPostIdWithResponse call
func ParseFiledropEphemPostIdResponse(rsp *http.Response) (*FiledropEphemPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropEphemPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAisPostIdResponse parses an HTTP response from a FiledropUdlAisPostIdWithResponse call
func ParseFiledropUdlAisPostIdResponse(rsp *http.Response) (*FiledropUdlAisPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAisPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAttitudesetPostIdResponse parses an HTTP response from a FiledropUdlAttitudesetPostIdWithResponse call
func ParseFiledropUdlAttitudesetPostIdResponse(rsp *http.Response) (*FiledropUdlAttitudesetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAttitudesetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlElsetPostIdResponse parses an HTTP response from a FiledropUdlElsetPostIdWithResponse call
func ParseFiledropUdlElsetPostIdResponse(rsp *http.Response) (*FiledropUdlElsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlElsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlEphsetPostIdResponse parses an HTTP response from a FiledropUdlEphsetPostIdWithResponse call
func ParseFiledropUdlEphsetPostIdResponse(rsp *http.Response) (*FiledropUdlEphsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlEphsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllResponse parses an HTTP response from a FindAllWithResponse call
func ParseFindAllResponse(rsp *http.Response) (*FindAllResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountDuplicateResponse parses an HTTP response from a CountDuplicateWithResponse call
func ParseCountDuplicateResponse(rsp *http.Response) (*CountDuplicateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulksResponse parses an HTTP response from a CreateBulksWithResponse call
func ParseCreateBulksResponse(rsp *http.Response) (*CreateBulksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistoryResponse parses an HTTP response from a FindAllHistoryWithResponse call
func ParseFindAllHistoryResponse(rsp *http.Response) (*FindAllHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodrResponse parses an HTTP response from a FindAllHistoryAodrWithResponse call
func ParseFindAllHistoryAodrResponse(rsp *http.Response) (*FindAllHistoryAodrResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistoryResponse parses an HTTP response from a CountHistoryWithResponse call
func ParseCountHistoryResponse(rsp *http.Response) (*CountHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelpResponse parses an HTTP response from a QueryhelpWithResponse call
func ParseQueryhelpResponse(rsp *http.Response) (*QueryhelpResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryhelpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuplesResponse parses an HTTP response from a FindAllTuplesWithResponse call
func ParseFindAllTuplesResponse(rsp *http.Response) (*FindAllTuplesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream1Response parses an HTTP response from a FindAllWithStream1WithResponse call
func ParseFindAllWithStream1Response(rsp *http.Response) (*FindAllWithStream1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate2Response parses an HTTP response from a CountDuplicate2WithResponse call
func ParseCountDuplicate2Response(rsp *http.Response) (*CountDuplicate2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory4Response parses an HTTP response from a FindAllHistory4WithResponse call
func ParseFindAllHistory4Response(rsp *http.Response) (*FindAllHistory4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr4Response parses an HTTP response from a FindAllHistoryAodr4WithResponse call
func ParseFindAllHistoryAodr4Response(rsp *http.Response) (*FindAllHistoryAodr4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory4Response parses an HTTP response from a CountHistory4WithResponse call
func ParseCountHistory4Response(rsp *http.Response) (*CountHistory4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp7Response parses an HTTP response from a Queryhelp7WithResponse call
func ParseQueryhelp7Response(rsp *http.Response) (*Queryhelp7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples7Response parses an HTTP response from a FindAllTuples7WithResponse call
func ParseFindAllTuples7Response(rsp *http.Response) (*FindAllTuples7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream2Response parses an HTTP response from a FindAllWithStream2WithResponse call
func ParseFindAllWithStream2Response(rsp *http.Response) (*FindAllWithStream2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate7Response parses an HTTP response from a Create7WithResponse call
func ParseCreate7Response(rsp *http.Response) (*Create7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST5Response parses an HTTP response from a CountREST5WithResponse call
func ParseCountREST5Response(rsp *http.Response) (*CountREST5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory5Response parses an HTTP response from a FindAllHistory5WithResponse call
func ParseFindAllHistory5Response(rsp *http.Response) (*FindAllHistory5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr5Response parses an HTTP response from a FindAllHistoryAodr5WithResponse call
func ParseFindAllHistoryAodr5Response(rsp *http.Response) (*FindAllHistoryAodr5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory5Response parses an HTTP response from a CountHistory5WithResponse call
func ParseCountHistory5Response(rsp *http.Response) (*CountHistory5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp8Response parses an HTTP response from a Queryhelp8WithResponse call
func ParseQueryhelp8Response(rsp *http.Response) (*Queryhelp8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples8Response parses an HTTP response from a FindAllTuples8WithResponse call
func ParseFindAllTuples8Response(rsp *http.Response) (*FindAllTuples8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind6Response parses an HTTP response from a Find6WithResponse call
func ParseFind6Response(rsp *http.Response) (*Find6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCurrentResponse parses an HTTP response from a CurrentWithResponse call
func ParseCurrentResponse(rsp *http.Response) (*CurrentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQueryhelp21Response parses an HTTP response from a Queryhelp21WithResponse call
func ParseQueryhelp21Response(rsp *http.Response) (*Queryhelp21Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllWithStream8Response parses an HTTP response from a FindAllWithStream8WithResponse call
func ParseFindAllWithStream8Response(rsp *http.Response) (*FindAllWithStream8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate28Response parses an HTTP response from a Create28WithResponse call
func ParseCreate28Response(rsp *http.Response) (*Create28Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create28Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST24Response parses an HTTP response from a CountREST24WithResponse call
func ParseCountREST24Response(rsp *http.Response) (*CountREST24Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST24Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks8Response parses an HTTP response from a CreateBulks8WithResponse call
func ParseCreateBulks8Response(rsp *http.Response) (*CreateBulks8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulkFromTLEResponse parses an HTTP response from a CreateBulkFromTLEWithResponse call
func ParseCreateBulkFromTLEResponse(rsp *http.Response) (*CreateBulkFromTLEResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulkFromTLEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrent1Response parses an HTTP response from a Current1WithResponse call
func ParseCurrent1Response(rsp *http.Response) (*Current1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Current1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCurrentTupleResponse parses an HTTP response from a CurrentTupleWithResponse call
func ParseCurrentTupleResponse(rsp *http.Response) (*CurrentTupleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentTupleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistory16Response parses an HTTP response from a FindAllHistory16WithResponse call
func ParseFindAllHistory16Response(rsp *http.Response) (*FindAllHistory16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr16Response parses an HTTP response from a FindAllHistoryAodr16WithResponse call
func ParseFindAllHistoryAodr16Response(rsp *http.Response) (*FindAllHistoryAodr16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory16Response parses an HTTP response from a CountHistory16WithResponse call
func ParseCountHistory16Response(rsp *http.Response) (*CountHistory16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp31Response parses an HTTP response from a Queryhelp31WithResponse call
func ParseQueryhelp31Response(rsp *http.Response) (*Queryhelp31Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp31Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples29Response parses an HTTP response from a FindAllTuples29WithResponse call
func ParseFindAllTuples29Response(rsp *http.Response) (*FindAllTuples29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind25Response parses an HTTP response from a Find25WithResponse call
func ParseFind25Response(rsp *http.Response) (*Find25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream9Response parses an HTTP response from a FindAllWithStream9WithResponse call
func ParseFindAllWithStream9Response(rsp *http.Response) (*FindAllWithStream9Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream9Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate6Response parses an HTTP response from a CountDuplicate6WithResponse call
func ParseCountDuplicate6Response(rsp *http.Response) (*CountDuplicate6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory17Response parses an HTTP response from a FindAllHistory17WithResponse call
func ParseFindAllHistory17Response(rsp *http.Response) (*FindAllHistory17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr17Response parses an HTTP response from a FindAllHistoryAodr17WithResponse call
func ParseFindAllHistoryAodr17Response(rsp *http.Response) (*FindAllHistoryAodr17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory17Response parses an HTTP response from a CountHistory17WithResponse call
func ParseCountHistory17Response(rsp *http.Response) (*CountHistory17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp34Response parses an HTTP response from a Queryhelp34WithResponse call
func ParseQueryhelp34Response(rsp *http.Response) (*Queryhelp34Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp34Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples32Response parses an HTTP response from a FindAllTuples32WithResponse call
func ParseFindAllTuples32Response(rsp *http.Response) (*FindAllTuples32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream10Response parses an HTTP response from a FindAllWithStream10WithResponse call
func ParseFindAllWithStream10Response(rsp *http.Response) (*FindAllWithStream10Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate32Response parses an HTTP response from a Create32WithResponse call
func ParseCreate32Response(rsp *http.Response) (*Create32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST27Response parses an HTTP response from a CountREST27WithResponse call
func ParseCountREST27Response(rsp *http.Response) (*CountREST27Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST27Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFile1Response parses an HTTP response from a GetFile1WithResponse call
func ParseGetFile1Response(rsp *http.Response) (*GetFile1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFile1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory18Response parses an HTTP response from a FindAllHistory18WithResponse call
func ParseFindAllHistory18Response(rsp *http.Response) (*FindAllHistory18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr18Response parses an HTTP response from a FindAllHistoryAodr18WithResponse call
func ParseFindAllHistoryAodr18Response(rsp *http.Response) (*FindAllHistoryAodr18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory18Response parses an HTTP response from a CountHistory18WithResponse call
func ParseCountHistory18Response(rsp *http.Response) (*CountHistory18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp35Response parses an HTTP response from a Queryhelp35WithResponse call
func ParseQueryhelp35Response(rsp *http.Response) (*Queryhelp35Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp35Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples33Response parses an HTTP response from a FindAllTuples33WithResponse call
func ParseFindAllTuples33Response(rsp *http.Response) (*FindAllTuples33Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples33Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind29Response parses an HTTP response from a Find29WithResponse call
func ParseFind29Response(rsp *http.Response) (*Find29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
