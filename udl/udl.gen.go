// Package udl provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package udl

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AntennaDetailsFullDataMode.
const (
	AntennaDetailsFullDataModeEXERCISE  AntennaDetailsFullDataMode = "EXERCISE"
	AntennaDetailsFullDataModeREAL      AntennaDetailsFullDataMode = "REAL"
	AntennaDetailsFullDataModeSIMULATED AntennaDetailsFullDataMode = "SIMULATED"
	AntennaDetailsFullDataModeTEST      AntennaDetailsFullDataMode = "TEST"
)

// Defines values for AntennaDetailsFullMode.
const (
	AntennaDetailsFullModeRX AntennaDetailsFullMode = "RX"
	AntennaDetailsFullModeTX AntennaDetailsFullMode = "TX"
)

// Defines values for AntennaFullDataMode.
const (
	AntennaFullDataModeEXERCISE  AntennaFullDataMode = "EXERCISE"
	AntennaFullDataModeREAL      AntennaFullDataMode = "REAL"
	AntennaFullDataModeSIMULATED AntennaFullDataMode = "SIMULATED"
	AntennaFullDataModeTEST      AntennaFullDataMode = "TEST"
)

// Defines values for BatteryDetailsFullDataMode.
const (
	BatteryDetailsFullDataModeEXERCISE  BatteryDetailsFullDataMode = "EXERCISE"
	BatteryDetailsFullDataModeREAL      BatteryDetailsFullDataMode = "REAL"
	BatteryDetailsFullDataModeSIMULATED BatteryDetailsFullDataMode = "SIMULATED"
	BatteryDetailsFullDataModeTEST      BatteryDetailsFullDataMode = "TEST"
)

// Defines values for BatteryFullDataMode.
const (
	BatteryFullDataModeEXERCISE  BatteryFullDataMode = "EXERCISE"
	BatteryFullDataModeREAL      BatteryFullDataMode = "REAL"
	BatteryFullDataModeSIMULATED BatteryFullDataMode = "SIMULATED"
	BatteryFullDataModeTEST      BatteryFullDataMode = "TEST"
)

// Defines values for DataMode.
const (
	DataModeEXERCISE  DataMode = "EXERCISE"
	DataModeREAL      DataMode = "REAL"
	DataModeSIMULATED DataMode = "SIMULATED"
	DataModeTEST      DataMode = "TEST"
)

// Defines values for ElsetAbridgedDataMode.
const (
	ElsetAbridgedDataModeEXERCISE  ElsetAbridgedDataMode = "EXERCISE"
	ElsetAbridgedDataModeREAL      ElsetAbridgedDataMode = "REAL"
	ElsetAbridgedDataModeSIMULATED ElsetAbridgedDataMode = "SIMULATED"
	ElsetAbridgedDataModeTEST      ElsetAbridgedDataMode = "TEST"
)

// Defines values for ElsetFullDataMode.
const (
	ElsetFullDataModeEXERCISE  ElsetFullDataMode = "EXERCISE"
	ElsetFullDataModeREAL      ElsetFullDataMode = "REAL"
	ElsetFullDataModeSIMULATED ElsetFullDataMode = "SIMULATED"
	ElsetFullDataModeTEST      ElsetFullDataMode = "TEST"
)

// Defines values for ElsetFullSourcedDataTypes.
const (
	ElsetFullSourcedDataTypesDOA   ElsetFullSourcedDataTypes = "DOA"
	ElsetFullSourcedDataTypesELSET ElsetFullSourcedDataTypes = "ELSET"
	ElsetFullSourcedDataTypesEO    ElsetFullSourcedDataTypes = "EO"
	ElsetFullSourcedDataTypesRADAR ElsetFullSourcedDataTypes = "RADAR"
	ElsetFullSourcedDataTypesRF    ElsetFullSourcedDataTypes = "RF"
	ElsetFullSourcedDataTypesSV    ElsetFullSourcedDataTypes = "SV"
)

// Defines values for ElsetIngestDataMode.
const (
	ElsetIngestDataModeEXERCISE  ElsetIngestDataMode = "EXERCISE"
	ElsetIngestDataModeREAL      ElsetIngestDataMode = "REAL"
	ElsetIngestDataModeSIMULATED ElsetIngestDataMode = "SIMULATED"
	ElsetIngestDataModeTEST      ElsetIngestDataMode = "TEST"
)

// Defines values for ElsetIngestSourcedDataTypes.
const (
	ElsetIngestSourcedDataTypesDOA   ElsetIngestSourcedDataTypes = "DOA"
	ElsetIngestSourcedDataTypesELSET ElsetIngestSourcedDataTypes = "ELSET"
	ElsetIngestSourcedDataTypesEO    ElsetIngestSourcedDataTypes = "EO"
	ElsetIngestSourcedDataTypesRADAR ElsetIngestSourcedDataTypes = "RADAR"
	ElsetIngestSourcedDataTypesRF    ElsetIngestSourcedDataTypes = "RF"
	ElsetIngestSourcedDataTypesSV    ElsetIngestSourcedDataTypes = "SV"
)

// Defines values for EngineDetailsFullDataMode.
const (
	EngineDetailsFullDataModeEXERCISE  EngineDetailsFullDataMode = "EXERCISE"
	EngineDetailsFullDataModeREAL      EngineDetailsFullDataMode = "REAL"
	EngineDetailsFullDataModeSIMULATED EngineDetailsFullDataMode = "SIMULATED"
	EngineDetailsFullDataModeTEST      EngineDetailsFullDataMode = "TEST"
)

// Defines values for EngineFullDataMode.
const (
	EngineFullDataModeEXERCISE  EngineFullDataMode = "EXERCISE"
	EngineFullDataModeREAL      EngineFullDataMode = "REAL"
	EngineFullDataModeSIMULATED EngineFullDataMode = "SIMULATED"
	EngineFullDataModeTEST      EngineFullDataMode = "TEST"
)

// Defines values for EntityAbridgedDataMode.
const (
	EntityAbridgedDataModeEXERCISE  EntityAbridgedDataMode = "EXERCISE"
	EntityAbridgedDataModeREAL      EntityAbridgedDataMode = "REAL"
	EntityAbridgedDataModeSIMULATED EntityAbridgedDataMode = "SIMULATED"
	EntityAbridgedDataModeTEST      EntityAbridgedDataMode = "TEST"
)

// Defines values for EntityAbridgedOwnerType.
const (
	EntityAbridgedOwnerTypeAcademic   EntityAbridgedOwnerType = "Academic"
	EntityAbridgedOwnerTypeCommercial EntityAbridgedOwnerType = "Commercial"
	EntityAbridgedOwnerTypeConsortium EntityAbridgedOwnerType = "Consortium"
	EntityAbridgedOwnerTypeGovernment EntityAbridgedOwnerType = "Government"
	EntityAbridgedOwnerTypeOther      EntityAbridgedOwnerType = "Other"
)

// Defines values for EntityAbridgedType.
const (
	EntityAbridgedTypeAIRCRAFT   EntityAbridgedType = "AIRCRAFT"
	EntityAbridgedTypeBUS        EntityAbridgedType = "BUS"
	EntityAbridgedTypeCOMM       EntityAbridgedType = "COMM"
	EntityAbridgedTypeIR         EntityAbridgedType = "IR"
	EntityAbridgedTypeNAVIGATION EntityAbridgedType = "NAVIGATION"
	EntityAbridgedTypeONORBIT    EntityAbridgedType = "ONORBIT"
	EntityAbridgedTypeRFEMITTER  EntityAbridgedType = "RFEMITTER"
	EntityAbridgedTypeSCIENTIFIC EntityAbridgedType = "SCIENTIFIC"
	EntityAbridgedTypeSENSOR     EntityAbridgedType = "SENSOR"
	EntityAbridgedTypeSITE       EntityAbridgedType = "SITE"
)

// Defines values for EntityFullDataMode.
const (
	EntityFullDataModeEXERCISE  EntityFullDataMode = "EXERCISE"
	EntityFullDataModeREAL      EntityFullDataMode = "REAL"
	EntityFullDataModeSIMULATED EntityFullDataMode = "SIMULATED"
	EntityFullDataModeTEST      EntityFullDataMode = "TEST"
)

// Defines values for EntityFullOwnerType.
const (
	EntityFullOwnerTypeAcademic   EntityFullOwnerType = "Academic"
	EntityFullOwnerTypeCommercial EntityFullOwnerType = "Commercial"
	EntityFullOwnerTypeConsortium EntityFullOwnerType = "Consortium"
	EntityFullOwnerTypeGovernment EntityFullOwnerType = "Government"
	EntityFullOwnerTypeOther      EntityFullOwnerType = "Other"
)

// Defines values for EntityFullType.
const (
	EntityFullTypeAIRCRAFT   EntityFullType = "AIRCRAFT"
	EntityFullTypeBUS        EntityFullType = "BUS"
	EntityFullTypeCOMM       EntityFullType = "COMM"
	EntityFullTypeIR         EntityFullType = "IR"
	EntityFullTypeNAVIGATION EntityFullType = "NAVIGATION"
	EntityFullTypeONORBIT    EntityFullType = "ONORBIT"
	EntityFullTypeRFEMITTER  EntityFullType = "RFEMITTER"
	EntityFullTypeSCIENTIFIC EntityFullType = "SCIENTIFIC"
	EntityFullTypeSENSOR     EntityFullType = "SENSOR"
	EntityFullTypeSITE       EntityFullType = "SITE"
)

// Defines values for EphemFormatType.
const (
	GOO    EphemFormatType = "GOO"
	ModITC EphemFormatType = "ModITC"
	NASA   EphemFormatType = "NASA"
	OASYS  EphemFormatType = "OASYS"
	OEM    EphemFormatType = "OEM"
)

// Defines values for EphemerisSetAbridgedCovReferenceFrame.
const (
	EphemerisSetAbridgedCovReferenceFrameJ2000 EphemerisSetAbridgedCovReferenceFrame = "J2000"
	EphemerisSetAbridgedCovReferenceFrameUVW   EphemerisSetAbridgedCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetAbridgedDataMode.
const (
	EphemerisSetAbridgedDataModeEXERCISE  EphemerisSetAbridgedDataMode = "EXERCISE"
	EphemerisSetAbridgedDataModeREAL      EphemerisSetAbridgedDataMode = "REAL"
	EphemerisSetAbridgedDataModeSIMULATED EphemerisSetAbridgedDataMode = "SIMULATED"
	EphemerisSetAbridgedDataModeTEST      EphemerisSetAbridgedDataMode = "TEST"
)

// Defines values for EphemerisSetAbridgedReferenceFrame.
const (
	EphemerisSetAbridgedReferenceFrameECRECEF EphemerisSetAbridgedReferenceFrame = "ECR/ECEF"
	EphemerisSetAbridgedReferenceFrameEFGTDR  EphemerisSetAbridgedReferenceFrame = "EFG/TDR"
	EphemerisSetAbridgedReferenceFrameGCRF    EphemerisSetAbridgedReferenceFrame = "GCRF"
	EphemerisSetAbridgedReferenceFrameITRF    EphemerisSetAbridgedReferenceFrame = "ITRF"
	EphemerisSetAbridgedReferenceFrameJ2000   EphemerisSetAbridgedReferenceFrame = "J2000"
	EphemerisSetAbridgedReferenceFrameTEME    EphemerisSetAbridgedReferenceFrame = "TEME"
)

// Defines values for EphemerisSetFullCovReferenceFrame.
const (
	EphemerisSetFullCovReferenceFrameJ2000 EphemerisSetFullCovReferenceFrame = "J2000"
	EphemerisSetFullCovReferenceFrameUVW   EphemerisSetFullCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetFullDataMode.
const (
	EphemerisSetFullDataModeEXERCISE  EphemerisSetFullDataMode = "EXERCISE"
	EphemerisSetFullDataModeREAL      EphemerisSetFullDataMode = "REAL"
	EphemerisSetFullDataModeSIMULATED EphemerisSetFullDataMode = "SIMULATED"
	EphemerisSetFullDataModeTEST      EphemerisSetFullDataMode = "TEST"
)

// Defines values for EphemerisSetFullReferenceFrame.
const (
	EphemerisSetFullReferenceFrameECRECEF EphemerisSetFullReferenceFrame = "ECR/ECEF"
	EphemerisSetFullReferenceFrameEFGTDR  EphemerisSetFullReferenceFrame = "EFG/TDR"
	EphemerisSetFullReferenceFrameGCRF    EphemerisSetFullReferenceFrame = "GCRF"
	EphemerisSetFullReferenceFrameITRF    EphemerisSetFullReferenceFrame = "ITRF"
	EphemerisSetFullReferenceFrameJ2000   EphemerisSetFullReferenceFrame = "J2000"
	EphemerisSetFullReferenceFrameTEME    EphemerisSetFullReferenceFrame = "TEME"
)

// Defines values for EphemerisSetIngestCovReferenceFrame.
const (
	EphemerisSetIngestCovReferenceFrameJ2000 EphemerisSetIngestCovReferenceFrame = "J2000"
	EphemerisSetIngestCovReferenceFrameUVW   EphemerisSetIngestCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetIngestDataMode.
const (
	EphemerisSetIngestDataModeEXERCISE  EphemerisSetIngestDataMode = "EXERCISE"
	EphemerisSetIngestDataModeREAL      EphemerisSetIngestDataMode = "REAL"
	EphemerisSetIngestDataModeSIMULATED EphemerisSetIngestDataMode = "SIMULATED"
	EphemerisSetIngestDataModeTEST      EphemerisSetIngestDataMode = "TEST"
)

// Defines values for EphemerisSetIngestReferenceFrame.
const (
	EphemerisSetIngestReferenceFrameECRECEF EphemerisSetIngestReferenceFrame = "ECR/ECEF"
	EphemerisSetIngestReferenceFrameEFGTDR  EphemerisSetIngestReferenceFrame = "EFG/TDR"
	EphemerisSetIngestReferenceFrameGCRF    EphemerisSetIngestReferenceFrame = "GCRF"
	EphemerisSetIngestReferenceFrameITRF    EphemerisSetIngestReferenceFrame = "ITRF"
	EphemerisSetIngestReferenceFrameJ2000   EphemerisSetIngestReferenceFrame = "J2000"
	EphemerisSetIngestReferenceFrameTEME    EphemerisSetIngestReferenceFrame = "TEME"
)

// Defines values for EphemerisAbridgedDataMode.
const (
	EphemerisAbridgedDataModeEXERCISE  EphemerisAbridgedDataMode = "EXERCISE"
	EphemerisAbridgedDataModeREAL      EphemerisAbridgedDataMode = "REAL"
	EphemerisAbridgedDataModeSIMULATED EphemerisAbridgedDataMode = "SIMULATED"
	EphemerisAbridgedDataModeTEST      EphemerisAbridgedDataMode = "TEST"
)

// Defines values for EphemerisFullDataMode.
const (
	EphemerisFullDataModeEXERCISE  EphemerisFullDataMode = "EXERCISE"
	EphemerisFullDataModeREAL      EphemerisFullDataMode = "REAL"
	EphemerisFullDataModeSIMULATED EphemerisFullDataMode = "SIMULATED"
	EphemerisFullDataModeTEST      EphemerisFullDataMode = "TEST"
)

// Defines values for EphemerisIngestDataMode.
const (
	EphemerisIngestDataModeEXERCISE  EphemerisIngestDataMode = "EXERCISE"
	EphemerisIngestDataModeREAL      EphemerisIngestDataMode = "REAL"
	EphemerisIngestDataModeSIMULATED EphemerisIngestDataMode = "SIMULATED"
	EphemerisIngestDataModeTEST      EphemerisIngestDataMode = "TEST"
)

// Defines values for LocationAbridgedDataMode.
const (
	LocationAbridgedDataModeEXERCISE  LocationAbridgedDataMode = "EXERCISE"
	LocationAbridgedDataModeREAL      LocationAbridgedDataMode = "REAL"
	LocationAbridgedDataModeSIMULATED LocationAbridgedDataMode = "SIMULATED"
	LocationAbridgedDataModeTEST      LocationAbridgedDataMode = "TEST"
)

// Defines values for LocationFullDataMode.
const (
	LocationFullDataModeEXERCISE  LocationFullDataMode = "EXERCISE"
	LocationFullDataModeREAL      LocationFullDataMode = "REAL"
	LocationFullDataModeSIMULATED LocationFullDataMode = "SIMULATED"
	LocationFullDataModeTEST      LocationFullDataMode = "TEST"
)

// Defines values for OnorbitAntennaFullDataMode.
const (
	OnorbitAntennaFullDataModeEXERCISE  OnorbitAntennaFullDataMode = "EXERCISE"
	OnorbitAntennaFullDataModeREAL      OnorbitAntennaFullDataMode = "REAL"
	OnorbitAntennaFullDataModeSIMULATED OnorbitAntennaFullDataMode = "SIMULATED"
	OnorbitAntennaFullDataModeTEST      OnorbitAntennaFullDataMode = "TEST"
)

// Defines values for OnorbitBatteryFullDataMode.
const (
	OnorbitBatteryFullDataModeEXERCISE  OnorbitBatteryFullDataMode = "EXERCISE"
	OnorbitBatteryFullDataModeREAL      OnorbitBatteryFullDataMode = "REAL"
	OnorbitBatteryFullDataModeSIMULATED OnorbitBatteryFullDataMode = "SIMULATED"
	OnorbitBatteryFullDataModeTEST      OnorbitBatteryFullDataMode = "TEST"
)

// Defines values for OnorbitDetailsFullDataMode.
const (
	OnorbitDetailsFullDataModeEXERCISE  OnorbitDetailsFullDataMode = "EXERCISE"
	OnorbitDetailsFullDataModeREAL      OnorbitDetailsFullDataMode = "REAL"
	OnorbitDetailsFullDataModeSIMULATED OnorbitDetailsFullDataMode = "SIMULATED"
	OnorbitDetailsFullDataModeTEST      OnorbitDetailsFullDataMode = "TEST"
)

// Defines values for OnorbitSolarArrayFullDataMode.
const (
	OnorbitSolarArrayFullDataModeEXERCISE  OnorbitSolarArrayFullDataMode = "EXERCISE"
	OnorbitSolarArrayFullDataModeREAL      OnorbitSolarArrayFullDataMode = "REAL"
	OnorbitSolarArrayFullDataModeSIMULATED OnorbitSolarArrayFullDataMode = "SIMULATED"
	OnorbitSolarArrayFullDataModeTEST      OnorbitSolarArrayFullDataMode = "TEST"
)

// Defines values for OnorbitThrusterFullDataMode.
const (
	OnorbitThrusterFullDataModeEXERCISE  OnorbitThrusterFullDataMode = "EXERCISE"
	OnorbitThrusterFullDataModeREAL      OnorbitThrusterFullDataMode = "REAL"
	OnorbitThrusterFullDataModeSIMULATED OnorbitThrusterFullDataMode = "SIMULATED"
	OnorbitThrusterFullDataModeTEST      OnorbitThrusterFullDataMode = "TEST"
)

// Defines values for OnorbitAbridgedCategory.
const (
	OnorbitAbridgedCategoryAnalystSatellite      OnorbitAbridgedCategory = "Analyst Satellite"
	OnorbitAbridgedCategoryCatalogedWithoutState OnorbitAbridgedCategory = "Cataloged Without State"
	OnorbitAbridgedCategoryCislunar              OnorbitAbridgedCategory = "Cislunar"
	OnorbitAbridgedCategoryDecayed               OnorbitAbridgedCategory = "Decayed"
	OnorbitAbridgedCategoryDocked                OnorbitAbridgedCategory = "Docked"
	OnorbitAbridgedCategoryHeliocentric          OnorbitAbridgedCategory = "Heliocentric"
	OnorbitAbridgedCategoryHyperbolic            OnorbitAbridgedCategory = "Hyperbolic"
	OnorbitAbridgedCategoryInterplanetary        OnorbitAbridgedCategory = "Interplanetary"
	OnorbitAbridgedCategoryLagrangian            OnorbitAbridgedCategory = "Lagrangian"
	OnorbitAbridgedCategoryLaunchNominal         OnorbitAbridgedCategory = "Launch Nominal"
	OnorbitAbridgedCategoryLunar                 OnorbitAbridgedCategory = "Lunar"
	OnorbitAbridgedCategoryOnOrbit               OnorbitAbridgedCategory = "On-Orbit"
	OnorbitAbridgedCategoryUnknown               OnorbitAbridgedCategory = "Unknown"
)

// Defines values for OnorbitAbridgedDataMode.
const (
	OnorbitAbridgedDataModeEXERCISE  OnorbitAbridgedDataMode = "EXERCISE"
	OnorbitAbridgedDataModeREAL      OnorbitAbridgedDataMode = "REAL"
	OnorbitAbridgedDataModeSIMULATED OnorbitAbridgedDataMode = "SIMULATED"
	OnorbitAbridgedDataModeTEST      OnorbitAbridgedDataMode = "TEST"
)

// Defines values for OnorbitAbridgedObjectType.
const (
	OnorbitAbridgedObjectTypeDEBRIS     OnorbitAbridgedObjectType = "DEBRIS"
	OnorbitAbridgedObjectTypeMANNED     OnorbitAbridgedObjectType = "MANNED"
	OnorbitAbridgedObjectTypePAYLOAD    OnorbitAbridgedObjectType = "PAYLOAD"
	OnorbitAbridgedObjectTypePLATFORM   OnorbitAbridgedObjectType = "PLATFORM"
	OnorbitAbridgedObjectTypeROCKETBODY OnorbitAbridgedObjectType = "ROCKET BODY"
	OnorbitAbridgedObjectTypeUNKNOWN    OnorbitAbridgedObjectType = "UNKNOWN"
)

// Defines values for OnorbitFullCategory.
const (
	OnorbitFullCategoryAnalystSatellite      OnorbitFullCategory = "Analyst Satellite"
	OnorbitFullCategoryCatalogedWithoutState OnorbitFullCategory = "Cataloged Without State"
	OnorbitFullCategoryCislunar              OnorbitFullCategory = "Cislunar"
	OnorbitFullCategoryDecayed               OnorbitFullCategory = "Decayed"
	OnorbitFullCategoryDocked                OnorbitFullCategory = "Docked"
	OnorbitFullCategoryHeliocentric          OnorbitFullCategory = "Heliocentric"
	OnorbitFullCategoryHyperbolic            OnorbitFullCategory = "Hyperbolic"
	OnorbitFullCategoryInterplanetary        OnorbitFullCategory = "Interplanetary"
	OnorbitFullCategoryLagrangian            OnorbitFullCategory = "Lagrangian"
	OnorbitFullCategoryLaunchNominal         OnorbitFullCategory = "Launch Nominal"
	OnorbitFullCategoryLunar                 OnorbitFullCategory = "Lunar"
	OnorbitFullCategoryOnOrbit               OnorbitFullCategory = "On-Orbit"
	OnorbitFullCategoryUnknown               OnorbitFullCategory = "Unknown"
)

// Defines values for OnorbitFullDataMode.
const (
	OnorbitFullDataModeEXERCISE  OnorbitFullDataMode = "EXERCISE"
	OnorbitFullDataModeREAL      OnorbitFullDataMode = "REAL"
	OnorbitFullDataModeSIMULATED OnorbitFullDataMode = "SIMULATED"
	OnorbitFullDataModeTEST      OnorbitFullDataMode = "TEST"
)

// Defines values for OnorbitFullObjectType.
const (
	OnorbitFullObjectTypeDEBRIS     OnorbitFullObjectType = "DEBRIS"
	OnorbitFullObjectTypeMANNED     OnorbitFullObjectType = "MANNED"
	OnorbitFullObjectTypePAYLOAD    OnorbitFullObjectType = "PAYLOAD"
	OnorbitFullObjectTypePLATFORM   OnorbitFullObjectType = "PLATFORM"
	OnorbitFullObjectTypeROCKETBODY OnorbitFullObjectType = "ROCKET BODY"
	OnorbitFullObjectTypeUNKNOWN    OnorbitFullObjectType = "UNKNOWN"
)

// Defines values for OperatingunitFullDataMode.
const (
	OperatingunitFullDataModeEXERCISE  OperatingunitFullDataMode = "EXERCISE"
	OperatingunitFullDataModeREAL      OperatingunitFullDataMode = "REAL"
	OperatingunitFullDataModeSIMULATED OperatingunitFullDataMode = "SIMULATED"
	OperatingunitFullDataModeTEST      OperatingunitFullDataMode = "TEST"
)

// Defines values for OrganizationDetailsFullDataMode.
const (
	OrganizationDetailsFullDataModeEXERCISE  OrganizationDetailsFullDataMode = "EXERCISE"
	OrganizationDetailsFullDataModeREAL      OrganizationDetailsFullDataMode = "REAL"
	OrganizationDetailsFullDataModeSIMULATED OrganizationDetailsFullDataMode = "SIMULATED"
	OrganizationDetailsFullDataModeTEST      OrganizationDetailsFullDataMode = "TEST"
)

// Defines values for OrganizationFullDataMode.
const (
	OrganizationFullDataModeEXERCISE  OrganizationFullDataMode = "EXERCISE"
	OrganizationFullDataModeREAL      OrganizationFullDataMode = "REAL"
	OrganizationFullDataModeSIMULATED OrganizationFullDataMode = "SIMULATED"
	OrganizationFullDataModeTEST      OrganizationFullDataMode = "TEST"
)

// Defines values for RFBandFullDataMode.
const (
	RFBandFullDataModeEXERCISE  RFBandFullDataMode = "EXERCISE"
	RFBandFullDataModeREAL      RFBandFullDataMode = "REAL"
	RFBandFullDataModeSIMULATED RFBandFullDataMode = "SIMULATED"
	RFBandFullDataModeTEST      RFBandFullDataMode = "TEST"
)

// Defines values for RFBandFullMode.
const (
	RFBandFullModeRX RFBandFullMode = "RX"
	RFBandFullModeTX RFBandFullMode = "TX"
)

// Defines values for RFBandFullPolarization.
const (
	H RFBandFullPolarization = "H"
	L RFBandFullPolarization = "L"
	R RFBandFullPolarization = "R"
	V RFBandFullPolarization = "V"
)

// Defines values for RFBandFullPurpose.
const (
	COMM  RFBandFullPurpose = "COMM"
	OPS   RFBandFullPurpose = "OPS"
	OTHER RFBandFullPurpose = "OTHER"
	TTC   RFBandFullPurpose = "TTC"
)

// Defines values for SensorStatsAbridgedDataMode.
const (
	SensorStatsAbridgedDataModeEXERCISE  SensorStatsAbridgedDataMode = "EXERCISE"
	SensorStatsAbridgedDataModeREAL      SensorStatsAbridgedDataMode = "REAL"
	SensorStatsAbridgedDataModeSIMULATED SensorStatsAbridgedDataMode = "SIMULATED"
	SensorStatsAbridgedDataModeTEST      SensorStatsAbridgedDataMode = "TEST"
)

// Defines values for SensorStatsFullDataMode.
const (
	SensorStatsFullDataModeEXERCISE  SensorStatsFullDataMode = "EXERCISE"
	SensorStatsFullDataModeREAL      SensorStatsFullDataMode = "REAL"
	SensorStatsFullDataModeSIMULATED SensorStatsFullDataMode = "SIMULATED"
	SensorStatsFullDataModeTEST      SensorStatsFullDataMode = "TEST"
)

// Defines values for SensorAbridgedDataMode.
const (
	SensorAbridgedDataModeEXERCISE  SensorAbridgedDataMode = "EXERCISE"
	SensorAbridgedDataModeREAL      SensorAbridgedDataMode = "REAL"
	SensorAbridgedDataModeSIMULATED SensorAbridgedDataMode = "SIMULATED"
	SensorAbridgedDataModeTEST      SensorAbridgedDataMode = "TEST"
)

// Defines values for SensorFullDataMode.
const (
	SensorFullDataModeEXERCISE  SensorFullDataMode = "EXERCISE"
	SensorFullDataModeREAL      SensorFullDataMode = "REAL"
	SensorFullDataModeSIMULATED SensorFullDataMode = "SIMULATED"
	SensorFullDataModeTEST      SensorFullDataMode = "TEST"
)

// Defines values for SensorcharacteristicsAbridgedDataMode.
const (
	SensorcharacteristicsAbridgedDataModeEXERCISE  SensorcharacteristicsAbridgedDataMode = "EXERCISE"
	SensorcharacteristicsAbridgedDataModeREAL      SensorcharacteristicsAbridgedDataMode = "REAL"
	SensorcharacteristicsAbridgedDataModeSIMULATED SensorcharacteristicsAbridgedDataMode = "SIMULATED"
	SensorcharacteristicsAbridgedDataModeTEST      SensorcharacteristicsAbridgedDataMode = "TEST"
)

// Defines values for SensorcharacteristicsFullDataMode.
const (
	SensorcharacteristicsFullDataModeEXERCISE  SensorcharacteristicsFullDataMode = "EXERCISE"
	SensorcharacteristicsFullDataModeREAL      SensorcharacteristicsFullDataMode = "REAL"
	SensorcharacteristicsFullDataModeSIMULATED SensorcharacteristicsFullDataMode = "SIMULATED"
	SensorcharacteristicsFullDataModeTEST      SensorcharacteristicsFullDataMode = "TEST"
)

// Defines values for SensorlimitsAbridgedDataMode.
const (
	SensorlimitsAbridgedDataModeEXERCISE  SensorlimitsAbridgedDataMode = "EXERCISE"
	SensorlimitsAbridgedDataModeREAL      SensorlimitsAbridgedDataMode = "REAL"
	SensorlimitsAbridgedDataModeSIMULATED SensorlimitsAbridgedDataMode = "SIMULATED"
	SensorlimitsAbridgedDataModeTEST      SensorlimitsAbridgedDataMode = "TEST"
)

// Defines values for SensorlimitsFullDataMode.
const (
	SensorlimitsFullDataModeEXERCISE  SensorlimitsFullDataMode = "EXERCISE"
	SensorlimitsFullDataModeREAL      SensorlimitsFullDataMode = "REAL"
	SensorlimitsFullDataModeSIMULATED SensorlimitsFullDataMode = "SIMULATED"
	SensorlimitsFullDataModeTEST      SensorlimitsFullDataMode = "TEST"
)

// Defines values for SensorobservationtypeFullDataMode.
const (
	SensorobservationtypeFullDataModeEXERCISE  SensorobservationtypeFullDataMode = "EXERCISE"
	SensorobservationtypeFullDataModeREAL      SensorobservationtypeFullDataMode = "REAL"
	SensorobservationtypeFullDataModeSIMULATED SensorobservationtypeFullDataMode = "SIMULATED"
	SensorobservationtypeFullDataModeTEST      SensorobservationtypeFullDataMode = "TEST"
)

// Defines values for SensortypeFullDataMode.
const (
	SensortypeFullDataModeEXERCISE  SensortypeFullDataMode = "EXERCISE"
	SensortypeFullDataModeREAL      SensortypeFullDataMode = "REAL"
	SensortypeFullDataModeSIMULATED SensortypeFullDataMode = "SIMULATED"
	SensortypeFullDataModeTEST      SensortypeFullDataMode = "TEST"
)

// Defines values for SolarArrayDetailsFullDataMode.
const (
	SolarArrayDetailsFullDataModeEXERCISE  SolarArrayDetailsFullDataMode = "EXERCISE"
	SolarArrayDetailsFullDataModeREAL      SolarArrayDetailsFullDataMode = "REAL"
	SolarArrayDetailsFullDataModeSIMULATED SolarArrayDetailsFullDataMode = "SIMULATED"
	SolarArrayDetailsFullDataModeTEST      SolarArrayDetailsFullDataMode = "TEST"
)

// Defines values for SolarArrayFullDataMode.
const (
	SolarArrayFullDataModeEXERCISE  SolarArrayFullDataMode = "EXERCISE"
	SolarArrayFullDataModeREAL      SolarArrayFullDataMode = "REAL"
	SolarArrayFullDataModeSIMULATED SolarArrayFullDataMode = "SIMULATED"
	SolarArrayFullDataModeTEST      SolarArrayFullDataMode = "TEST"
)

// Defines values for StateVectorFullCovReferenceFrame.
const (
	StateVectorFullCovReferenceFrameJ2000 StateVectorFullCovReferenceFrame = "J2000"
	StateVectorFullCovReferenceFrameUVW   StateVectorFullCovReferenceFrame = "UVW"
)

// Defines values for StateVectorFullDataMode.
const (
	StateVectorFullDataModeEXERCISE  StateVectorFullDataMode = "EXERCISE"
	StateVectorFullDataModeREAL      StateVectorFullDataMode = "REAL"
	StateVectorFullDataModeSIMULATED StateVectorFullDataMode = "SIMULATED"
	StateVectorFullDataModeTEST      StateVectorFullDataMode = "TEST"
)

// Defines values for StateVectorFullReferenceFrame.
const (
	StateVectorFullReferenceFrameECRECEF StateVectorFullReferenceFrame = "ECR/ECEF"
	StateVectorFullReferenceFrameEFGTDR  StateVectorFullReferenceFrame = "EFG/TDR"
	StateVectorFullReferenceFrameGCRF    StateVectorFullReferenceFrame = "GCRF"
	StateVectorFullReferenceFrameITRF    StateVectorFullReferenceFrame = "ITRF"
	StateVectorFullReferenceFrameJ2000   StateVectorFullReferenceFrame = "J2000"
	StateVectorFullReferenceFrameTEME    StateVectorFullReferenceFrame = "TEME"
)

// Defines values for StateVectorFullSourcedDataTypes.
const (
	DOA   StateVectorFullSourcedDataTypes = "DOA"
	ELSET StateVectorFullSourcedDataTypes = "ELSET"
	EO    StateVectorFullSourcedDataTypes = "EO"
	RADAR StateVectorFullSourcedDataTypes = "RADAR"
	RF    StateVectorFullSourcedDataTypes = "RF"
	SV    StateVectorFullSourcedDataTypes = "SV"
)

// Defines values for StatusFullDataMode.
const (
	StatusFullDataModeEXERCISE  StatusFullDataMode = "EXERCISE"
	StatusFullDataModeREAL      StatusFullDataMode = "REAL"
	StatusFullDataModeSIMULATED StatusFullDataMode = "SIMULATED"
	StatusFullDataModeTEST      StatusFullDataMode = "TEST"
)

// Defines values for StatusFullOpsCap.
const (
	StatusFullOpsCapFMC StatusFullOpsCap = "FMC"
	StatusFullOpsCapNMC StatusFullOpsCap = "NMC"
	StatusFullOpsCapPMC StatusFullOpsCap = "PMC"
	StatusFullOpsCapUNK StatusFullOpsCap = "UNK"
)

// Defines values for StatusFullState.
const (
	ACTIVE   StatusFullState = "ACTIVE"
	DEAD     StatusFullState = "DEAD"
	RFACTIVE StatusFullState = "RF ACTIVE"
	STANDBY  StatusFullState = "STANDBY"
	UNKNOWN  StatusFullState = "UNKNOWN"
)

// Defines values for StatusFullSysCap.
const (
	StatusFullSysCapFMC StatusFullSysCap = "FMC"
	StatusFullSysCapNMC StatusFullSysCap = "NMC"
	StatusFullSysCapPMC StatusFullSysCap = "PMC"
	StatusFullSysCapUNK StatusFullSysCap = "UNK"
)

// Defines values for SubStatusFullDataMode.
const (
	SubStatusFullDataModeEXERCISE  SubStatusFullDataMode = "EXERCISE"
	SubStatusFullDataModeREAL      SubStatusFullDataMode = "REAL"
	SubStatusFullDataModeSIMULATED SubStatusFullDataMode = "SIMULATED"
	SubStatusFullDataModeTEST      SubStatusFullDataMode = "TEST"
)

// Defines values for SubStatusFullStatus.
const (
	FMC SubStatusFullStatus = "FMC"
	NMC SubStatusFullStatus = "NMC"
	PMC SubStatusFullStatus = "PMC"
	UNK SubStatusFullStatus = "UNK"
)

// Defines values for SubStatusFullType.
const (
	MdCap SubStatusFullType = "mdCap"
	MwCap SubStatusFullType = "mwCap"
	SsCap SubStatusFullType = "ssCap"
)

// Model representation of Information on spacecraft communication antennas. An antenna may have multiple details records compiled by various sources.
type AntennaDetailsFull struct {
	// Boolean indicating if this is a beam forming antenna
	BeamForming *bool `json:"beamForming,omitempty"`

	// Array of angles between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaDetailsFullDataMode `json:"dataMode"`

	// Antenna description
	Description *string `json:"description,omitempty"`

	// Antenna diameter in meters
	Diameter *float64 `json:"diameter,omitempty"`

	// Antenna end of frequency range in Mhz
	EndFrequency *float64 `json:"endFrequency,omitempty"`

	// Antenna maximum gain in dBi
	Gain *float64 `json:"gain,omitempty"`

	// Antenna gain tolerance in dB
	GainTolerance *float64 `json:"gainTolerance,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Antenna
	IdAntenna string `json:"idAntenna"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the antenna
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Antenna mode (e.g. TX,RX)
	Mode *AntennaDetailsFullMode `json:"mode,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Antenna polarization in degrees
	Polarization *float64 `json:"polarization,omitempty"`

	// Antenna position (e.g. Top, Nadir, Side)
	Position *string `json:"position,omitempty"`

	// Array with 1-2 values specifying the length and width (for rectangular) and just length for dipole antennas in meters
	Size *[]float64 `json:"size,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Antenna start of frequency range in Mhz
	StartFrequency *float64 `json:"startFrequency,omitempty"`

	// Boolean indicating if this antenna is steerable
	Steerable *bool `json:"steerable,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of antenna (e.g. Reflector, Double Reflector, Shaped Reflector, Horn, Parabolic, etc.)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaDetailsFullDataMode string

// Antenna mode (e.g. TX,RX)
type AntennaDetailsFullMode string

// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
type AntennaFull struct {
	// Read-only collection of additional AntennaDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/antennadetails operations.
	AntennaDetails *[]AntennaDetailsFull `json:"antennaDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Antenna name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaFullDataMode string

// Detailed information on a spacecraft battery type compiled by a particular source. A Battery record may have multiple details records from several sources.
type BatteryDetailsFull struct {
	// Battery capacity in Ah
	Capacity *float64 `json:"capacity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryDetailsFullDataMode `json:"dataMode"`

	// Battery description/notes
	Description *string `json:"description,omitempty"`

	// Depth of discharge as a percentage/fraction
	DischargeDepth *float64 `json:"dischargeDepth,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent battery type record
	IdBattery string `json:"idBattery"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the battery
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Battery model number or name
	Model *string `json:"model,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of battery technology (e.g. Ni-Cd, Ni-H2, Li-ion, etc.)
	Technology *string `json:"technology,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryDetailsFullDataMode string

// Model representation of specific spacecraft battery types
type BatteryFull struct {
	// Read-only collection of additional BatteryDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/batterydetails operations.
	BatteryDetails *[]BatteryDetailsFull `json:"batteryDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Battery name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryFullDataMode string

// DataMode defines model for DataMode.
type DataMode string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite. The backing table contains historical element sets and current element sets (current elsets have a reference from the Currentelset table).
type ElsetAbridged struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetAbridgedDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetAbridgedDataMode string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite. The backing table contains historical element sets and current element sets (current elsets have a reference from the Currentelset table).
type ElsetFull struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// Read-only start time at which this elset was the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// Read-only end time at which this elset was no longer the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetFullDataMode string

// ElsetFullSourcedDataTypes defines model for ElsetFull.SourcedDataTypes.
type ElsetFullSourcedDataTypes string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite. The backing table contains historical element sets and current element sets (current elsets have a reference from the Currentelset table).
type ElsetIngest struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetIngestDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetIngestSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetIngestDataMode string

// ElsetIngestSourcedDataTypes defines model for ElsetIngest.SourcedDataTypes.
type ElsetIngestSourcedDataTypes string

// Known launch vehicle engine details and performance characteristics and limits compiled by a particular source.  A launch vehicle engine may have several details records from multiple sources.
type EngineDetailsFull struct {
	// Launch engine maximum burn time in seconds
	BurnTime *float64 `json:"burnTime,omitempty"`

	// Engine chamber pressure in bars
	ChamberPressure *float64 `json:"chamberPressure,omitempty"`

	// Engine characteristic type (e.g. Electric, Mono-propellant, Bi-propellant, etc.)
	CharacteristicType *string `json:"characteristicType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Engine cycle type (e.g. Electrostatic Ion, Pressure Fed, Hall, Catalytic Decomposition, etc.)
	CycleType *string `json:"cycleType,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineDetailsFullDataMode `json:"dataMode"`

	// Engine type or family
	Family *string `json:"family,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent engine record
	IdEngine string `json:"idEngine"`

	// Organization ID of the engine manufacturer
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Engine maximum number of firings
	MaxFirings *int32 `json:"maxFirings,omitempty"`

	// Notes/Description of the engine
	Notes *string `json:"notes,omitempty"`

	// Engine nozzle expansion ratio
	NozzleExpansionRatio *float64 `json:"nozzleExpansionRatio,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Oxidizer type (e.g. Nitrogen Tetroxide, Liquid Oxygen, etc)
	Oxidizer *string `json:"oxidizer,omitempty"`

	// Propellant/fuel type of the engine (e.g. Liquid Hydrogen, Kerosene, Aerozine, etc).
	Propellant *string `json:"propellant,omitempty"`

	// Engine maximum thrust at sea level in Kilo-Newtons
	SeaLevelThrust *float64 `json:"seaLevelThrust,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Launch engine specific impulse in seconds
	SpecificImpulse *float64 `json:"specificImpulse,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Engine maximum thrust in a vacuum in Kilo-Newtons
	VacuumThrust *float64 `json:"vacuumThrust,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineDetailsFullDataMode string

// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
type EngineFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineFullDataMode `json:"dataMode"`

	// Read-only collection of additional EngineDetails by various sources for this engine, ignored on create/update. These details must be created separately via the /udl/enginedetails operations.
	EngineDetails *[]EngineDetailsFull `json:"engineDetails,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Engine name/variant
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineFullDataMode string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Unique identifier of the target on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationAbridged `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitAbridged `json:"onOrbit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityAbridgedOwnerType `json:"ownerType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityAbridgedType `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityAbridgedDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityAbridgedOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityAbridgedType string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Unique identifier of the target on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
	OperatingUnit *OperatingunitFull `json:"operatingUnit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityFullOwnerType `json:"ownerType,omitempty"`

	// Read-only collection of RF bands utilized by this entity for communication and/or operation
	RfBands *[]RFBandFull `json:"rfBands,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of statuses which can be collected by multiple sources
	StatusCollection *[]StatusFull `json:"statusCollection,omitempty"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityFullType `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// List of URLs to additional details/documents for this entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityFullDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityFullOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityFullType string

// EphemFormatType defines model for EphemFormatType.
type EphemFormatType string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetAbridged struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetAbridgedCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetAbridgedDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetAbridgedReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetAbridgedDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetFull struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetFullDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisFull `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
	StateVector *StateVectorFull `json:"stateVector,omitempty"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetFullReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetIngest struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetIngestCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetIngestDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisIngest `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetIngestReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetIngestCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetIngestDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetIngestReferenceFrame string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisAbridgedDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisFullDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisFullDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisIngestDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisIngestDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationAbridged struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationAbridgedDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationFull struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationFullDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationFullDataMode string

// Read-only collection of antennas on this on-orbit object
type OnorbitAntennaFull struct {
	// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
	Antenna *AntennaFull `json:"antenna,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the antenna
	IdAntenna string `json:"idAntenna"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAntennaFullDataMode string

// Read-only collection of batteries on this on-orbit object
type OnorbitBatteryFull struct {
	// Model representation of specific spacecraft battery types
	Battery *BatteryFull `json:"battery,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitBatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the battery
	IdBattery string `json:"idBattery"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of batteries on the spacecraft of the type identified by idBattery
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitBatteryFullDataMode string

// Contains details of the OnOrbit object
type OnorbitDetailsFull struct {
	// Mass of fuel and disposables at launch time in kg
	AdditionalMass *float64 `json:"additionalMass,omitempty"`

	// The radius used for long-term debris environment projection analyses that is not as conservative as COLA Radius, in meters
	AdeptRadius *float64 `json:"adeptRadius,omitempty"`

	// Spacecraft beginning of life fuel mass, in orbit, in kg
	BolFuelMass *float64 `json:"bolFuelMass,omitempty"`

	// Average cross sectional area of the bus in meters squared
	BusCrossSection *float64 `json:"busCrossSection,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Maximum dimension of the box circumscribing the spacecraft (d = sqrt(a*a + b*b + c*c) where a is the tip-to-tip dimension, b and c are perpendicular to that.) in meters
	ColaRadius *float64 `json:"colaRadius,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Average cross sectional area in meters squared
	CrossSection *float64 `json:"crossSection,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitDetailsFullDataMode `json:"dataMode"`

	// GEO drift rate, if applicable in degrees per day
	DriftRate *float64 `json:"driftRate,omitempty"`

	// Spacecraft dry mass (without fuel or disposables) in kg
	DryMass *float64 `json:"dryMass,omitempty"`

	// Estimated maxmimum burn duration for the object
	EstDeltaVDuration *float64 `json:"estDeltaVDuration,omitempty"`

	// Estimated remaining fuel for the object in kg
	FuelRemaining *float64 `json:"fuelRemaining,omitempty"`

	// GEO slot if applicable, in degrees. -180 (West of Prime Meridian) to 180 degrees (East of Prime Meridian). Prime Meridian is 0.
	GeoSlot *float64 `json:"geoSlot,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// UUID of the parent Onorbit record
	IdOnOrbit string `json:"idOnOrbit"`

	// The name of the source who last provided an observation for this idOnOrbit
	LastObSource *string `json:"lastObSource,omitempty"`

	// Time of last reported observation for this object in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Nominal mass of spacecraft and fuel at launch time, in kg
	LaunchMass *float64 `json:"launchMass,omitempty"`

	// Maximum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMax *float64 `json:"launchMassMax,omitempty"`

	// Minimum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMin *float64 `json:"launchMassMin,omitempty"`

	// Maximum delta V available for this on-orbit spacecraft
	MaxDeltaV *float64 `json:"maxDeltaV,omitempty"`

	// Maximum dimension across the spacecraft (e.g., tip-to-tip across the solar panel arrays) in meters
	MaxRadius *float64 `json:"maxRadius,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Current/latest radar cross section in meters squared
	Rcs *float64 `json:"rcs,omitempty"`

	// Maximum radar cross section in meters squared
	RcsMax *float64 `json:"rcsMax,omitempty"`

	// Mean radar cross section in meters squared
	RcsMean *float64 `json:"rcsMean,omitempty"`

	// Minimum radar cross section in meters squared
	RcsMin *float64 `json:"rcsMin,omitempty"`

	// Spacecraft deployed area of solar array in sq meters
	SolarArrayArea *float64 `json:"solarArrayArea,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Current/latest visual magnitude in M
	Vismag *float64 `json:"vismag,omitempty"`

	// Maximum visual magnitude in M
	VismagMax *float64 `json:"vismagMax,omitempty"`

	// Mean visual magnitude in M
	VismagMean *float64 `json:"vismagMean,omitempty"`

	// Minimum visual magnitude in M
	VismagMin *float64 `json:"vismagMin,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitDetailsFullDataMode string

// Read-only collection of solar arrays on this on-orbit object
type OnorbitSolarArrayFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitSolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// ID of the SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of solar arrays on the spacecraft of the type identified by idSolarArray
	Quantity *int32 `json:"quantity,omitempty"`

	// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
	SolarArray *SolarArrayFull `json:"solarArray,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitSolarArrayFullDataMode string

// Read-only collection of thrusters (engines) on this on-orbit object
type OnorbitThrusterFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitThrusterFullDataMode `json:"dataMode"`

	// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
	Engine *EngineFull `json:"engine,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Engine
	IdEngine string `json:"idEngine"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of engines/thrusters on the spacecraft of the type identified by idEngine
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitThrusterFullDataMode string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitAbridged struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitAbridgedCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAbridgedDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitAbridgedObjectType `json:"objectType,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Source of the data
	Source string `json:"source"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitAbridgedCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAbridgedDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitAbridgedObjectType string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitFull struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Read-only collection of antennas on this on-orbit object
	Antennas *[]OnorbitAntennaFull `json:"antennas,omitempty"`

	// Read-only collection of batteries on this on-orbit object
	Batteries *[]OnorbitBatteryFull `json:"batteries,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitFullCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitFullDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// Read-only entity details (only returned/used on detail queries).
	EntityCollection *[]EntityFull `json:"entityCollection,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitFullObjectType `json:"objectType,omitempty"`

	// Read-only collection of details for this on-orbit object
	OnorbitDetails *[]OnorbitDetailsFull `json:"onorbitDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Read-only collection of solar arrays on this on-orbit object
	SolarArrays *[]OnorbitSolarArrayFull `json:"solarArrays,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of thrusters (engines) on this on-orbit object
	Thrusters *[]OnorbitThrusterFull `json:"thrusters,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitFullCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitFullDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitFullObjectType string

// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
type OperatingunitFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OperatingunitFullDataMode `json:"dataMode"`

	// Description of the operating unit
	Description *string `json:"description,omitempty"`

	// Unique identifier of the contact for this operating unit
	IdContact *string `json:"idContact,omitempty"`

	// Unique identifier of the location record for this operating unit
	IdLocation *string `json:"idLocation,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Unique identifier of the organization record for this operating unit
	IdOrganization *string `json:"idOrganization,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Name of the operating unit
	Name string `json:"name"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	Organization *OrganizationFull `json:"organization,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OperatingunitFullDataMode string

// Model representation of additional detailed organization data as collected by a particular source.
type OrganizationDetailsFull struct {
	// Designated broker for this organization.
	Broker *string `json:"broker,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Executive Officer.
	Ceo *string `json:"ceo,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Financial Officer.
	Cfo *string `json:"cfo,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Technology Officer.
	Cto *string `json:"cto,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationDetailsFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// For organizations of type CORPORATION, the company EBITDA value as of financialYearEndDate in US Dollars.
	Ebitda *float64 `json:"ebitda,omitempty"`

	// For organizations of type CORPORATION, notes on company financials.
	FinancialNotes *string `json:"financialNotes,omitempty"`

	// For organizations of type CORPORATION, the effective financial year end date for revenue, EBITDA, and profit values.
	FinancialYearEndDate *time.Time `json:"financialYearEndDate,omitempty"`

	// Satellite fleet planning notes for this organization.
	FleetPlanNotes *string `json:"fleetPlanNotes,omitempty"`

	// Former organization ID (if this organization previously existed as another organization)
	FormerOrgId *string `json:"formerOrgId,omitempty"`

	// Total number of FTEs in this organization.
	Ftes *int32 `json:"ftes,omitempty"`

	// Unique identifier of the parent organization.
	IdOrganization string `json:"idOrganization"`

	// Mass ranking for this organization.
	MassRanking *int32 `json:"massRanking,omitempty"`

	// Organization details name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Parent organization ID of this organization if it is a child organization
	ParentOrgId *string `json:"parentOrgId,omitempty"`

	// For organizations of type CORPORATION, total annual profit as of financialYearEndDate in US Dollars.
	Profit *float64 `json:"profit,omitempty"`

	// For organizations of type CORPORATION, total annual revenue as of financialYearEndDate in US Dollars.
	Revenue *float64 `json:"revenue,omitempty"`

	// Revenue ranking for this organization.
	RevenueRanking *int32 `json:"revenueRanking,omitempty"`

	// The name of the risk manager for the organization.
	RiskManager *string `json:"riskManager,omitempty"`

	// Notes on the services provided by the organization.
	ServicesNotes *string `json:"servicesNotes,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationDetailsFullDataMode string

// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
type OrganizationFull struct {
	// Boolean indicating if this organization is currently active.
	Active *bool `json:"active,omitempty"`

	// Subtype or category of the organization (e.g. Private company, stock market quoted company, subsidiary, goverment department/agency, etc).
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code of this organization's headquarters.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// Optional externally provided identifier for this row
	ExternalId *string `json:"externalId,omitempty"`

	// Organization name
	Name string `json:"name"`

	// Read-only collection of additional OrganizationDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/organizationdetails operations.
	OrganizationDetails *[]OrganizationDetailsFull `json:"organizationDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Type of organization (e.g. GOVERNMENT, CORPORATION, CONSORTIUM, ACADEMIC)
	Type string `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationFullDataMode string

// Details on a particular Radio Frequency (RF) band, also known as a carrier, which may be in use by any type of Entity for communications or operations.
type RFBandFull struct {
	// Name of the band of this RF range (e.g. X,K,Ku,L,S,C,UHF,VHF). See RFBandType for more details and descriptions of each band name.
	Band *string `json:"band,omitempty"`

	// RF Band frequency range bandwidth in Mhz
	Bandwidth *float64 `json:"bandwidth,omitempty"`

	// Angle between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Center frequency of RF frequency range, if applicable, in Mhz
	CenterFreq *float64 `json:"centerFreq,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode RFBandFullDataMode `json:"dataMode"`

	// RF Range edge gain, in dBi
	EdgeGain *float64 `json:"edgeGain,omitempty"`

	// ERP is defined as the RMS power input in decibel watts required to a lossless half-wave dipole antenna to give the same maximum power density far from the antenna as the actual transmitter. It is equal to the power input to the transmitter''s antenna multiplied by the antenna gain relative to a half-wave dipole. Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Eirp *float64 `json:"eirp,omitempty"`

	// Effective Radiated Power (ERP) is the total power in decibel watts radiated by an actual antenna relative to a half-wave dipole rather than a theoretical isotropic antenna. A half-wave dipole has a gain of 2.15 dB compared to an isotropic antenna.  EIRP(dB) = ERP (dB)+2.15 Db or EIRP (W) = 1.64*ERP(W). Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Erp *float64 `json:"erp,omitempty"`

	// End/maximum of transmit RF frequency range, if applicable, in Mhz
	FreqMax *float64 `json:"freqMax,omitempty"`

	// Start/minimum of transmit RF frequency range, if applicable, in Mhz
	FreqMin *float64 `json:"freqMin,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Entity which uses this band
	IdEntity string `json:"idEntity"`

	// RF Band mode (e.g. TX, RX)
	Mode *RFBandFullMode `json:"mode,omitempty"`

	// Optional RF Band name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// RF Range maximum gain, in dBi
	PeakGain *float64 `json:"peakGain,omitempty"`

	// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
	Polarization *RFBandFullPolarization `json:"polarization,omitempty"`

	// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
	Purpose *RFBandFullPurpose `json:"purpose,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type RFBandFullDataMode string

// RF Band mode (e.g. TX, RX)
type RFBandFullMode string

// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
type RFBandFullPolarization string

// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
type RFBandFullPurpose string

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsAbridgedDataMode string

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsFullDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorAbridged struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorAbridgedDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityAbridged `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeAbridged `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsAbridged `json:"sensorStats,omitempty"`
	SensorType  *SensortypeAbridged    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsAbridged `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsAbridged `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorAbridgedDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorFull struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorFullDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityFull `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeFull `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsFull `json:"sensorStats,omitempty"`
	SensorType  *SensortypeFull    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsFull `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsFull `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorFullDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsAbridged struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsAbridgedDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsAbridgedDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsFull struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsFullDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent sensor
	IdSensor string `json:"idSensor"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsFullDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsAbridgedDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsFullDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsFullDataMode string

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorobservationtypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorobservationtypeFullDataMode string

// SensortypeAbridged defines model for Sensortype_Abridged.
type SensortypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32            `json:"id,omitempty"`
	SensorCollection *[]SensorAbridged `json:"sensorCollection,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// SensortypeFull defines model for Sensortype_Full.
type SensortypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensortypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32        `json:"id,omitempty"`
	SensorCollection *[]SensorFull `json:"sensorCollection,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensortypeFullDataMode string

// Model representation of Information on spacecraft SolarArrayDetails. A SolarArray may have multiple details records compiled by various sources.
type SolarArrayDetailsFull struct {
	// Solar Array area in square meters
	Area *float64 `json:"area,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayDetailsFullDataMode `json:"dataMode"`

	// Solar array description/notes
	Description *string `json:"description,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Unique identifier of the parent SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Solar array junction technology (e.g. Triple)
	JunctionTechnology *string `json:"junctionTechnology,omitempty"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the solar array
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Solar Array span in meters
	Span *float64 `json:"span,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Solar array technology (e.g. Ga-As)
	Technology *string `json:"technology,omitempty"`

	// Type of solar array (e.g. U Shaped)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayDetailsFullDataMode string

// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
type SolarArrayFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Solar Array name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Read-only collection of additional SolarArrayDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/solararraydetails operations.
	SolarArrayDetails *[]SolarArrayDetailsFull `json:"solarArrayDetails,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayFullDataMode string

// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
type StateVectorFull struct {
	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// First derivative of drag/ballistic coefficient (m2/kg-s).
	BDot *float64 `json:"bDot,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Model parameter value for center of mass offset (m).
	CmOffset *float64 `json:"cmOffset,omitempty"`

	// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	Cov *[]float64 `json:"cov,omitempty"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *StateVectorFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StateVectorFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
	DragCoeff *float64 `json:"dragCoeff,omitempty"`

	// Drag model used for this vector (e.g. HARRIS-PRIESTER, JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR) (w/kg).
	Edr *float64 `json:"edr,omitempty"`

	// Start time at which this state vector was the 'current' state vector for its satellite.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// End time at which this state vector was no longer the 'current' state vector for its satellite.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
	//
	// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
	//
	// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	//
	//
	//
	// The ordering of values is as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
	//
	// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
	//
	// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
	//
	// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
	//
	// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
	//
	// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
	//
	// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
	//
	// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
	//
	// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
	//
	// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
	//
	// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
	//
	// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
	//
	// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
	//
	// :
	//
	// :
	//
	// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
	EqCov *[]float64 `json:"eqCov,omitempty"`

	// Integrator error control.
	ErrorControl *float64 `json:"errorControl,omitempty"`

	// Boolean indicating use of fixed step size for this vector.
	FixedStep *bool `json:"fixedStep,omitempty"`

	// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
	Iau1980Terms *int32 `json:"iau1980Terms,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Boolean indicating use of in-track thrust perturbations for this vector.
	InTrackThrust *bool `json:"inTrackThrust,omitempty"`

	// Integrator Mode
	IntegratorMode *string `json:"integratorMode,omitempty"`

	// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
	LeapSecondTime *time.Time `json:"leapSecondTime,omitempty"`

	// Boolean indicating use of lunar/solar perturbations for this vector.
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
	Partials *string `json:"partials,omitempty"`

	// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN)
	Pedigree *string `json:"pedigree,omitempty"`

	// Polar Wander Motion X (arc seconds).
	PolarMotionX *float64 `json:"polarMotionX,omitempty"`

	// Polar Wander Motion Y (arc seconds).
	PolarMotionY *float64 `json:"polarMotionY,omitempty"`

	// Approximate position uncertainty (kilometers)
	PosUnc *float64 `json:"posUnc,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *StateVectorFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Epoch revolution number.
	RevNo *int32 `json:"revNo,omitempty"`

	// Weighted Root Mean Squared (RMS) of last differential correction on the target object.
	Rms *float64 `json:"rms,omitempty"`

	// Satellite/Catalog number of the target OnOrbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
	SigmaPosUVW *[]float64 `json:"sigmaPosUVW,omitempty"`

	// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
	SigmaVelUVW *[]float64 `json:"sigmaVelUVW,omitempty"`

	// Average solar flux geomagnetic index.
	SolarFluxAPAvg *float64 `json:"solarFluxAPAvg,omitempty"`

	// F10 (10.7 cm) solar flux value.
	SolarFluxF10 *float64 `json:"solarFluxF10,omitempty"`

	// F10 (10.7 cm) solar flux 81-day average value.
	SolarFluxF10Avg *float64 `json:"solarFluxF10Avg,omitempty"`

	// Boolean indicating use of solar radiation pressure perturbations for this vector.
	SolarRadPress *bool `json:"solarRadPress,omitempty"`

	// Area-to-mass ratio coefficient for solar radiation pressure
	SolarRadPressCoeff *float64 `json:"solarRadPressCoeff,omitempty"`

	// Boolean indicating use of solid earth tide perturbations for this vector.
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *StateVectorFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Integrator step mode (AUTO, TIME, or S).
	StepMode *string `json:"stepMode,omitempty"`

	// Initial integration step size (seconds).
	StepSize *float64 `json:"stepSize,omitempty"`

	// Initial step size selection (AUTO or MANUAL).
	StepSizeSelection *string `json:"stepSizeSelection,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
	TaiUtc *float64 `json:"taiUtc,omitempty"`

	// Model parameter value for thrust acceleration (m/s2).
	ThrustAccel *float64 `json:"thrustAccel,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`

	// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
	Ut1Rate *float64 `json:"ut1Rate,omitempty"`

	// Universal Time-1 (UT1) minus UTC offset, in seconds.
	Ut1Utc *float64 `json:"ut1Utc,omitempty"`

	// Approximate velocity uncertainty
	VelUnc *float64 `json:"velUnc,omitempty"`

	// Cartesian X position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos *float64 `json:"xpos,omitempty"`

	// Cartesian X velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel *float64 `json:"xvel,omitempty"`

	// Cartesian Y position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos *float64 `json:"ypos,omitempty"`

	// Cartesian Y velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel *float64 `json:"yvel,omitempty"`

	// Cartesian Z position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zpos *float64 `json:"zpos,omitempty"`

	// Cartesian Z velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel *float64 `json:"zvel,omitempty"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type StateVectorFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StateVectorFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type StateVectorFullReferenceFrame string

// StateVectorFullSourcedDataTypes defines model for StateVectorFull.SourcedDataTypes.
type StateVectorFullSourcedDataTypes string

// Status for a particular Entity. An entity may have multiple status records collected by various sources.
type StatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StatusFullDataMode `json:"dataMode"`

	// The declassification date of this data, in ISO 8601 UTC format.
	DeclassificationDate *time.Time `json:"declassificationDate,omitempty"`

	// Declassification string of this data.
	DeclassificationString *string `json:"declassificationString,omitempty"`

	// The sources or SCG references from which the classification of this data is derived.
	DerivedFrom *string `json:"derivedFrom,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent entity
	IdEntity string `json:"idEntity"`

	// Comments describing the status creation and or updates to an entity
	Notes *string `json:"notes,omitempty"`

	// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	OpsCap *StatusFullOpsCap `json:"opsCap,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
	State               *StatusFullState `json:"state,omitempty"`
	SubStatusCollection *[]SubStatusFull `json:"subStatusCollection,omitempty"`

	// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	SysCap *StatusFullSysCap `json:"sysCap,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StatusFullDataMode string

// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullOpsCap string

// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
type StatusFullState string

// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullSysCap string

// Additional sub-system or capability status for the parent entity.
type SubStatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SubStatusFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Descriptions and/or comments associated with the sub-status
	Notes string `json:"notes"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
	Status SubStatusFullStatus `json:"status"`

	// Id of the parent status
	StatusId string `json:"statusId"`

	// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
	Type SubStatusFullType `json:"type"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SubStatusFullDataMode string

// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
type SubStatusFullStatus string

// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
type SubStatusFullType string

// FiledropEphemPostIdParams defines parameters for FiledropEphemPostId.
type FiledropEphemPostIdParams struct {
	// Unique identifier of the on-orbit satellite object.
	IdOnOrbit string `form:"idOnOrbit" json:"idOnOrbit"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	Classification string `form:"classification" json:"classification"`

	// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
	DataMode DataMode `form:"dataMode" json:"dataMode"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
	HasMnvr bool `form:"hasMnvr" json:"hasMnvr"`

	// Ephemeris type.
	Type string `form:"type" json:"type"`

	// Ephemeris category.
	Category string `form:"category" json:"category"`

	// Ephemeris format as documented in Flight Safety Handbook.
	EphemFormatType EphemFormatType `form:"ephemFormatType" json:"ephemFormatType"`

	// Optional origin of the Ephemeris.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`
}

// FiledropUdlElsetPostIdJSONBody defines parameters for FiledropUdlElsetPostId.
type FiledropUdlElsetPostIdJSONBody = []ElsetIngest

// FiledropUdlEphsetPostIdJSONBody defines parameters for FiledropUdlEphsetPostId.
type FiledropUdlEphsetPostIdJSONBody = EphemerisSetIngest

// FindAllWithStream6Params defines parameters for FindAllWithStream6.
type FindAllWithStream6Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// Create25JSONBody defines parameters for Create25.
type Create25JSONBody = ElsetIngest

// CountREST23Params defines parameters for CountREST23.
type CountREST23Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// CreateBulks8JSONBody defines parameters for CreateBulks8.
type CreateBulks8JSONBody = []ElsetIngest

// CreateBulks8Params defines parameters for CreateBulks8.
type CreateBulks8Params struct {
	// Boolean indicating if these elsets should be checked for duplicates, default is not to
	DupeCheck *bool `form:"dupeCheck,omitempty" json:"dupeCheck,omitempty"`
}

// CreateBulkFromTLEParams defines parameters for CreateBulkFromTLE.
type CreateBulkFromTLEParams struct {
	// Data mode of the passed elsets (REAL, TEST, etc)
	DataMode string `form:"dataMode" json:"dataMode"`

	// Dissemination control of the passed elsets (e.g. to support tagging with proprietary markings)
	Control *string `form:"control,omitempty" json:"control,omitempty"`

	// Boolean indicating if these elsets should be set as the 'current' for their corresponding on-orbit/satellite numbers.
	MakeCurrent bool `form:"makeCurrent" json:"makeCurrent"`

	// Source of the elset data.
	Source string `form:"source" json:"source"`

	// Origin of the elset data.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`

	// Boolean indicating if a shell Onorbit/satellite should be created if the passed satellite number doesn't exist.
	AutoCreateSats *bool `form:"autoCreateSats,omitempty" json:"autoCreateSats,omitempty"`

	// Optional comma-delineated list of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// CurrentTupleParams defines parameters for CurrentTuple.
type CurrentTupleParams struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the ‘queryhelp’ operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// FindAllHistory12Params defines parameters for FindAllHistory12.
type FindAllHistory12Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllHistoryAodr12Params defines parameters for FindAllHistoryAodr12.
type FindAllHistoryAodr12Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// CountHistory12Params defines parameters for CountHistory12.
type CountHistory12Params struct {
	// Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllTuples25Params defines parameters for FindAllTuples25.
type FindAllTuples25Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the ‘queryhelp’ operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC time, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// FindAllWithStream7Params defines parameters for FindAllWithStream7.
type FindAllWithStream7Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountDuplicate3Params defines parameters for CountDuplicate3.
type CountDuplicate3Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistory13Params defines parameters for FindAllHistory13.
type FindAllHistory13Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistoryAodr13Params defines parameters for FindAllHistoryAodr13.
type FindAllHistoryAodr13Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountHistory13Params defines parameters for CountHistory13.
type CountHistory13Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllTuples28Params defines parameters for FindAllTuples28.
type FindAllTuples28Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the ‘queryhelp’ operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllWithStream8Params defines parameters for FindAllWithStream8.
type FindAllWithStream8Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// Create29JSONBody defines parameters for Create29.
type Create29JSONBody = EphemerisSetIngest

// CountREST26Params defines parameters for CountREST26.
type CountREST26Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistory14Params defines parameters for FindAllHistory14.
type FindAllHistory14Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistoryAodr14Params defines parameters for FindAllHistoryAodr14.
type FindAllHistoryAodr14Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// CountHistory14Params defines parameters for CountHistory14.
type CountHistory14Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllTuples29Params defines parameters for FindAllTuples29.
type FindAllTuples29Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the ‘queryhelp’ operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FiledropUdlElsetPostIdJSONRequestBody defines body for FiledropUdlElsetPostId for application/json ContentType.
type FiledropUdlElsetPostIdJSONRequestBody = FiledropUdlElsetPostIdJSONBody

// FiledropUdlEphsetPostIdJSONRequestBody defines body for FiledropUdlEphsetPostId for application/json ContentType.
type FiledropUdlEphsetPostIdJSONRequestBody = FiledropUdlEphsetPostIdJSONBody

// Create25JSONRequestBody defines body for Create25 for application/json ContentType.
type Create25JSONRequestBody = Create25JSONBody

// CreateBulks8JSONRequestBody defines body for CreateBulks8 for application/json ContentType.
type CreateBulks8JSONRequestBody = CreateBulks8JSONBody

// Create29JSONRequestBody defines body for Create29 for application/json ContentType.
type Create29JSONRequestBody = Create29JSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream6 request
	FindAllWithStream6(ctx context.Context, params *FindAllWithStream6Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create25 request with any body
	Create25WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create25(ctx context.Context, body Create25JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST23 request
	CountREST23(ctx context.Context, params *CountREST23Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Current request
	Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentTuple request
	CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory12 request
	FindAllHistory12(ctx context.Context, params *FindAllHistory12Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr12 request
	FindAllHistoryAodr12(ctx context.Context, params *FindAllHistoryAodr12Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory12 request
	CountHistory12(ctx context.Context, params *CountHistory12Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp26 request
	Queryhelp26(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples25 request
	FindAllTuples25(ctx context.Context, params *FindAllTuples25Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find24 request
	Find24(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream7 request
	FindAllWithStream7(ctx context.Context, params *FindAllWithStream7Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate3 request
	CountDuplicate3(ctx context.Context, params *CountDuplicate3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory13 request
	FindAllHistory13(ctx context.Context, params *FindAllHistory13Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr13 request
	FindAllHistoryAodr13(ctx context.Context, params *FindAllHistoryAodr13Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory13 request
	CountHistory13(ctx context.Context, params *CountHistory13Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp29 request
	Queryhelp29(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples28 request
	FindAllTuples28(ctx context.Context, params *FindAllTuples28Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create29 request with any body
	Create29WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create29(ctx context.Context, body Create29JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST26 request
	CountREST26(ctx context.Context, params *CountREST26Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile1 request
	GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory14 request
	FindAllHistory14(ctx context.Context, params *FindAllHistory14Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr14 request
	FindAllHistoryAodr14(ctx context.Context, params *FindAllHistoryAodr14Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory14 request
	CountHistory14(ctx context.Context, params *CountHistory14Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp30 request
	Queryhelp30(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples29 request
	FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find28 request
	Find28(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropEphemPostIdRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream6(ctx context.Context, params *FindAllWithStream6Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream6Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create25WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate25RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create25(ctx context.Context, body Create25JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate25Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST23(ctx context.Context, params *CountREST23Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST23Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8RequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8Request(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulkFromTLERequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentTupleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory12(ctx context.Context, params *FindAllHistory12Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory12Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr12(ctx context.Context, params *FindAllHistoryAodr12Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr12Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory12(ctx context.Context, params *CountHistory12Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory12Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp26(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp26Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples25(ctx context.Context, params *FindAllTuples25Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples25Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find24(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind24Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream7(ctx context.Context, params *FindAllWithStream7Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream7Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate3(ctx context.Context, params *CountDuplicate3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory13(ctx context.Context, params *FindAllHistory13Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory13Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr13(ctx context.Context, params *FindAllHistoryAodr13Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr13Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory13(ctx context.Context, params *CountHistory13Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory13Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp29(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp29Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples28(ctx context.Context, params *FindAllTuples28Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples28Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create29WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate29RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create29(ctx context.Context, body Create29JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate29Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST26(ctx context.Context, params *CountREST26Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST26Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFile1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory14(ctx context.Context, params *FindAllHistory14Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory14Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr14(ctx context.Context, params *FindAllHistoryAodr14Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr14Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory14(ctx context.Context, params *CountHistory14Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory14Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp30(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp30Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples29Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find28(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind28Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewFiledropEphemPostIdRequestWithBody generates requests for FiledropEphemPostId with any type of body
func NewFiledropEphemPostIdRequestWithBody(server string, params *FiledropEphemPostIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/ephem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idOnOrbit", runtime.ParamLocationQuery, params.IdOnOrbit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classification", runtime.ParamLocationQuery, params.Classification); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasMnvr", runtime.ParamLocationQuery, params.HasMnvr); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, params.Category); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ephemFormatType", runtime.ParamLocationQuery, params.EphemFormatType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlElsetPostIdRequest calls the generic FiledropUdlElsetPostId builder with application/json body
func NewFiledropUdlElsetPostIdRequest(server string, body FiledropUdlElsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlElsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlElsetPostIdRequestWithBody generates requests for FiledropUdlElsetPostId with any type of body
func NewFiledropUdlElsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlEphsetPostIdRequest calls the generic FiledropUdlEphsetPostId builder with application/json body
func NewFiledropUdlEphsetPostIdRequest(server string, body FiledropUdlEphsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlEphsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlEphsetPostIdRequestWithBody generates requests for FiledropUdlEphsetPostId with any type of body
func NewFiledropUdlEphsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-ephset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllWithStream6Request generates requests for FindAllWithStream6
func NewFindAllWithStream6Request(server string, params *FindAllWithStream6Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate25Request calls the generic Create25 builder with application/json body
func NewCreate25Request(server string, body Create25JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate25RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate25RequestWithBody generates requests for Create25 with any type of body
func NewCreate25RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST23Request generates requests for CountREST23
func NewCountREST23Request(server string, params *CountREST23Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks8Request calls the generic CreateBulks8 builder with application/json body
func NewCreateBulks8Request(server string, params *CreateBulks8Params, body CreateBulks8JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks8RequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBulks8RequestWithBody generates requests for CreateBulks8 with any type of body
func NewCreateBulks8RequestWithBody(server string, params *CreateBulks8Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DupeCheck != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dupeCheck", runtime.ParamLocationQuery, *params.DupeCheck); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBulkFromTLERequestWithBody generates requests for CreateBulkFromTLE with any type of body
func NewCreateBulkFromTLERequestWithBody(server string, params *CreateBulkFromTLEParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulkFromTLE")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Control != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "control", runtime.ParamLocationQuery, *params.Control); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "makeCurrent", runtime.ParamLocationQuery, params.MakeCurrent); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AutoCreateSats != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoCreateSats", runtime.ParamLocationQuery, *params.AutoCreateSats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrentRequest generates requests for Current
func NewCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentTupleRequest generates requests for CurrentTuple
func NewCurrentTupleRequest(server string, params *CurrentTupleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory12Request generates requests for FindAllHistory12
func NewFindAllHistory12Request(server string, params *FindAllHistory12Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr12Request generates requests for FindAllHistoryAodr12
func NewFindAllHistoryAodr12Request(server string, params *FindAllHistoryAodr12Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory12Request generates requests for CountHistory12
func NewCountHistory12Request(server string, params *CountHistory12Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp26Request generates requests for Queryhelp26
func NewQueryhelp26Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples25Request generates requests for FindAllTuples25
func NewFindAllTuples25Request(server string, params *FindAllTuples25Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind24Request generates requests for Find24
func NewFind24Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream7Request generates requests for FindAllWithStream7
func NewFindAllWithStream7Request(server string, params *FindAllWithStream7Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate3Request generates requests for CountDuplicate3
func NewCountDuplicate3Request(server string, params *CountDuplicate3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory13Request generates requests for FindAllHistory13
func NewFindAllHistory13Request(server string, params *FindAllHistory13Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr13Request generates requests for FindAllHistoryAodr13
func NewFindAllHistoryAodr13Request(server string, params *FindAllHistoryAodr13Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory13Request generates requests for CountHistory13
func NewCountHistory13Request(server string, params *CountHistory13Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp29Request generates requests for Queryhelp29
func NewQueryhelp29Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples28Request generates requests for FindAllTuples28
func NewFindAllTuples28Request(server string, params *FindAllTuples28Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream8Request generates requests for FindAllWithStream8
func NewFindAllWithStream8Request(server string, params *FindAllWithStream8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate29Request calls the generic Create29 builder with application/json body
func NewCreate29Request(server string, body Create29JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate29RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate29RequestWithBody generates requests for Create29 with any type of body
func NewCreate29RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST26Request generates requests for CountREST26
func NewCountREST26Request(server string, params *CountREST26Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFile1Request generates requests for GetFile1
func NewGetFile1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/getFile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory14Request generates requests for FindAllHistory14
func NewFindAllHistory14Request(server string, params *FindAllHistory14Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr14Request generates requests for FindAllHistoryAodr14
func NewFindAllHistoryAodr14Request(server string, params *FindAllHistoryAodr14Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory14Request generates requests for CountHistory14
func NewCountHistory14Request(server string, params *CountHistory14Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp30Request generates requests for Queryhelp30
func NewQueryhelp30Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples29Request generates requests for FindAllTuples29
func NewFindAllTuples29Request(server string, params *FindAllTuples29Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind28Request generates requests for Find28
func NewFind28Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	// FindAllWithStream6 request
	FindAllWithStream6WithResponse(ctx context.Context, params *FindAllWithStream6Params, reqEditors ...RequestEditorFn) (*FindAllWithStream6Response, error)

	// Create25 request with any body
	Create25WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create25Response, error)

	Create25WithResponse(ctx context.Context, body Create25JSONRequestBody, reqEditors ...RequestEditorFn) (*Create25Response, error)

	// CountREST23 request
	CountREST23WithResponse(ctx context.Context, params *CountREST23Params, reqEditors ...RequestEditorFn) (*CountREST23Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error)

	// Current request
	CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error)

	// CurrentTuple request
	CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error)

	// FindAllHistory12 request
	FindAllHistory12WithResponse(ctx context.Context, params *FindAllHistory12Params, reqEditors ...RequestEditorFn) (*FindAllHistory12Response, error)

	// FindAllHistoryAodr12 request
	FindAllHistoryAodr12WithResponse(ctx context.Context, params *FindAllHistoryAodr12Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr12Response, error)

	// CountHistory12 request
	CountHistory12WithResponse(ctx context.Context, params *CountHistory12Params, reqEditors ...RequestEditorFn) (*CountHistory12Response, error)

	// Queryhelp26 request
	Queryhelp26WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp26Response, error)

	// FindAllTuples25 request
	FindAllTuples25WithResponse(ctx context.Context, params *FindAllTuples25Params, reqEditors ...RequestEditorFn) (*FindAllTuples25Response, error)

	// Find24 request
	Find24WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find24Response, error)

	// FindAllWithStream7 request
	FindAllWithStream7WithResponse(ctx context.Context, params *FindAllWithStream7Params, reqEditors ...RequestEditorFn) (*FindAllWithStream7Response, error)

	// CountDuplicate3 request
	CountDuplicate3WithResponse(ctx context.Context, params *CountDuplicate3Params, reqEditors ...RequestEditorFn) (*CountDuplicate3Response, error)

	// FindAllHistory13 request
	FindAllHistory13WithResponse(ctx context.Context, params *FindAllHistory13Params, reqEditors ...RequestEditorFn) (*FindAllHistory13Response, error)

	// FindAllHistoryAodr13 request
	FindAllHistoryAodr13WithResponse(ctx context.Context, params *FindAllHistoryAodr13Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr13Response, error)

	// CountHistory13 request
	CountHistory13WithResponse(ctx context.Context, params *CountHistory13Params, reqEditors ...RequestEditorFn) (*CountHistory13Response, error)

	// Queryhelp29 request
	Queryhelp29WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp29Response, error)

	// FindAllTuples28 request
	FindAllTuples28WithResponse(ctx context.Context, params *FindAllTuples28Params, reqEditors ...RequestEditorFn) (*FindAllTuples28Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error)

	// Create29 request with any body
	Create29WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create29Response, error)

	Create29WithResponse(ctx context.Context, body Create29JSONRequestBody, reqEditors ...RequestEditorFn) (*Create29Response, error)

	// CountREST26 request
	CountREST26WithResponse(ctx context.Context, params *CountREST26Params, reqEditors ...RequestEditorFn) (*CountREST26Response, error)

	// GetFile1 request
	GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error)

	// FindAllHistory14 request
	FindAllHistory14WithResponse(ctx context.Context, params *FindAllHistory14Params, reqEditors ...RequestEditorFn) (*FindAllHistory14Response, error)

	// FindAllHistoryAodr14 request
	FindAllHistoryAodr14WithResponse(ctx context.Context, params *FindAllHistoryAodr14Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr14Response, error)

	// CountHistory14 request
	CountHistory14WithResponse(ctx context.Context, params *CountHistory14Params, reqEditors ...RequestEditorFn) (*CountHistory14Response, error)

	// Queryhelp30 request
	Queryhelp30WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp30Response, error)

	// FindAllTuples29 request
	FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error)

	// Find28 request
	Find28WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find28Response, error)
}

type FiledropEphemPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropEphemPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropEphemPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlElsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlElsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlElsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlEphsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlEphsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlEphsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create25Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST23Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST23Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST23Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks8Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulkFromTLEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulkFromTLEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulkFromTLEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r CurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentTupleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r CurrentTupleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentTupleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory12Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory12Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory12Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr12Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr12Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr12Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory12Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory12Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory12Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp26Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp26Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp26Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples25Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find24Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElsetFull
}

// Status returns HTTPResponse.Status
func (r Find24Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find24Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory13Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory13Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory13Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr13Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr13Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr13Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory13Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory13Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory13Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp29Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples28Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples28Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples28Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create29Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST26Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST26Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST26Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFile1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFile1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFile1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory14Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory14Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory14Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr14Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr14Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr14Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory14Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory14Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory14Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp30Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp30Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp30Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples29Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find28Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r Find28Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find28Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// FiledropEphemPostIdWithBodyWithResponse request with arbitrary body returning *FiledropEphemPostIdResponse
func (c *ClientWithResponses) FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error) {
	rsp, err := c.FiledropEphemPostIdWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropEphemPostIdResponse(rsp)
}

// FiledropUdlElsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlElsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

// FiledropUdlEphsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlEphsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

// FindAllWithStream6WithResponse request returning *FindAllWithStream6Response
func (c *ClientWithResponses) FindAllWithStream6WithResponse(ctx context.Context, params *FindAllWithStream6Params, reqEditors ...RequestEditorFn) (*FindAllWithStream6Response, error) {
	rsp, err := c.FindAllWithStream6(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream6Response(rsp)
}

// Create25WithBodyWithResponse request with arbitrary body returning *Create25Response
func (c *ClientWithResponses) Create25WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create25Response, error) {
	rsp, err := c.Create25WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate25Response(rsp)
}

func (c *ClientWithResponses) Create25WithResponse(ctx context.Context, body Create25JSONRequestBody, reqEditors ...RequestEditorFn) (*Create25Response, error) {
	rsp, err := c.Create25(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate25Response(rsp)
}

// CountREST23WithResponse request returning *CountREST23Response
func (c *ClientWithResponses) CountREST23WithResponse(ctx context.Context, params *CountREST23Params, reqEditors ...RequestEditorFn) (*CountREST23Response, error) {
	rsp, err := c.CountREST23(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST23Response(rsp)
}

// CreateBulks8WithBodyWithResponse request with arbitrary body returning *CreateBulks8Response
func (c *ClientWithResponses) CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8WithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

func (c *ClientWithResponses) CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

// CreateBulkFromTLEWithBodyWithResponse request with arbitrary body returning *CreateBulkFromTLEResponse
func (c *ClientWithResponses) CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error) {
	rsp, err := c.CreateBulkFromTLEWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulkFromTLEResponse(rsp)
}

// CurrentWithResponse request returning *CurrentResponse
func (c *ClientWithResponses) CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error) {
	rsp, err := c.Current(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentResponse(rsp)
}

// CurrentTupleWithResponse request returning *CurrentTupleResponse
func (c *ClientWithResponses) CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error) {
	rsp, err := c.CurrentTuple(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentTupleResponse(rsp)
}

// FindAllHistory12WithResponse request returning *FindAllHistory12Response
func (c *ClientWithResponses) FindAllHistory12WithResponse(ctx context.Context, params *FindAllHistory12Params, reqEditors ...RequestEditorFn) (*FindAllHistory12Response, error) {
	rsp, err := c.FindAllHistory12(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory12Response(rsp)
}

// FindAllHistoryAodr12WithResponse request returning *FindAllHistoryAodr12Response
func (c *ClientWithResponses) FindAllHistoryAodr12WithResponse(ctx context.Context, params *FindAllHistoryAodr12Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr12Response, error) {
	rsp, err := c.FindAllHistoryAodr12(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr12Response(rsp)
}

// CountHistory12WithResponse request returning *CountHistory12Response
func (c *ClientWithResponses) CountHistory12WithResponse(ctx context.Context, params *CountHistory12Params, reqEditors ...RequestEditorFn) (*CountHistory12Response, error) {
	rsp, err := c.CountHistory12(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory12Response(rsp)
}

// Queryhelp26WithResponse request returning *Queryhelp26Response
func (c *ClientWithResponses) Queryhelp26WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp26Response, error) {
	rsp, err := c.Queryhelp26(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp26Response(rsp)
}

// FindAllTuples25WithResponse request returning *FindAllTuples25Response
func (c *ClientWithResponses) FindAllTuples25WithResponse(ctx context.Context, params *FindAllTuples25Params, reqEditors ...RequestEditorFn) (*FindAllTuples25Response, error) {
	rsp, err := c.FindAllTuples25(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples25Response(rsp)
}

// Find24WithResponse request returning *Find24Response
func (c *ClientWithResponses) Find24WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find24Response, error) {
	rsp, err := c.Find24(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind24Response(rsp)
}

// FindAllWithStream7WithResponse request returning *FindAllWithStream7Response
func (c *ClientWithResponses) FindAllWithStream7WithResponse(ctx context.Context, params *FindAllWithStream7Params, reqEditors ...RequestEditorFn) (*FindAllWithStream7Response, error) {
	rsp, err := c.FindAllWithStream7(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream7Response(rsp)
}

// CountDuplicate3WithResponse request returning *CountDuplicate3Response
func (c *ClientWithResponses) CountDuplicate3WithResponse(ctx context.Context, params *CountDuplicate3Params, reqEditors ...RequestEditorFn) (*CountDuplicate3Response, error) {
	rsp, err := c.CountDuplicate3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate3Response(rsp)
}

// FindAllHistory13WithResponse request returning *FindAllHistory13Response
func (c *ClientWithResponses) FindAllHistory13WithResponse(ctx context.Context, params *FindAllHistory13Params, reqEditors ...RequestEditorFn) (*FindAllHistory13Response, error) {
	rsp, err := c.FindAllHistory13(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory13Response(rsp)
}

// FindAllHistoryAodr13WithResponse request returning *FindAllHistoryAodr13Response
func (c *ClientWithResponses) FindAllHistoryAodr13WithResponse(ctx context.Context, params *FindAllHistoryAodr13Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr13Response, error) {
	rsp, err := c.FindAllHistoryAodr13(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr13Response(rsp)
}

// CountHistory13WithResponse request returning *CountHistory13Response
func (c *ClientWithResponses) CountHistory13WithResponse(ctx context.Context, params *CountHistory13Params, reqEditors ...RequestEditorFn) (*CountHistory13Response, error) {
	rsp, err := c.CountHistory13(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory13Response(rsp)
}

// Queryhelp29WithResponse request returning *Queryhelp29Response
func (c *ClientWithResponses) Queryhelp29WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp29Response, error) {
	rsp, err := c.Queryhelp29(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp29Response(rsp)
}

// FindAllTuples28WithResponse request returning *FindAllTuples28Response
func (c *ClientWithResponses) FindAllTuples28WithResponse(ctx context.Context, params *FindAllTuples28Params, reqEditors ...RequestEditorFn) (*FindAllTuples28Response, error) {
	rsp, err := c.FindAllTuples28(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples28Response(rsp)
}

// FindAllWithStream8WithResponse request returning *FindAllWithStream8Response
func (c *ClientWithResponses) FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error) {
	rsp, err := c.FindAllWithStream8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream8Response(rsp)
}

// Create29WithBodyWithResponse request with arbitrary body returning *Create29Response
func (c *ClientWithResponses) Create29WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create29Response, error) {
	rsp, err := c.Create29WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate29Response(rsp)
}

func (c *ClientWithResponses) Create29WithResponse(ctx context.Context, body Create29JSONRequestBody, reqEditors ...RequestEditorFn) (*Create29Response, error) {
	rsp, err := c.Create29(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate29Response(rsp)
}

// CountREST26WithResponse request returning *CountREST26Response
func (c *ClientWithResponses) CountREST26WithResponse(ctx context.Context, params *CountREST26Params, reqEditors ...RequestEditorFn) (*CountREST26Response, error) {
	rsp, err := c.CountREST26(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST26Response(rsp)
}

// GetFile1WithResponse request returning *GetFile1Response
func (c *ClientWithResponses) GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error) {
	rsp, err := c.GetFile1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFile1Response(rsp)
}

// FindAllHistory14WithResponse request returning *FindAllHistory14Response
func (c *ClientWithResponses) FindAllHistory14WithResponse(ctx context.Context, params *FindAllHistory14Params, reqEditors ...RequestEditorFn) (*FindAllHistory14Response, error) {
	rsp, err := c.FindAllHistory14(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory14Response(rsp)
}

// FindAllHistoryAodr14WithResponse request returning *FindAllHistoryAodr14Response
func (c *ClientWithResponses) FindAllHistoryAodr14WithResponse(ctx context.Context, params *FindAllHistoryAodr14Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr14Response, error) {
	rsp, err := c.FindAllHistoryAodr14(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr14Response(rsp)
}

// CountHistory14WithResponse request returning *CountHistory14Response
func (c *ClientWithResponses) CountHistory14WithResponse(ctx context.Context, params *CountHistory14Params, reqEditors ...RequestEditorFn) (*CountHistory14Response, error) {
	rsp, err := c.CountHistory14(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory14Response(rsp)
}

// Queryhelp30WithResponse request returning *Queryhelp30Response
func (c *ClientWithResponses) Queryhelp30WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp30Response, error) {
	rsp, err := c.Queryhelp30(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp30Response(rsp)
}

// FindAllTuples29WithResponse request returning *FindAllTuples29Response
func (c *ClientWithResponses) FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error) {
	rsp, err := c.FindAllTuples29(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples29Response(rsp)
}

// Find28WithResponse request returning *Find28Response
func (c *ClientWithResponses) Find28WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find28Response, error) {
	rsp, err := c.Find28(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind28Response(rsp)
}

// ParseFiledropEphemPostIdResponse parses an HTTP response from a FiledropEphemPostIdWithResponse call
func ParseFiledropEphemPostIdResponse(rsp *http.Response) (*FiledropEphemPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropEphemPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlElsetPostIdResponse parses an HTTP response from a FiledropUdlElsetPostIdWithResponse call
func ParseFiledropUdlElsetPostIdResponse(rsp *http.Response) (*FiledropUdlElsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlElsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlEphsetPostIdResponse parses an HTTP response from a FiledropUdlEphsetPostIdWithResponse call
func ParseFiledropUdlEphsetPostIdResponse(rsp *http.Response) (*FiledropUdlEphsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlEphsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllWithStream6Response parses an HTTP response from a FindAllWithStream6WithResponse call
func ParseFindAllWithStream6Response(rsp *http.Response) (*FindAllWithStream6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate25Response parses an HTTP response from a Create25WithResponse call
func ParseCreate25Response(rsp *http.Response) (*Create25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST23Response parses an HTTP response from a CountREST23WithResponse call
func ParseCountREST23Response(rsp *http.Response) (*CountREST23Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST23Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks8Response parses an HTTP response from a CreateBulks8WithResponse call
func ParseCreateBulks8Response(rsp *http.Response) (*CreateBulks8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulkFromTLEResponse parses an HTTP response from a CreateBulkFromTLEWithResponse call
func ParseCreateBulkFromTLEResponse(rsp *http.Response) (*CreateBulkFromTLEResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulkFromTLEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentResponse parses an HTTP response from a CurrentWithResponse call
func ParseCurrentResponse(rsp *http.Response) (*CurrentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCurrentTupleResponse parses an HTTP response from a CurrentTupleWithResponse call
func ParseCurrentTupleResponse(rsp *http.Response) (*CurrentTupleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentTupleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistory12Response parses an HTTP response from a FindAllHistory12WithResponse call
func ParseFindAllHistory12Response(rsp *http.Response) (*FindAllHistory12Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory12Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr12Response parses an HTTP response from a FindAllHistoryAodr12WithResponse call
func ParseFindAllHistoryAodr12Response(rsp *http.Response) (*FindAllHistoryAodr12Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr12Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory12Response parses an HTTP response from a CountHistory12WithResponse call
func ParseCountHistory12Response(rsp *http.Response) (*CountHistory12Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory12Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp26Response parses an HTTP response from a Queryhelp26WithResponse call
func ParseQueryhelp26Response(rsp *http.Response) (*Queryhelp26Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp26Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples25Response parses an HTTP response from a FindAllTuples25WithResponse call
func ParseFindAllTuples25Response(rsp *http.Response) (*FindAllTuples25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind24Response parses an HTTP response from a Find24WithResponse call
func ParseFind24Response(rsp *http.Response) (*Find24Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find24Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream7Response parses an HTTP response from a FindAllWithStream7WithResponse call
func ParseFindAllWithStream7Response(rsp *http.Response) (*FindAllWithStream7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate3Response parses an HTTP response from a CountDuplicate3WithResponse call
func ParseCountDuplicate3Response(rsp *http.Response) (*CountDuplicate3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory13Response parses an HTTP response from a FindAllHistory13WithResponse call
func ParseFindAllHistory13Response(rsp *http.Response) (*FindAllHistory13Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory13Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr13Response parses an HTTP response from a FindAllHistoryAodr13WithResponse call
func ParseFindAllHistoryAodr13Response(rsp *http.Response) (*FindAllHistoryAodr13Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr13Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory13Response parses an HTTP response from a CountHistory13WithResponse call
func ParseCountHistory13Response(rsp *http.Response) (*CountHistory13Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory13Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp29Response parses an HTTP response from a Queryhelp29WithResponse call
func ParseQueryhelp29Response(rsp *http.Response) (*Queryhelp29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples28Response parses an HTTP response from a FindAllTuples28WithResponse call
func ParseFindAllTuples28Response(rsp *http.Response) (*FindAllTuples28Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples28Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream8Response parses an HTTP response from a FindAllWithStream8WithResponse call
func ParseFindAllWithStream8Response(rsp *http.Response) (*FindAllWithStream8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate29Response parses an HTTP response from a Create29WithResponse call
func ParseCreate29Response(rsp *http.Response) (*Create29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST26Response parses an HTTP response from a CountREST26WithResponse call
func ParseCountREST26Response(rsp *http.Response) (*CountREST26Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST26Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFile1Response parses an HTTP response from a GetFile1WithResponse call
func ParseGetFile1Response(rsp *http.Response) (*GetFile1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFile1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory14Response parses an HTTP response from a FindAllHistory14WithResponse call
func ParseFindAllHistory14Response(rsp *http.Response) (*FindAllHistory14Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory14Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr14Response parses an HTTP response from a FindAllHistoryAodr14WithResponse call
func ParseFindAllHistoryAodr14Response(rsp *http.Response) (*FindAllHistoryAodr14Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr14Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory14Response parses an HTTP response from a CountHistory14WithResponse call
func ParseCountHistory14Response(rsp *http.Response) (*CountHistory14Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory14Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp30Response parses an HTTP response from a Queryhelp30WithResponse call
func ParseQueryhelp30Response(rsp *http.Response) (*Queryhelp30Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp30Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples29Response parses an HTTP response from a FindAllTuples29WithResponse call
func ParseFindAllTuples29Response(rsp *http.Response) (*FindAllTuples29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind28Response parses an HTTP response from a Find28WithResponse call
func ParseFind28Response(rsp *http.Response) (*Find28Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find28Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
