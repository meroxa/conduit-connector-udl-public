// Package udl provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package udl

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for AISAbridgedDataMode.
const (
	AISAbridgedDataModeEXERCISE  AISAbridgedDataMode = "EXERCISE"
	AISAbridgedDataModeREAL      AISAbridgedDataMode = "REAL"
	AISAbridgedDataModeSIMULATED AISAbridgedDataMode = "SIMULATED"
	AISAbridgedDataModeTEST      AISAbridgedDataMode = "TEST"
)

// Defines values for AISFullDataMode.
const (
	AISFullDataModeEXERCISE  AISFullDataMode = "EXERCISE"
	AISFullDataModeREAL      AISFullDataMode = "REAL"
	AISFullDataModeSIMULATED AISFullDataMode = "SIMULATED"
	AISFullDataModeTEST      AISFullDataMode = "TEST"
)

// Defines values for AISIngestDataMode.
const (
	AISIngestDataModeEXERCISE  AISIngestDataMode = "EXERCISE"
	AISIngestDataModeREAL      AISIngestDataMode = "REAL"
	AISIngestDataModeSIMULATED AISIngestDataMode = "SIMULATED"
	AISIngestDataModeTEST      AISIngestDataMode = "TEST"
)

// Defines values for AircraftSortieAbridgedDataMode.
const (
	AircraftSortieAbridgedDataModeEXERCISE  AircraftSortieAbridgedDataMode = "EXERCISE"
	AircraftSortieAbridgedDataModeREAL      AircraftSortieAbridgedDataMode = "REAL"
	AircraftSortieAbridgedDataModeSIMULATED AircraftSortieAbridgedDataMode = "SIMULATED"
	AircraftSortieAbridgedDataModeTEST      AircraftSortieAbridgedDataMode = "TEST"
)

// Defines values for AircraftSortieFullDataMode.
const (
	AircraftSortieFullDataModeEXERCISE  AircraftSortieFullDataMode = "EXERCISE"
	AircraftSortieFullDataModeREAL      AircraftSortieFullDataMode = "REAL"
	AircraftSortieFullDataModeSIMULATED AircraftSortieFullDataMode = "SIMULATED"
	AircraftSortieFullDataModeTEST      AircraftSortieFullDataMode = "TEST"
)

// Defines values for AircraftSortieIngestDataMode.
const (
	AircraftSortieIngestDataModeEXERCISE  AircraftSortieIngestDataMode = "EXERCISE"
	AircraftSortieIngestDataModeREAL      AircraftSortieIngestDataMode = "REAL"
	AircraftSortieIngestDataModeSIMULATED AircraftSortieIngestDataMode = "SIMULATED"
	AircraftSortieIngestDataModeTEST      AircraftSortieIngestDataMode = "TEST"
)

// Defines values for AircraftStatusAbridgedAirToAirStatus.
const (
	AircraftStatusAbridgedAirToAirStatusNONOPERATIONAL AircraftStatusAbridgedAirToAirStatus = "NON-OPERATIONAL"
	AircraftStatusAbridgedAirToAirStatusOFF            AircraftStatusAbridgedAirToAirStatus = "OFF"
	AircraftStatusAbridgedAirToAirStatusOPERATIONAL    AircraftStatusAbridgedAirToAirStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusAbridgedAirToGroundStatus.
const (
	AircraftStatusAbridgedAirToGroundStatusNONOPERATIONAL AircraftStatusAbridgedAirToGroundStatus = "NON-OPERATIONAL"
	AircraftStatusAbridgedAirToGroundStatusOFF            AircraftStatusAbridgedAirToGroundStatus = "OFF"
	AircraftStatusAbridgedAirToGroundStatusOPERATIONAL    AircraftStatusAbridgedAirToGroundStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusAbridgedCurrentState.
const (
	AircraftStatusAbridgedCurrentStateAIRBORNE      AircraftStatusAbridgedCurrentState = "AIRBORNE"
	AircraftStatusAbridgedCurrentStateAVAILABLE     AircraftStatusAbridgedCurrentState = "AVAILABLE"
	AircraftStatusAbridgedCurrentStateBATTLESTATION AircraftStatusAbridgedCurrentState = "BATTLESTATION"
	AircraftStatusAbridgedCurrentStateRUNWAYALERT   AircraftStatusAbridgedCurrentState = "RUNWAYALERT"
	AircraftStatusAbridgedCurrentStateSUITUP        AircraftStatusAbridgedCurrentState = "SUITUP"
)

// Defines values for AircraftStatusAbridgedDataMode.
const (
	AircraftStatusAbridgedDataModeEXERCISE  AircraftStatusAbridgedDataMode = "EXERCISE"
	AircraftStatusAbridgedDataModeREAL      AircraftStatusAbridgedDataMode = "REAL"
	AircraftStatusAbridgedDataModeSIMULATED AircraftStatusAbridgedDataMode = "SIMULATED"
	AircraftStatusAbridgedDataModeTEST      AircraftStatusAbridgedDataMode = "TEST"
)

// Defines values for AircraftStatusAbridgedMissionReadiness.
const (
	AircraftStatusAbridgedMissionReadinessABLE   AircraftStatusAbridgedMissionReadiness = "ABLE"
	AircraftStatusAbridgedMissionReadinessLOFUEL AircraftStatusAbridgedMissionReadiness = "LOFUEL"
	AircraftStatusAbridgedMissionReadinessUNABLE AircraftStatusAbridgedMissionReadiness = "UNABLE"
)

// Defines values for AircraftStatusFullAirToAirStatus.
const (
	AircraftStatusFullAirToAirStatusNONOPERATIONAL AircraftStatusFullAirToAirStatus = "NON-OPERATIONAL"
	AircraftStatusFullAirToAirStatusOFF            AircraftStatusFullAirToAirStatus = "OFF"
	AircraftStatusFullAirToAirStatusOPERATIONAL    AircraftStatusFullAirToAirStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusFullAirToGroundStatus.
const (
	AircraftStatusFullAirToGroundStatusNONOPERATIONAL AircraftStatusFullAirToGroundStatus = "NON-OPERATIONAL"
	AircraftStatusFullAirToGroundStatusOFF            AircraftStatusFullAirToGroundStatus = "OFF"
	AircraftStatusFullAirToGroundStatusOPERATIONAL    AircraftStatusFullAirToGroundStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusFullCurrentState.
const (
	AircraftStatusFullCurrentStateAIRBORNE      AircraftStatusFullCurrentState = "AIRBORNE"
	AircraftStatusFullCurrentStateAVAILABLE     AircraftStatusFullCurrentState = "AVAILABLE"
	AircraftStatusFullCurrentStateBATTLESTATION AircraftStatusFullCurrentState = "BATTLESTATION"
	AircraftStatusFullCurrentStateRUNWAYALERT   AircraftStatusFullCurrentState = "RUNWAYALERT"
	AircraftStatusFullCurrentStateSUITUP        AircraftStatusFullCurrentState = "SUITUP"
)

// Defines values for AircraftStatusFullDataMode.
const (
	AircraftStatusFullDataModeEXERCISE  AircraftStatusFullDataMode = "EXERCISE"
	AircraftStatusFullDataModeREAL      AircraftStatusFullDataMode = "REAL"
	AircraftStatusFullDataModeSIMULATED AircraftStatusFullDataMode = "SIMULATED"
	AircraftStatusFullDataModeTEST      AircraftStatusFullDataMode = "TEST"
)

// Defines values for AircraftStatusFullMissionReadiness.
const (
	AircraftStatusFullMissionReadinessABLE   AircraftStatusFullMissionReadiness = "ABLE"
	AircraftStatusFullMissionReadinessLOFUEL AircraftStatusFullMissionReadiness = "LOFUEL"
	AircraftStatusFullMissionReadinessUNABLE AircraftStatusFullMissionReadiness = "UNABLE"
)

// Defines values for AircraftStatusIngestAirToAirStatus.
const (
	AircraftStatusIngestAirToAirStatusNONOPERATIONAL AircraftStatusIngestAirToAirStatus = "NON-OPERATIONAL"
	AircraftStatusIngestAirToAirStatusOFF            AircraftStatusIngestAirToAirStatus = "OFF"
	AircraftStatusIngestAirToAirStatusOPERATIONAL    AircraftStatusIngestAirToAirStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusIngestAirToGroundStatus.
const (
	AircraftStatusIngestAirToGroundStatusNONOPERATIONAL AircraftStatusIngestAirToGroundStatus = "NON-OPERATIONAL"
	AircraftStatusIngestAirToGroundStatusOFF            AircraftStatusIngestAirToGroundStatus = "OFF"
	AircraftStatusIngestAirToGroundStatusOPERATIONAL    AircraftStatusIngestAirToGroundStatus = "OPERATIONAL"
)

// Defines values for AircraftStatusIngestCurrentState.
const (
	AIRBORNE      AircraftStatusIngestCurrentState = "AIRBORNE"
	AVAILABLE     AircraftStatusIngestCurrentState = "AVAILABLE"
	BATTLESTATION AircraftStatusIngestCurrentState = "BATTLESTATION"
	RUNWAYALERT   AircraftStatusIngestCurrentState = "RUNWAYALERT"
	SUITUP        AircraftStatusIngestCurrentState = "SUITUP"
)

// Defines values for AircraftStatusIngestDataMode.
const (
	AircraftStatusIngestDataModeEXERCISE  AircraftStatusIngestDataMode = "EXERCISE"
	AircraftStatusIngestDataModeREAL      AircraftStatusIngestDataMode = "REAL"
	AircraftStatusIngestDataModeSIMULATED AircraftStatusIngestDataMode = "SIMULATED"
	AircraftStatusIngestDataModeTEST      AircraftStatusIngestDataMode = "TEST"
)

// Defines values for AircraftStatusIngestMissionReadiness.
const (
	ABLE   AircraftStatusIngestMissionReadiness = "ABLE"
	LOFUEL AircraftStatusIngestMissionReadiness = "LOFUEL"
	UNABLE AircraftStatusIngestMissionReadiness = "UNABLE"
)

// Defines values for AircraftAbridgedDataMode.
const (
	AircraftAbridgedDataModeEXERCISE  AircraftAbridgedDataMode = "EXERCISE"
	AircraftAbridgedDataModeREAL      AircraftAbridgedDataMode = "REAL"
	AircraftAbridgedDataModeSIMULATED AircraftAbridgedDataMode = "SIMULATED"
	AircraftAbridgedDataModeTEST      AircraftAbridgedDataMode = "TEST"
)

// Defines values for AircraftFullDataMode.
const (
	AircraftFullDataModeEXERCISE  AircraftFullDataMode = "EXERCISE"
	AircraftFullDataModeREAL      AircraftFullDataMode = "REAL"
	AircraftFullDataModeSIMULATED AircraftFullDataMode = "SIMULATED"
	AircraftFullDataModeTEST      AircraftFullDataMode = "TEST"
)

// Defines values for AircraftIngestDataMode.
const (
	AircraftIngestDataModeEXERCISE  AircraftIngestDataMode = "EXERCISE"
	AircraftIngestDataModeREAL      AircraftIngestDataMode = "REAL"
	AircraftIngestDataModeSIMULATED AircraftIngestDataMode = "SIMULATED"
	AircraftIngestDataModeTEST      AircraftIngestDataMode = "TEST"
)

// Defines values for AnalyticImageryAbridgedDataMode.
const (
	AnalyticImageryAbridgedDataModeEXERCISE  AnalyticImageryAbridgedDataMode = "EXERCISE"
	AnalyticImageryAbridgedDataModeREAL      AnalyticImageryAbridgedDataMode = "REAL"
	AnalyticImageryAbridgedDataModeSIMULATED AnalyticImageryAbridgedDataMode = "SIMULATED"
	AnalyticImageryAbridgedDataModeTEST      AnalyticImageryAbridgedDataMode = "TEST"
)

// Defines values for AnalyticImageryFullDataMode.
const (
	AnalyticImageryFullDataModeEXERCISE  AnalyticImageryFullDataMode = "EXERCISE"
	AnalyticImageryFullDataModeREAL      AnalyticImageryFullDataMode = "REAL"
	AnalyticImageryFullDataModeSIMULATED AnalyticImageryFullDataMode = "SIMULATED"
	AnalyticImageryFullDataModeTEST      AnalyticImageryFullDataMode = "TEST"
)

// Defines values for AntennaDetailsFullDataMode.
const (
	AntennaDetailsFullDataModeEXERCISE  AntennaDetailsFullDataMode = "EXERCISE"
	AntennaDetailsFullDataModeREAL      AntennaDetailsFullDataMode = "REAL"
	AntennaDetailsFullDataModeSIMULATED AntennaDetailsFullDataMode = "SIMULATED"
	AntennaDetailsFullDataModeTEST      AntennaDetailsFullDataMode = "TEST"
)

// Defines values for AntennaDetailsFullMode.
const (
	AntennaDetailsFullModeRX AntennaDetailsFullMode = "RX"
	AntennaDetailsFullModeTX AntennaDetailsFullMode = "TX"
)

// Defines values for AntennaFullDataMode.
const (
	AntennaFullDataModeEXERCISE  AntennaFullDataMode = "EXERCISE"
	AntennaFullDataModeREAL      AntennaFullDataMode = "REAL"
	AntennaFullDataModeSIMULATED AntennaFullDataMode = "SIMULATED"
	AntennaFullDataModeTEST      AntennaFullDataMode = "TEST"
)

// Defines values for AttitudeDataAbridgedDataMode.
const (
	AttitudeDataAbridgedDataModeEXERCISE  AttitudeDataAbridgedDataMode = "EXERCISE"
	AttitudeDataAbridgedDataModeREAL      AttitudeDataAbridgedDataMode = "REAL"
	AttitudeDataAbridgedDataModeSIMULATED AttitudeDataAbridgedDataMode = "SIMULATED"
	AttitudeDataAbridgedDataModeTEST      AttitudeDataAbridgedDataMode = "TEST"
)

// Defines values for AttitudeDataFullDataMode.
const (
	AttitudeDataFullDataModeEXERCISE  AttitudeDataFullDataMode = "EXERCISE"
	AttitudeDataFullDataModeREAL      AttitudeDataFullDataMode = "REAL"
	AttitudeDataFullDataModeSIMULATED AttitudeDataFullDataMode = "SIMULATED"
	AttitudeDataFullDataModeTEST      AttitudeDataFullDataMode = "TEST"
)

// Defines values for AttitudeDataIngestDataMode.
const (
	AttitudeDataIngestDataModeEXERCISE  AttitudeDataIngestDataMode = "EXERCISE"
	AttitudeDataIngestDataModeREAL      AttitudeDataIngestDataMode = "REAL"
	AttitudeDataIngestDataModeSIMULATED AttitudeDataIngestDataMode = "SIMULATED"
	AttitudeDataIngestDataModeTEST      AttitudeDataIngestDataMode = "TEST"
)

// Defines values for AttitudeSetAbridgedDataMode.
const (
	AttitudeSetAbridgedDataModeEXERCISE  AttitudeSetAbridgedDataMode = "EXERCISE"
	AttitudeSetAbridgedDataModeREAL      AttitudeSetAbridgedDataMode = "REAL"
	AttitudeSetAbridgedDataModeSIMULATED AttitudeSetAbridgedDataMode = "SIMULATED"
	AttitudeSetAbridgedDataModeTEST      AttitudeSetAbridgedDataMode = "TEST"
)

// Defines values for AttitudeSetFullDataMode.
const (
	AttitudeSetFullDataModeEXERCISE  AttitudeSetFullDataMode = "EXERCISE"
	AttitudeSetFullDataModeREAL      AttitudeSetFullDataMode = "REAL"
	AttitudeSetFullDataModeSIMULATED AttitudeSetFullDataMode = "SIMULATED"
	AttitudeSetFullDataModeTEST      AttitudeSetFullDataMode = "TEST"
)

// Defines values for AttitudeSetIngestDataMode.
const (
	AttitudeSetIngestDataModeEXERCISE  AttitudeSetIngestDataMode = "EXERCISE"
	AttitudeSetIngestDataModeREAL      AttitudeSetIngestDataMode = "REAL"
	AttitudeSetIngestDataModeSIMULATED AttitudeSetIngestDataMode = "SIMULATED"
	AttitudeSetIngestDataModeTEST      AttitudeSetIngestDataMode = "TEST"
)

// Defines values for BatteryDetailsFullDataMode.
const (
	BatteryDetailsFullDataModeEXERCISE  BatteryDetailsFullDataMode = "EXERCISE"
	BatteryDetailsFullDataModeREAL      BatteryDetailsFullDataMode = "REAL"
	BatteryDetailsFullDataModeSIMULATED BatteryDetailsFullDataMode = "SIMULATED"
	BatteryDetailsFullDataModeTEST      BatteryDetailsFullDataMode = "TEST"
)

// Defines values for BatteryFullDataMode.
const (
	BatteryFullDataModeEXERCISE  BatteryFullDataMode = "EXERCISE"
	BatteryFullDataModeREAL      BatteryFullDataMode = "REAL"
	BatteryFullDataModeSIMULATED BatteryFullDataMode = "SIMULATED"
	BatteryFullDataModeTEST      BatteryFullDataMode = "TEST"
)

// Defines values for DataMode.
const (
	DataModeEXERCISE  DataMode = "EXERCISE"
	DataModeREAL      DataMode = "REAL"
	DataModeSIMULATED DataMode = "SIMULATED"
	DataModeTEST      DataMode = "TEST"
)

// Defines values for ElsetAbridgedDataMode.
const (
	ElsetAbridgedDataModeEXERCISE  ElsetAbridgedDataMode = "EXERCISE"
	ElsetAbridgedDataModeREAL      ElsetAbridgedDataMode = "REAL"
	ElsetAbridgedDataModeSIMULATED ElsetAbridgedDataMode = "SIMULATED"
	ElsetAbridgedDataModeTEST      ElsetAbridgedDataMode = "TEST"
)

// Defines values for ElsetFullDataMode.
const (
	ElsetFullDataModeEXERCISE  ElsetFullDataMode = "EXERCISE"
	ElsetFullDataModeREAL      ElsetFullDataMode = "REAL"
	ElsetFullDataModeSIMULATED ElsetFullDataMode = "SIMULATED"
	ElsetFullDataModeTEST      ElsetFullDataMode = "TEST"
)

// Defines values for ElsetFullSourcedDataTypes.
const (
	ElsetFullSourcedDataTypesDOA   ElsetFullSourcedDataTypes = "DOA"
	ElsetFullSourcedDataTypesELSET ElsetFullSourcedDataTypes = "ELSET"
	ElsetFullSourcedDataTypesEO    ElsetFullSourcedDataTypes = "EO"
	ElsetFullSourcedDataTypesRADAR ElsetFullSourcedDataTypes = "RADAR"
	ElsetFullSourcedDataTypesRF    ElsetFullSourcedDataTypes = "RF"
	ElsetFullSourcedDataTypesSV    ElsetFullSourcedDataTypes = "SV"
)

// Defines values for ElsetIngestDataMode.
const (
	ElsetIngestDataModeEXERCISE  ElsetIngestDataMode = "EXERCISE"
	ElsetIngestDataModeREAL      ElsetIngestDataMode = "REAL"
	ElsetIngestDataModeSIMULATED ElsetIngestDataMode = "SIMULATED"
	ElsetIngestDataModeTEST      ElsetIngestDataMode = "TEST"
)

// Defines values for ElsetIngestSourcedDataTypes.
const (
	ElsetIngestSourcedDataTypesDOA   ElsetIngestSourcedDataTypes = "DOA"
	ElsetIngestSourcedDataTypesELSET ElsetIngestSourcedDataTypes = "ELSET"
	ElsetIngestSourcedDataTypesEO    ElsetIngestSourcedDataTypes = "EO"
	ElsetIngestSourcedDataTypesRADAR ElsetIngestSourcedDataTypes = "RADAR"
	ElsetIngestSourcedDataTypesRF    ElsetIngestSourcedDataTypes = "RF"
	ElsetIngestSourcedDataTypesSV    ElsetIngestSourcedDataTypes = "SV"
)

// Defines values for EngineDetailsFullDataMode.
const (
	EngineDetailsFullDataModeEXERCISE  EngineDetailsFullDataMode = "EXERCISE"
	EngineDetailsFullDataModeREAL      EngineDetailsFullDataMode = "REAL"
	EngineDetailsFullDataModeSIMULATED EngineDetailsFullDataMode = "SIMULATED"
	EngineDetailsFullDataModeTEST      EngineDetailsFullDataMode = "TEST"
)

// Defines values for EngineFullDataMode.
const (
	EngineFullDataModeEXERCISE  EngineFullDataMode = "EXERCISE"
	EngineFullDataModeREAL      EngineFullDataMode = "REAL"
	EngineFullDataModeSIMULATED EngineFullDataMode = "SIMULATED"
	EngineFullDataModeTEST      EngineFullDataMode = "TEST"
)

// Defines values for EntityAbridgedDataMode.
const (
	EntityAbridgedDataModeEXERCISE  EntityAbridgedDataMode = "EXERCISE"
	EntityAbridgedDataModeREAL      EntityAbridgedDataMode = "REAL"
	EntityAbridgedDataModeSIMULATED EntityAbridgedDataMode = "SIMULATED"
	EntityAbridgedDataModeTEST      EntityAbridgedDataMode = "TEST"
)

// Defines values for EntityAbridgedOwnerType.
const (
	EntityAbridgedOwnerTypeAcademic   EntityAbridgedOwnerType = "Academic"
	EntityAbridgedOwnerTypeCommercial EntityAbridgedOwnerType = "Commercial"
	EntityAbridgedOwnerTypeConsortium EntityAbridgedOwnerType = "Consortium"
	EntityAbridgedOwnerTypeGovernment EntityAbridgedOwnerType = "Government"
	EntityAbridgedOwnerTypeOther      EntityAbridgedOwnerType = "Other"
)

// Defines values for EntityAbridgedType.
const (
	EntityAbridgedTypeAIRCRAFT   EntityAbridgedType = "AIRCRAFT"
	EntityAbridgedTypeBUS        EntityAbridgedType = "BUS"
	EntityAbridgedTypeCOMM       EntityAbridgedType = "COMM"
	EntityAbridgedTypeIR         EntityAbridgedType = "IR"
	EntityAbridgedTypeNAVIGATION EntityAbridgedType = "NAVIGATION"
	EntityAbridgedTypeONORBIT    EntityAbridgedType = "ONORBIT"
	EntityAbridgedTypeRFEMITTER  EntityAbridgedType = "RFEMITTER"
	EntityAbridgedTypeSCIENTIFIC EntityAbridgedType = "SCIENTIFIC"
	EntityAbridgedTypeSENSOR     EntityAbridgedType = "SENSOR"
	EntityAbridgedTypeSITE       EntityAbridgedType = "SITE"
)

// Defines values for EntityFullDataMode.
const (
	EntityFullDataModeEXERCISE  EntityFullDataMode = "EXERCISE"
	EntityFullDataModeREAL      EntityFullDataMode = "REAL"
	EntityFullDataModeSIMULATED EntityFullDataMode = "SIMULATED"
	EntityFullDataModeTEST      EntityFullDataMode = "TEST"
)

// Defines values for EntityFullOwnerType.
const (
	EntityFullOwnerTypeAcademic   EntityFullOwnerType = "Academic"
	EntityFullOwnerTypeCommercial EntityFullOwnerType = "Commercial"
	EntityFullOwnerTypeConsortium EntityFullOwnerType = "Consortium"
	EntityFullOwnerTypeGovernment EntityFullOwnerType = "Government"
	EntityFullOwnerTypeOther      EntityFullOwnerType = "Other"
)

// Defines values for EntityFullType.
const (
	EntityFullTypeAIRCRAFT   EntityFullType = "AIRCRAFT"
	EntityFullTypeBUS        EntityFullType = "BUS"
	EntityFullTypeCOMM       EntityFullType = "COMM"
	EntityFullTypeIR         EntityFullType = "IR"
	EntityFullTypeNAVIGATION EntityFullType = "NAVIGATION"
	EntityFullTypeONORBIT    EntityFullType = "ONORBIT"
	EntityFullTypeRFEMITTER  EntityFullType = "RFEMITTER"
	EntityFullTypeSCIENTIFIC EntityFullType = "SCIENTIFIC"
	EntityFullTypeSENSOR     EntityFullType = "SENSOR"
	EntityFullTypeSITE       EntityFullType = "SITE"
)

// Defines values for EntityIngestDataMode.
const (
	EntityIngestDataModeEXERCISE  EntityIngestDataMode = "EXERCISE"
	EntityIngestDataModeREAL      EntityIngestDataMode = "REAL"
	EntityIngestDataModeSIMULATED EntityIngestDataMode = "SIMULATED"
	EntityIngestDataModeTEST      EntityIngestDataMode = "TEST"
)

// Defines values for EntityIngestOwnerType.
const (
	Academic   EntityIngestOwnerType = "Academic"
	Commercial EntityIngestOwnerType = "Commercial"
	Consortium EntityIngestOwnerType = "Consortium"
	Government EntityIngestOwnerType = "Government"
	Other      EntityIngestOwnerType = "Other"
)

// Defines values for EntityIngestType.
const (
	EntityIngestTypeAIRCRAFT   EntityIngestType = "AIRCRAFT"
	EntityIngestTypeBUS        EntityIngestType = "BUS"
	EntityIngestTypeCOMM       EntityIngestType = "COMM"
	EntityIngestTypeIR         EntityIngestType = "IR"
	EntityIngestTypeNAVIGATION EntityIngestType = "NAVIGATION"
	EntityIngestTypeONORBIT    EntityIngestType = "ONORBIT"
	EntityIngestTypeRFEMITTER  EntityIngestType = "RFEMITTER"
	EntityIngestTypeSCIENTIFIC EntityIngestType = "SCIENTIFIC"
	EntityIngestTypeSENSOR     EntityIngestType = "SENSOR"
	EntityIngestTypeSITE       EntityIngestType = "SITE"
)

// Defines values for EphemFormatType.
const (
	GOO    EphemFormatType = "GOO"
	ModITC EphemFormatType = "ModITC"
	NASA   EphemFormatType = "NASA"
	OASYS  EphemFormatType = "OASYS"
	OEM    EphemFormatType = "OEM"
)

// Defines values for EphemerisSetAbridgedCovReferenceFrame.
const (
	EphemerisSetAbridgedCovReferenceFrameJ2000 EphemerisSetAbridgedCovReferenceFrame = "J2000"
	EphemerisSetAbridgedCovReferenceFrameUVW   EphemerisSetAbridgedCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetAbridgedDataMode.
const (
	EphemerisSetAbridgedDataModeEXERCISE  EphemerisSetAbridgedDataMode = "EXERCISE"
	EphemerisSetAbridgedDataModeREAL      EphemerisSetAbridgedDataMode = "REAL"
	EphemerisSetAbridgedDataModeSIMULATED EphemerisSetAbridgedDataMode = "SIMULATED"
	EphemerisSetAbridgedDataModeTEST      EphemerisSetAbridgedDataMode = "TEST"
)

// Defines values for EphemerisSetAbridgedReferenceFrame.
const (
	EphemerisSetAbridgedReferenceFrameECRECEF EphemerisSetAbridgedReferenceFrame = "ECR/ECEF"
	EphemerisSetAbridgedReferenceFrameEFGTDR  EphemerisSetAbridgedReferenceFrame = "EFG/TDR"
	EphemerisSetAbridgedReferenceFrameGCRF    EphemerisSetAbridgedReferenceFrame = "GCRF"
	EphemerisSetAbridgedReferenceFrameITRF    EphemerisSetAbridgedReferenceFrame = "ITRF"
	EphemerisSetAbridgedReferenceFrameJ2000   EphemerisSetAbridgedReferenceFrame = "J2000"
	EphemerisSetAbridgedReferenceFrameTEME    EphemerisSetAbridgedReferenceFrame = "TEME"
)

// Defines values for EphemerisSetFullCovReferenceFrame.
const (
	EphemerisSetFullCovReferenceFrameJ2000 EphemerisSetFullCovReferenceFrame = "J2000"
	EphemerisSetFullCovReferenceFrameUVW   EphemerisSetFullCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetFullDataMode.
const (
	EphemerisSetFullDataModeEXERCISE  EphemerisSetFullDataMode = "EXERCISE"
	EphemerisSetFullDataModeREAL      EphemerisSetFullDataMode = "REAL"
	EphemerisSetFullDataModeSIMULATED EphemerisSetFullDataMode = "SIMULATED"
	EphemerisSetFullDataModeTEST      EphemerisSetFullDataMode = "TEST"
)

// Defines values for EphemerisSetFullReferenceFrame.
const (
	EphemerisSetFullReferenceFrameECRECEF EphemerisSetFullReferenceFrame = "ECR/ECEF"
	EphemerisSetFullReferenceFrameEFGTDR  EphemerisSetFullReferenceFrame = "EFG/TDR"
	EphemerisSetFullReferenceFrameGCRF    EphemerisSetFullReferenceFrame = "GCRF"
	EphemerisSetFullReferenceFrameITRF    EphemerisSetFullReferenceFrame = "ITRF"
	EphemerisSetFullReferenceFrameJ2000   EphemerisSetFullReferenceFrame = "J2000"
	EphemerisSetFullReferenceFrameTEME    EphemerisSetFullReferenceFrame = "TEME"
)

// Defines values for EphemerisSetIngestCovReferenceFrame.
const (
	EphemerisSetIngestCovReferenceFrameJ2000 EphemerisSetIngestCovReferenceFrame = "J2000"
	EphemerisSetIngestCovReferenceFrameUVW   EphemerisSetIngestCovReferenceFrame = "UVW"
)

// Defines values for EphemerisSetIngestDataMode.
const (
	EphemerisSetIngestDataModeEXERCISE  EphemerisSetIngestDataMode = "EXERCISE"
	EphemerisSetIngestDataModeREAL      EphemerisSetIngestDataMode = "REAL"
	EphemerisSetIngestDataModeSIMULATED EphemerisSetIngestDataMode = "SIMULATED"
	EphemerisSetIngestDataModeTEST      EphemerisSetIngestDataMode = "TEST"
)

// Defines values for EphemerisSetIngestReferenceFrame.
const (
	EphemerisSetIngestReferenceFrameECRECEF EphemerisSetIngestReferenceFrame = "ECR/ECEF"
	EphemerisSetIngestReferenceFrameEFGTDR  EphemerisSetIngestReferenceFrame = "EFG/TDR"
	EphemerisSetIngestReferenceFrameGCRF    EphemerisSetIngestReferenceFrame = "GCRF"
	EphemerisSetIngestReferenceFrameITRF    EphemerisSetIngestReferenceFrame = "ITRF"
	EphemerisSetIngestReferenceFrameJ2000   EphemerisSetIngestReferenceFrame = "J2000"
	EphemerisSetIngestReferenceFrameTEME    EphemerisSetIngestReferenceFrame = "TEME"
)

// Defines values for EphemerisAbridgedDataMode.
const (
	EphemerisAbridgedDataModeEXERCISE  EphemerisAbridgedDataMode = "EXERCISE"
	EphemerisAbridgedDataModeREAL      EphemerisAbridgedDataMode = "REAL"
	EphemerisAbridgedDataModeSIMULATED EphemerisAbridgedDataMode = "SIMULATED"
	EphemerisAbridgedDataModeTEST      EphemerisAbridgedDataMode = "TEST"
)

// Defines values for EphemerisFullDataMode.
const (
	EphemerisFullDataModeEXERCISE  EphemerisFullDataMode = "EXERCISE"
	EphemerisFullDataModeREAL      EphemerisFullDataMode = "REAL"
	EphemerisFullDataModeSIMULATED EphemerisFullDataMode = "SIMULATED"
	EphemerisFullDataModeTEST      EphemerisFullDataMode = "TEST"
)

// Defines values for EphemerisIngestDataMode.
const (
	EphemerisIngestDataModeEXERCISE  EphemerisIngestDataMode = "EXERCISE"
	EphemerisIngestDataModeREAL      EphemerisIngestDataMode = "REAL"
	EphemerisIngestDataModeSIMULATED EphemerisIngestDataMode = "SIMULATED"
	EphemerisIngestDataModeTEST      EphemerisIngestDataMode = "TEST"
)

// Defines values for EventEvolutionAbridgedDataMode.
const (
	EventEvolutionAbridgedDataModeEXERCISE  EventEvolutionAbridgedDataMode = "EXERCISE"
	EventEvolutionAbridgedDataModeREAL      EventEvolutionAbridgedDataMode = "REAL"
	EventEvolutionAbridgedDataModeSIMULATED EventEvolutionAbridgedDataMode = "SIMULATED"
	EventEvolutionAbridgedDataModeTEST      EventEvolutionAbridgedDataMode = "TEST"
)

// Defines values for EventEvolutionFullDataMode.
const (
	EventEvolutionFullDataModeEXERCISE  EventEvolutionFullDataMode = "EXERCISE"
	EventEvolutionFullDataModeREAL      EventEvolutionFullDataMode = "REAL"
	EventEvolutionFullDataModeSIMULATED EventEvolutionFullDataMode = "SIMULATED"
	EventEvolutionFullDataModeTEST      EventEvolutionFullDataMode = "TEST"
)

// Defines values for EventEvolutionIngestDataMode.
const (
	EventEvolutionIngestDataModeEXERCISE  EventEvolutionIngestDataMode = "EXERCISE"
	EventEvolutionIngestDataModeREAL      EventEvolutionIngestDataMode = "REAL"
	EventEvolutionIngestDataModeSIMULATED EventEvolutionIngestDataMode = "SIMULATED"
	EventEvolutionIngestDataModeTEST      EventEvolutionIngestDataMode = "TEST"
)

// Defines values for HazardAbridgedDataMode.
const (
	HazardAbridgedDataModeEXERCISE  HazardAbridgedDataMode = "EXERCISE"
	HazardAbridgedDataModeREAL      HazardAbridgedDataMode = "REAL"
	HazardAbridgedDataModeSIMULATED HazardAbridgedDataMode = "SIMULATED"
	HazardAbridgedDataModeTEST      HazardAbridgedDataMode = "TEST"
)

// Defines values for HazardFullDataMode.
const (
	HazardFullDataModeEXERCISE  HazardFullDataMode = "EXERCISE"
	HazardFullDataModeREAL      HazardFullDataMode = "REAL"
	HazardFullDataModeSIMULATED HazardFullDataMode = "SIMULATED"
	HazardFullDataModeTEST      HazardFullDataMode = "TEST"
)

// Defines values for HazardIngestDataMode.
const (
	HazardIngestDataModeEXERCISE  HazardIngestDataMode = "EXERCISE"
	HazardIngestDataModeREAL      HazardIngestDataMode = "REAL"
	HazardIngestDataModeSIMULATED HazardIngestDataMode = "SIMULATED"
	HazardIngestDataModeTEST      HazardIngestDataMode = "TEST"
)

// Defines values for LocationAbridgedDataMode.
const (
	LocationAbridgedDataModeEXERCISE  LocationAbridgedDataMode = "EXERCISE"
	LocationAbridgedDataModeREAL      LocationAbridgedDataMode = "REAL"
	LocationAbridgedDataModeSIMULATED LocationAbridgedDataMode = "SIMULATED"
	LocationAbridgedDataModeTEST      LocationAbridgedDataMode = "TEST"
)

// Defines values for LocationFullDataMode.
const (
	LocationFullDataModeEXERCISE  LocationFullDataMode = "EXERCISE"
	LocationFullDataModeREAL      LocationFullDataMode = "REAL"
	LocationFullDataModeSIMULATED LocationFullDataMode = "SIMULATED"
	LocationFullDataModeTEST      LocationFullDataMode = "TEST"
)

// Defines values for LocationIngestDataMode.
const (
	LocationIngestDataModeEXERCISE  LocationIngestDataMode = "EXERCISE"
	LocationIngestDataModeREAL      LocationIngestDataMode = "REAL"
	LocationIngestDataModeSIMULATED LocationIngestDataMode = "SIMULATED"
	LocationIngestDataModeTEST      LocationIngestDataMode = "TEST"
)

// Defines values for MissileTrackAbridgedDataMode.
const (
	MissileTrackAbridgedDataModeEXERCISE  MissileTrackAbridgedDataMode = "EXERCISE"
	MissileTrackAbridgedDataModeREAL      MissileTrackAbridgedDataMode = "REAL"
	MissileTrackAbridgedDataModeSIMULATED MissileTrackAbridgedDataMode = "SIMULATED"
	MissileTrackAbridgedDataModeTEST      MissileTrackAbridgedDataMode = "TEST"
)

// Defines values for MissileTrackAbridgedEnv.
const (
	MissileTrackAbridgedEnvAIR        MissileTrackAbridgedEnv = "AIR"
	MissileTrackAbridgedEnvLAND       MissileTrackAbridgedEnv = "LAND"
	MissileTrackAbridgedEnvSPACE      MissileTrackAbridgedEnv = "SPACE"
	MissileTrackAbridgedEnvSUBSURFACE MissileTrackAbridgedEnv = "SUBSURFACE"
	MissileTrackAbridgedEnvSURFACE    MissileTrackAbridgedEnv = "SURFACE"
	MissileTrackAbridgedEnvUNKNOWN    MissileTrackAbridgedEnv = "UNKNOWN"
)

// Defines values for MissileTrackAbridgedObjIdent.
const (
	MissileTrackAbridgedObjIdentASSUMEDFRIEND MissileTrackAbridgedObjIdent = "ASSUMED FRIEND"
	MissileTrackAbridgedObjIdentFRIEND        MissileTrackAbridgedObjIdent = "FRIEND"
	MissileTrackAbridgedObjIdentHOSTILE       MissileTrackAbridgedObjIdent = "HOSTILE"
	MissileTrackAbridgedObjIdentNEUTRAL       MissileTrackAbridgedObjIdent = "NEUTRAL"
	MissileTrackAbridgedObjIdentPENDING       MissileTrackAbridgedObjIdent = "PENDING"
	MissileTrackAbridgedObjIdentSUSPECT       MissileTrackAbridgedObjIdent = "SUSPECT"
	MissileTrackAbridgedObjIdentUNKNOWN       MissileTrackAbridgedObjIdent = "UNKNOWN"
)

// Defines values for MissileTrackFullDataMode.
const (
	MissileTrackFullDataModeEXERCISE  MissileTrackFullDataMode = "EXERCISE"
	MissileTrackFullDataModeREAL      MissileTrackFullDataMode = "REAL"
	MissileTrackFullDataModeSIMULATED MissileTrackFullDataMode = "SIMULATED"
	MissileTrackFullDataModeTEST      MissileTrackFullDataMode = "TEST"
)

// Defines values for MissileTrackFullEnv.
const (
	MissileTrackFullEnvAIR        MissileTrackFullEnv = "AIR"
	MissileTrackFullEnvLAND       MissileTrackFullEnv = "LAND"
	MissileTrackFullEnvSPACE      MissileTrackFullEnv = "SPACE"
	MissileTrackFullEnvSUBSURFACE MissileTrackFullEnv = "SUBSURFACE"
	MissileTrackFullEnvSURFACE    MissileTrackFullEnv = "SURFACE"
	MissileTrackFullEnvUNKNOWN    MissileTrackFullEnv = "UNKNOWN"
)

// Defines values for MissileTrackFullObjIdent.
const (
	MissileTrackFullObjIdentASSUMEDFRIEND MissileTrackFullObjIdent = "ASSUMED FRIEND"
	MissileTrackFullObjIdentFRIEND        MissileTrackFullObjIdent = "FRIEND"
	MissileTrackFullObjIdentHOSTILE       MissileTrackFullObjIdent = "HOSTILE"
	MissileTrackFullObjIdentNEUTRAL       MissileTrackFullObjIdent = "NEUTRAL"
	MissileTrackFullObjIdentPENDING       MissileTrackFullObjIdent = "PENDING"
	MissileTrackFullObjIdentSUSPECT       MissileTrackFullObjIdent = "SUSPECT"
	MissileTrackFullObjIdentUNKNOWN       MissileTrackFullObjIdent = "UNKNOWN"
)

// Defines values for MissileTrackIngestDataMode.
const (
	MissileTrackIngestDataModeEXERCISE  MissileTrackIngestDataMode = "EXERCISE"
	MissileTrackIngestDataModeREAL      MissileTrackIngestDataMode = "REAL"
	MissileTrackIngestDataModeSIMULATED MissileTrackIngestDataMode = "SIMULATED"
	MissileTrackIngestDataModeTEST      MissileTrackIngestDataMode = "TEST"
)

// Defines values for MissileTrackIngestEnv.
const (
	MissileTrackIngestEnvAIR        MissileTrackIngestEnv = "AIR"
	MissileTrackIngestEnvLAND       MissileTrackIngestEnv = "LAND"
	MissileTrackIngestEnvSPACE      MissileTrackIngestEnv = "SPACE"
	MissileTrackIngestEnvSUBSURFACE MissileTrackIngestEnv = "SUBSURFACE"
	MissileTrackIngestEnvSURFACE    MissileTrackIngestEnv = "SURFACE"
	MissileTrackIngestEnvUNKNOWN    MissileTrackIngestEnv = "UNKNOWN"
)

// Defines values for MissileTrackIngestObjIdent.
const (
	MissileTrackIngestObjIdentASSUMEDFRIEND MissileTrackIngestObjIdent = "ASSUMED FRIEND"
	MissileTrackIngestObjIdentFRIEND        MissileTrackIngestObjIdent = "FRIEND"
	MissileTrackIngestObjIdentHOSTILE       MissileTrackIngestObjIdent = "HOSTILE"
	MissileTrackIngestObjIdentNEUTRAL       MissileTrackIngestObjIdent = "NEUTRAL"
	MissileTrackIngestObjIdentPENDING       MissileTrackIngestObjIdent = "PENDING"
	MissileTrackIngestObjIdentSUSPECT       MissileTrackIngestObjIdent = "SUSPECT"
	MissileTrackIngestObjIdentUNKNOWN       MissileTrackIngestObjIdent = "UNKNOWN"
)

// Defines values for MissionAssignmentAbridgedDataMode.
const (
	MissionAssignmentAbridgedDataModeEXERCISE  MissionAssignmentAbridgedDataMode = "EXERCISE"
	MissionAssignmentAbridgedDataModeREAL      MissionAssignmentAbridgedDataMode = "REAL"
	MissionAssignmentAbridgedDataModeSIMULATED MissionAssignmentAbridgedDataMode = "SIMULATED"
	MissionAssignmentAbridgedDataModeTEST      MissionAssignmentAbridgedDataMode = "TEST"
)

// Defines values for MissionAssignmentFullDataMode.
const (
	MissionAssignmentFullDataModeEXERCISE  MissionAssignmentFullDataMode = "EXERCISE"
	MissionAssignmentFullDataModeREAL      MissionAssignmentFullDataMode = "REAL"
	MissionAssignmentFullDataModeSIMULATED MissionAssignmentFullDataMode = "SIMULATED"
	MissionAssignmentFullDataModeTEST      MissionAssignmentFullDataMode = "TEST"
)

// Defines values for MissionAssignmentIngestDataMode.
const (
	MissionAssignmentIngestDataModeEXERCISE  MissionAssignmentIngestDataMode = "EXERCISE"
	MissionAssignmentIngestDataModeREAL      MissionAssignmentIngestDataMode = "REAL"
	MissionAssignmentIngestDataModeSIMULATED MissionAssignmentIngestDataMode = "SIMULATED"
	MissionAssignmentIngestDataModeTEST      MissionAssignmentIngestDataMode = "TEST"
)

// Defines values for OnorbitAntennaFullDataMode.
const (
	OnorbitAntennaFullDataModeEXERCISE  OnorbitAntennaFullDataMode = "EXERCISE"
	OnorbitAntennaFullDataModeREAL      OnorbitAntennaFullDataMode = "REAL"
	OnorbitAntennaFullDataModeSIMULATED OnorbitAntennaFullDataMode = "SIMULATED"
	OnorbitAntennaFullDataModeTEST      OnorbitAntennaFullDataMode = "TEST"
)

// Defines values for OnorbitBatteryFullDataMode.
const (
	OnorbitBatteryFullDataModeEXERCISE  OnorbitBatteryFullDataMode = "EXERCISE"
	OnorbitBatteryFullDataModeREAL      OnorbitBatteryFullDataMode = "REAL"
	OnorbitBatteryFullDataModeSIMULATED OnorbitBatteryFullDataMode = "SIMULATED"
	OnorbitBatteryFullDataModeTEST      OnorbitBatteryFullDataMode = "TEST"
)

// Defines values for OnorbitDetailsFullDataMode.
const (
	OnorbitDetailsFullDataModeEXERCISE  OnorbitDetailsFullDataMode = "EXERCISE"
	OnorbitDetailsFullDataModeREAL      OnorbitDetailsFullDataMode = "REAL"
	OnorbitDetailsFullDataModeSIMULATED OnorbitDetailsFullDataMode = "SIMULATED"
	OnorbitDetailsFullDataModeTEST      OnorbitDetailsFullDataMode = "TEST"
)

// Defines values for OnorbitSolarArrayFullDataMode.
const (
	OnorbitSolarArrayFullDataModeEXERCISE  OnorbitSolarArrayFullDataMode = "EXERCISE"
	OnorbitSolarArrayFullDataModeREAL      OnorbitSolarArrayFullDataMode = "REAL"
	OnorbitSolarArrayFullDataModeSIMULATED OnorbitSolarArrayFullDataMode = "SIMULATED"
	OnorbitSolarArrayFullDataModeTEST      OnorbitSolarArrayFullDataMode = "TEST"
)

// Defines values for OnorbitThrusterFullDataMode.
const (
	OnorbitThrusterFullDataModeEXERCISE  OnorbitThrusterFullDataMode = "EXERCISE"
	OnorbitThrusterFullDataModeREAL      OnorbitThrusterFullDataMode = "REAL"
	OnorbitThrusterFullDataModeSIMULATED OnorbitThrusterFullDataMode = "SIMULATED"
	OnorbitThrusterFullDataModeTEST      OnorbitThrusterFullDataMode = "TEST"
)

// Defines values for OnorbitAbridgedCategory.
const (
	OnorbitAbridgedCategoryAnalystSatellite      OnorbitAbridgedCategory = "Analyst Satellite"
	OnorbitAbridgedCategoryCatalogedWithoutState OnorbitAbridgedCategory = "Cataloged Without State"
	OnorbitAbridgedCategoryCislunar              OnorbitAbridgedCategory = "Cislunar"
	OnorbitAbridgedCategoryDecayed               OnorbitAbridgedCategory = "Decayed"
	OnorbitAbridgedCategoryDocked                OnorbitAbridgedCategory = "Docked"
	OnorbitAbridgedCategoryHeliocentric          OnorbitAbridgedCategory = "Heliocentric"
	OnorbitAbridgedCategoryHyperbolic            OnorbitAbridgedCategory = "Hyperbolic"
	OnorbitAbridgedCategoryInterplanetary        OnorbitAbridgedCategory = "Interplanetary"
	OnorbitAbridgedCategoryLagrangian            OnorbitAbridgedCategory = "Lagrangian"
	OnorbitAbridgedCategoryLaunchNominal         OnorbitAbridgedCategory = "Launch Nominal"
	OnorbitAbridgedCategoryLunar                 OnorbitAbridgedCategory = "Lunar"
	OnorbitAbridgedCategoryOnOrbit               OnorbitAbridgedCategory = "On-Orbit"
	OnorbitAbridgedCategoryUnknown               OnorbitAbridgedCategory = "Unknown"
)

// Defines values for OnorbitAbridgedDataMode.
const (
	OnorbitAbridgedDataModeEXERCISE  OnorbitAbridgedDataMode = "EXERCISE"
	OnorbitAbridgedDataModeREAL      OnorbitAbridgedDataMode = "REAL"
	OnorbitAbridgedDataModeSIMULATED OnorbitAbridgedDataMode = "SIMULATED"
	OnorbitAbridgedDataModeTEST      OnorbitAbridgedDataMode = "TEST"
)

// Defines values for OnorbitAbridgedObjectType.
const (
	OnorbitAbridgedObjectTypeDEBRIS     OnorbitAbridgedObjectType = "DEBRIS"
	OnorbitAbridgedObjectTypeMANNED     OnorbitAbridgedObjectType = "MANNED"
	OnorbitAbridgedObjectTypePAYLOAD    OnorbitAbridgedObjectType = "PAYLOAD"
	OnorbitAbridgedObjectTypePLATFORM   OnorbitAbridgedObjectType = "PLATFORM"
	OnorbitAbridgedObjectTypeROCKETBODY OnorbitAbridgedObjectType = "ROCKET BODY"
	OnorbitAbridgedObjectTypeUNKNOWN    OnorbitAbridgedObjectType = "UNKNOWN"
)

// Defines values for OnorbitFullCategory.
const (
	OnorbitFullCategoryAnalystSatellite      OnorbitFullCategory = "Analyst Satellite"
	OnorbitFullCategoryCatalogedWithoutState OnorbitFullCategory = "Cataloged Without State"
	OnorbitFullCategoryCislunar              OnorbitFullCategory = "Cislunar"
	OnorbitFullCategoryDecayed               OnorbitFullCategory = "Decayed"
	OnorbitFullCategoryDocked                OnorbitFullCategory = "Docked"
	OnorbitFullCategoryHeliocentric          OnorbitFullCategory = "Heliocentric"
	OnorbitFullCategoryHyperbolic            OnorbitFullCategory = "Hyperbolic"
	OnorbitFullCategoryInterplanetary        OnorbitFullCategory = "Interplanetary"
	OnorbitFullCategoryLagrangian            OnorbitFullCategory = "Lagrangian"
	OnorbitFullCategoryLaunchNominal         OnorbitFullCategory = "Launch Nominal"
	OnorbitFullCategoryLunar                 OnorbitFullCategory = "Lunar"
	OnorbitFullCategoryOnOrbit               OnorbitFullCategory = "On-Orbit"
	OnorbitFullCategoryUnknown               OnorbitFullCategory = "Unknown"
)

// Defines values for OnorbitFullDataMode.
const (
	OnorbitFullDataModeEXERCISE  OnorbitFullDataMode = "EXERCISE"
	OnorbitFullDataModeREAL      OnorbitFullDataMode = "REAL"
	OnorbitFullDataModeSIMULATED OnorbitFullDataMode = "SIMULATED"
	OnorbitFullDataModeTEST      OnorbitFullDataMode = "TEST"
)

// Defines values for OnorbitFullObjectType.
const (
	OnorbitFullObjectTypeDEBRIS     OnorbitFullObjectType = "DEBRIS"
	OnorbitFullObjectTypeMANNED     OnorbitFullObjectType = "MANNED"
	OnorbitFullObjectTypePAYLOAD    OnorbitFullObjectType = "PAYLOAD"
	OnorbitFullObjectTypePLATFORM   OnorbitFullObjectType = "PLATFORM"
	OnorbitFullObjectTypeROCKETBODY OnorbitFullObjectType = "ROCKET BODY"
	OnorbitFullObjectTypeUNKNOWN    OnorbitFullObjectType = "UNKNOWN"
)

// Defines values for OnorbitIngestCategory.
const (
	AnalystSatellite      OnorbitIngestCategory = "Analyst Satellite"
	CatalogedWithoutState OnorbitIngestCategory = "Cataloged Without State"
	Cislunar              OnorbitIngestCategory = "Cislunar"
	Decayed               OnorbitIngestCategory = "Decayed"
	Docked                OnorbitIngestCategory = "Docked"
	Heliocentric          OnorbitIngestCategory = "Heliocentric"
	Hyperbolic            OnorbitIngestCategory = "Hyperbolic"
	Interplanetary        OnorbitIngestCategory = "Interplanetary"
	Lagrangian            OnorbitIngestCategory = "Lagrangian"
	LaunchNominal         OnorbitIngestCategory = "Launch Nominal"
	Lunar                 OnorbitIngestCategory = "Lunar"
	OnOrbit               OnorbitIngestCategory = "On-Orbit"
	Unknown               OnorbitIngestCategory = "Unknown"
)

// Defines values for OnorbitIngestDataMode.
const (
	OnorbitIngestDataModeEXERCISE  OnorbitIngestDataMode = "EXERCISE"
	OnorbitIngestDataModeREAL      OnorbitIngestDataMode = "REAL"
	OnorbitIngestDataModeSIMULATED OnorbitIngestDataMode = "SIMULATED"
	OnorbitIngestDataModeTEST      OnorbitIngestDataMode = "TEST"
)

// Defines values for OnorbitIngestObjectType.
const (
	OnorbitIngestObjectTypeDEBRIS     OnorbitIngestObjectType = "DEBRIS"
	OnorbitIngestObjectTypeMANNED     OnorbitIngestObjectType = "MANNED"
	OnorbitIngestObjectTypePAYLOAD    OnorbitIngestObjectType = "PAYLOAD"
	OnorbitIngestObjectTypePLATFORM   OnorbitIngestObjectType = "PLATFORM"
	OnorbitIngestObjectTypeROCKETBODY OnorbitIngestObjectType = "ROCKET BODY"
	OnorbitIngestObjectTypeUNKNOWN    OnorbitIngestObjectType = "UNKNOWN"
)

// Defines values for OperatingunitFullDataMode.
const (
	OperatingunitFullDataModeEXERCISE  OperatingunitFullDataMode = "EXERCISE"
	OperatingunitFullDataModeREAL      OperatingunitFullDataMode = "REAL"
	OperatingunitFullDataModeSIMULATED OperatingunitFullDataMode = "SIMULATED"
	OperatingunitFullDataModeTEST      OperatingunitFullDataMode = "TEST"
)

// Defines values for OrbitTrackAbridgedDataMode.
const (
	OrbitTrackAbridgedDataModeEXERCISE  OrbitTrackAbridgedDataMode = "EXERCISE"
	OrbitTrackAbridgedDataModeREAL      OrbitTrackAbridgedDataMode = "REAL"
	OrbitTrackAbridgedDataModeSIMULATED OrbitTrackAbridgedDataMode = "SIMULATED"
	OrbitTrackAbridgedDataModeTEST      OrbitTrackAbridgedDataMode = "TEST"
)

// Defines values for OrbitTrackAbridgedObjIdent.
const (
	OrbitTrackAbridgedObjIdentASSUMEDFRIEND OrbitTrackAbridgedObjIdent = "ASSUMED FRIEND"
	OrbitTrackAbridgedObjIdentFRIEND        OrbitTrackAbridgedObjIdent = "FRIEND"
	OrbitTrackAbridgedObjIdentHOSTILE       OrbitTrackAbridgedObjIdent = "HOSTILE"
	OrbitTrackAbridgedObjIdentNEUTRAL       OrbitTrackAbridgedObjIdent = "NEUTRAL"
	OrbitTrackAbridgedObjIdentPENDING       OrbitTrackAbridgedObjIdent = "PENDING"
	OrbitTrackAbridgedObjIdentSUSPECT       OrbitTrackAbridgedObjIdent = "SUSPECT"
	OrbitTrackAbridgedObjIdentUNKNOWN       OrbitTrackAbridgedObjIdent = "UNKNOWN"
)

// Defines values for OrbitTrackAbridgedObjectType.
const (
	OrbitTrackAbridgedObjectTypeDEBRIS     OrbitTrackAbridgedObjectType = "DEBRIS"
	OrbitTrackAbridgedObjectTypeMANNED     OrbitTrackAbridgedObjectType = "MANNED"
	OrbitTrackAbridgedObjectTypePAYLOAD    OrbitTrackAbridgedObjectType = "PAYLOAD"
	OrbitTrackAbridgedObjectTypePLATFORM   OrbitTrackAbridgedObjectType = "PLATFORM"
	OrbitTrackAbridgedObjectTypeROCKETBODY OrbitTrackAbridgedObjectType = "ROCKET BODY"
	OrbitTrackAbridgedObjectTypeUNKNOWN    OrbitTrackAbridgedObjectType = "UNKNOWN"
)

// Defines values for OrbitTrackFullDataMode.
const (
	OrbitTrackFullDataModeEXERCISE  OrbitTrackFullDataMode = "EXERCISE"
	OrbitTrackFullDataModeREAL      OrbitTrackFullDataMode = "REAL"
	OrbitTrackFullDataModeSIMULATED OrbitTrackFullDataMode = "SIMULATED"
	OrbitTrackFullDataModeTEST      OrbitTrackFullDataMode = "TEST"
)

// Defines values for OrbitTrackFullObjIdent.
const (
	OrbitTrackFullObjIdentASSUMEDFRIEND OrbitTrackFullObjIdent = "ASSUMED FRIEND"
	OrbitTrackFullObjIdentFRIEND        OrbitTrackFullObjIdent = "FRIEND"
	OrbitTrackFullObjIdentHOSTILE       OrbitTrackFullObjIdent = "HOSTILE"
	OrbitTrackFullObjIdentNEUTRAL       OrbitTrackFullObjIdent = "NEUTRAL"
	OrbitTrackFullObjIdentPENDING       OrbitTrackFullObjIdent = "PENDING"
	OrbitTrackFullObjIdentSUSPECT       OrbitTrackFullObjIdent = "SUSPECT"
	OrbitTrackFullObjIdentUNKNOWN       OrbitTrackFullObjIdent = "UNKNOWN"
)

// Defines values for OrbitTrackFullObjectType.
const (
	OrbitTrackFullObjectTypeDEBRIS     OrbitTrackFullObjectType = "DEBRIS"
	OrbitTrackFullObjectTypeMANNED     OrbitTrackFullObjectType = "MANNED"
	OrbitTrackFullObjectTypePAYLOAD    OrbitTrackFullObjectType = "PAYLOAD"
	OrbitTrackFullObjectTypePLATFORM   OrbitTrackFullObjectType = "PLATFORM"
	OrbitTrackFullObjectTypeROCKETBODY OrbitTrackFullObjectType = "ROCKET BODY"
	OrbitTrackFullObjectTypeUNKNOWN    OrbitTrackFullObjectType = "UNKNOWN"
)

// Defines values for OrbitTrackIngestDataMode.
const (
	OrbitTrackIngestDataModeEXERCISE  OrbitTrackIngestDataMode = "EXERCISE"
	OrbitTrackIngestDataModeREAL      OrbitTrackIngestDataMode = "REAL"
	OrbitTrackIngestDataModeSIMULATED OrbitTrackIngestDataMode = "SIMULATED"
	OrbitTrackIngestDataModeTEST      OrbitTrackIngestDataMode = "TEST"
)

// Defines values for OrbitTrackIngestObjIdent.
const (
	OrbitTrackIngestObjIdentASSUMEDFRIEND OrbitTrackIngestObjIdent = "ASSUMED FRIEND"
	OrbitTrackIngestObjIdentFRIEND        OrbitTrackIngestObjIdent = "FRIEND"
	OrbitTrackIngestObjIdentHOSTILE       OrbitTrackIngestObjIdent = "HOSTILE"
	OrbitTrackIngestObjIdentNEUTRAL       OrbitTrackIngestObjIdent = "NEUTRAL"
	OrbitTrackIngestObjIdentPENDING       OrbitTrackIngestObjIdent = "PENDING"
	OrbitTrackIngestObjIdentSUSPECT       OrbitTrackIngestObjIdent = "SUSPECT"
	OrbitTrackIngestObjIdentUNKNOWN       OrbitTrackIngestObjIdent = "UNKNOWN"
)

// Defines values for OrbitTrackIngestObjectType.
const (
	OrbitTrackIngestObjectTypeDEBRIS     OrbitTrackIngestObjectType = "DEBRIS"
	OrbitTrackIngestObjectTypeMANNED     OrbitTrackIngestObjectType = "MANNED"
	OrbitTrackIngestObjectTypePAYLOAD    OrbitTrackIngestObjectType = "PAYLOAD"
	OrbitTrackIngestObjectTypePLATFORM   OrbitTrackIngestObjectType = "PLATFORM"
	OrbitTrackIngestObjectTypeROCKETBODY OrbitTrackIngestObjectType = "ROCKET BODY"
	OrbitTrackIngestObjectTypeUNKNOWN    OrbitTrackIngestObjectType = "UNKNOWN"
)

// Defines values for OrganizationDetailsFullDataMode.
const (
	OrganizationDetailsFullDataModeEXERCISE  OrganizationDetailsFullDataMode = "EXERCISE"
	OrganizationDetailsFullDataModeREAL      OrganizationDetailsFullDataMode = "REAL"
	OrganizationDetailsFullDataModeSIMULATED OrganizationDetailsFullDataMode = "SIMULATED"
	OrganizationDetailsFullDataModeTEST      OrganizationDetailsFullDataMode = "TEST"
)

// Defines values for OrganizationFullDataMode.
const (
	OrganizationFullDataModeEXERCISE  OrganizationFullDataMode = "EXERCISE"
	OrganizationFullDataModeREAL      OrganizationFullDataMode = "REAL"
	OrganizationFullDataModeSIMULATED OrganizationFullDataMode = "SIMULATED"
	OrganizationFullDataModeTEST      OrganizationFullDataMode = "TEST"
)

// Defines values for POIAbridgedDataMode.
const (
	POIAbridgedDataModeEXERCISE  POIAbridgedDataMode = "EXERCISE"
	POIAbridgedDataModeREAL      POIAbridgedDataMode = "REAL"
	POIAbridgedDataModeSIMULATED POIAbridgedDataMode = "SIMULATED"
	POIAbridgedDataModeTEST      POIAbridgedDataMode = "TEST"
)

// Defines values for POIFullDataMode.
const (
	POIFullDataModeEXERCISE  POIFullDataMode = "EXERCISE"
	POIFullDataModeREAL      POIFullDataMode = "REAL"
	POIFullDataModeSIMULATED POIFullDataMode = "SIMULATED"
	POIFullDataModeTEST      POIFullDataMode = "TEST"
)

// Defines values for POIIngestDataMode.
const (
	POIIngestDataModeEXERCISE  POIIngestDataMode = "EXERCISE"
	POIIngestDataModeREAL      POIIngestDataMode = "REAL"
	POIIngestDataModeSIMULATED POIIngestDataMode = "SIMULATED"
	POIIngestDataModeTEST      POIIngestDataMode = "TEST"
)

// Defines values for RFBandFullDataMode.
const (
	RFBandFullDataModeEXERCISE  RFBandFullDataMode = "EXERCISE"
	RFBandFullDataModeREAL      RFBandFullDataMode = "REAL"
	RFBandFullDataModeSIMULATED RFBandFullDataMode = "SIMULATED"
	RFBandFullDataModeTEST      RFBandFullDataMode = "TEST"
)

// Defines values for RFBandFullMode.
const (
	RFBandFullModeRX RFBandFullMode = "RX"
	RFBandFullModeTX RFBandFullMode = "TX"
)

// Defines values for RFBandFullPolarization.
const (
	H RFBandFullPolarization = "H"
	L RFBandFullPolarization = "L"
	R RFBandFullPolarization = "R"
	V RFBandFullPolarization = "V"
)

// Defines values for RFBandFullPurpose.
const (
	RFBandFullPurposeCOMM  RFBandFullPurpose = "COMM"
	RFBandFullPurposeOPS   RFBandFullPurpose = "OPS"
	RFBandFullPurposeOTHER RFBandFullPurpose = "OTHER"
	RFBandFullPurposeTTC   RFBandFullPurpose = "TTC"
)

// Defines values for SensorStatsAbridgedDataMode.
const (
	SensorStatsAbridgedDataModeEXERCISE  SensorStatsAbridgedDataMode = "EXERCISE"
	SensorStatsAbridgedDataModeREAL      SensorStatsAbridgedDataMode = "REAL"
	SensorStatsAbridgedDataModeSIMULATED SensorStatsAbridgedDataMode = "SIMULATED"
	SensorStatsAbridgedDataModeTEST      SensorStatsAbridgedDataMode = "TEST"
)

// Defines values for SensorStatsFullDataMode.
const (
	SensorStatsFullDataModeEXERCISE  SensorStatsFullDataMode = "EXERCISE"
	SensorStatsFullDataModeREAL      SensorStatsFullDataMode = "REAL"
	SensorStatsFullDataModeSIMULATED SensorStatsFullDataMode = "SIMULATED"
	SensorStatsFullDataModeTEST      SensorStatsFullDataMode = "TEST"
)

// Defines values for SensorAbridgedDataMode.
const (
	SensorAbridgedDataModeEXERCISE  SensorAbridgedDataMode = "EXERCISE"
	SensorAbridgedDataModeREAL      SensorAbridgedDataMode = "REAL"
	SensorAbridgedDataModeSIMULATED SensorAbridgedDataMode = "SIMULATED"
	SensorAbridgedDataModeTEST      SensorAbridgedDataMode = "TEST"
)

// Defines values for SensorFullDataMode.
const (
	SensorFullDataModeEXERCISE  SensorFullDataMode = "EXERCISE"
	SensorFullDataModeREAL      SensorFullDataMode = "REAL"
	SensorFullDataModeSIMULATED SensorFullDataMode = "SIMULATED"
	SensorFullDataModeTEST      SensorFullDataMode = "TEST"
)

// Defines values for SensorcharacteristicsAbridgedDataMode.
const (
	SensorcharacteristicsAbridgedDataModeEXERCISE  SensorcharacteristicsAbridgedDataMode = "EXERCISE"
	SensorcharacteristicsAbridgedDataModeREAL      SensorcharacteristicsAbridgedDataMode = "REAL"
	SensorcharacteristicsAbridgedDataModeSIMULATED SensorcharacteristicsAbridgedDataMode = "SIMULATED"
	SensorcharacteristicsAbridgedDataModeTEST      SensorcharacteristicsAbridgedDataMode = "TEST"
)

// Defines values for SensorcharacteristicsFullDataMode.
const (
	SensorcharacteristicsFullDataModeEXERCISE  SensorcharacteristicsFullDataMode = "EXERCISE"
	SensorcharacteristicsFullDataModeREAL      SensorcharacteristicsFullDataMode = "REAL"
	SensorcharacteristicsFullDataModeSIMULATED SensorcharacteristicsFullDataMode = "SIMULATED"
	SensorcharacteristicsFullDataModeTEST      SensorcharacteristicsFullDataMode = "TEST"
)

// Defines values for SensorlimitsAbridgedDataMode.
const (
	SensorlimitsAbridgedDataModeEXERCISE  SensorlimitsAbridgedDataMode = "EXERCISE"
	SensorlimitsAbridgedDataModeREAL      SensorlimitsAbridgedDataMode = "REAL"
	SensorlimitsAbridgedDataModeSIMULATED SensorlimitsAbridgedDataMode = "SIMULATED"
	SensorlimitsAbridgedDataModeTEST      SensorlimitsAbridgedDataMode = "TEST"
)

// Defines values for SensorlimitsFullDataMode.
const (
	SensorlimitsFullDataModeEXERCISE  SensorlimitsFullDataMode = "EXERCISE"
	SensorlimitsFullDataModeREAL      SensorlimitsFullDataMode = "REAL"
	SensorlimitsFullDataModeSIMULATED SensorlimitsFullDataMode = "SIMULATED"
	SensorlimitsFullDataModeTEST      SensorlimitsFullDataMode = "TEST"
)

// Defines values for SensorobservationtypeFullDataMode.
const (
	SensorobservationtypeFullDataModeEXERCISE  SensorobservationtypeFullDataMode = "EXERCISE"
	SensorobservationtypeFullDataModeREAL      SensorobservationtypeFullDataMode = "REAL"
	SensorobservationtypeFullDataModeSIMULATED SensorobservationtypeFullDataMode = "SIMULATED"
	SensorobservationtypeFullDataModeTEST      SensorobservationtypeFullDataMode = "TEST"
)

// Defines values for SensortypeFullDataMode.
const (
	SensortypeFullDataModeEXERCISE  SensortypeFullDataMode = "EXERCISE"
	SensortypeFullDataModeREAL      SensortypeFullDataMode = "REAL"
	SensortypeFullDataModeSIMULATED SensortypeFullDataMode = "SIMULATED"
	SensortypeFullDataModeTEST      SensortypeFullDataMode = "TEST"
)

// Defines values for SigActAbridgedDataMode.
const (
	SigActAbridgedDataModeEXERCISE  SigActAbridgedDataMode = "EXERCISE"
	SigActAbridgedDataModeREAL      SigActAbridgedDataMode = "REAL"
	SigActAbridgedDataModeSIMULATED SigActAbridgedDataMode = "SIMULATED"
	SigActAbridgedDataModeTEST      SigActAbridgedDataMode = "TEST"
)

// Defines values for SigActFullDataMode.
const (
	SigActFullDataModeEXERCISE  SigActFullDataMode = "EXERCISE"
	SigActFullDataModeREAL      SigActFullDataMode = "REAL"
	SigActFullDataModeSIMULATED SigActFullDataMode = "SIMULATED"
	SigActFullDataModeTEST      SigActFullDataMode = "TEST"
)

// Defines values for SigActIngestDataMode.
const (
	SigActIngestDataModeEXERCISE  SigActIngestDataMode = "EXERCISE"
	SigActIngestDataModeREAL      SigActIngestDataMode = "REAL"
	SigActIngestDataModeSIMULATED SigActIngestDataMode = "SIMULATED"
	SigActIngestDataModeTEST      SigActIngestDataMode = "TEST"
)

// Defines values for SiteStatusAbridgedDataMode.
const (
	SiteStatusAbridgedDataModeEXERCISE  SiteStatusAbridgedDataMode = "EXERCISE"
	SiteStatusAbridgedDataModeREAL      SiteStatusAbridgedDataMode = "REAL"
	SiteStatusAbridgedDataModeSIMULATED SiteStatusAbridgedDataMode = "SIMULATED"
	SiteStatusAbridgedDataModeTEST      SiteStatusAbridgedDataMode = "TEST"
)

// Defines values for SiteStatusFullDataMode.
const (
	SiteStatusFullDataModeEXERCISE  SiteStatusFullDataMode = "EXERCISE"
	SiteStatusFullDataModeREAL      SiteStatusFullDataMode = "REAL"
	SiteStatusFullDataModeSIMULATED SiteStatusFullDataMode = "SIMULATED"
	SiteStatusFullDataModeTEST      SiteStatusFullDataMode = "TEST"
)

// Defines values for SiteStatusIngestDataMode.
const (
	SiteStatusIngestDataModeEXERCISE  SiteStatusIngestDataMode = "EXERCISE"
	SiteStatusIngestDataModeREAL      SiteStatusIngestDataMode = "REAL"
	SiteStatusIngestDataModeSIMULATED SiteStatusIngestDataMode = "SIMULATED"
	SiteStatusIngestDataModeTEST      SiteStatusIngestDataMode = "TEST"
)

// Defines values for SiteAbridgedDataMode.
const (
	SiteAbridgedDataModeEXERCISE  SiteAbridgedDataMode = "EXERCISE"
	SiteAbridgedDataModeREAL      SiteAbridgedDataMode = "REAL"
	SiteAbridgedDataModeSIMULATED SiteAbridgedDataMode = "SIMULATED"
	SiteAbridgedDataModeTEST      SiteAbridgedDataMode = "TEST"
)

// Defines values for SiteFullDataMode.
const (
	SiteFullDataModeEXERCISE  SiteFullDataMode = "EXERCISE"
	SiteFullDataModeREAL      SiteFullDataMode = "REAL"
	SiteFullDataModeSIMULATED SiteFullDataMode = "SIMULATED"
	SiteFullDataModeTEST      SiteFullDataMode = "TEST"
)

// Defines values for SiteIngestDataMode.
const (
	SiteIngestDataModeEXERCISE  SiteIngestDataMode = "EXERCISE"
	SiteIngestDataModeREAL      SiteIngestDataMode = "REAL"
	SiteIngestDataModeSIMULATED SiteIngestDataMode = "SIMULATED"
	SiteIngestDataModeTEST      SiteIngestDataMode = "TEST"
)

// Defines values for SolarArrayDetailsFullDataMode.
const (
	SolarArrayDetailsFullDataModeEXERCISE  SolarArrayDetailsFullDataMode = "EXERCISE"
	SolarArrayDetailsFullDataModeREAL      SolarArrayDetailsFullDataMode = "REAL"
	SolarArrayDetailsFullDataModeSIMULATED SolarArrayDetailsFullDataMode = "SIMULATED"
	SolarArrayDetailsFullDataModeTEST      SolarArrayDetailsFullDataMode = "TEST"
)

// Defines values for SolarArrayFullDataMode.
const (
	SolarArrayFullDataModeEXERCISE  SolarArrayFullDataMode = "EXERCISE"
	SolarArrayFullDataModeREAL      SolarArrayFullDataMode = "REAL"
	SolarArrayFullDataModeSIMULATED SolarArrayFullDataMode = "SIMULATED"
	SolarArrayFullDataModeTEST      SolarArrayFullDataMode = "TEST"
)

// Defines values for StateVectorFullCovReferenceFrame.
const (
	StateVectorFullCovReferenceFrameJ2000 StateVectorFullCovReferenceFrame = "J2000"
	StateVectorFullCovReferenceFrameUVW   StateVectorFullCovReferenceFrame = "UVW"
)

// Defines values for StateVectorFullDataMode.
const (
	StateVectorFullDataModeEXERCISE  StateVectorFullDataMode = "EXERCISE"
	StateVectorFullDataModeREAL      StateVectorFullDataMode = "REAL"
	StateVectorFullDataModeSIMULATED StateVectorFullDataMode = "SIMULATED"
	StateVectorFullDataModeTEST      StateVectorFullDataMode = "TEST"
)

// Defines values for StateVectorFullReferenceFrame.
const (
	StateVectorFullReferenceFrameECRECEF StateVectorFullReferenceFrame = "ECR/ECEF"
	StateVectorFullReferenceFrameEFGTDR  StateVectorFullReferenceFrame = "EFG/TDR"
	StateVectorFullReferenceFrameGCRF    StateVectorFullReferenceFrame = "GCRF"
	StateVectorFullReferenceFrameITRF    StateVectorFullReferenceFrame = "ITRF"
	StateVectorFullReferenceFrameJ2000   StateVectorFullReferenceFrame = "J2000"
	StateVectorFullReferenceFrameTEME    StateVectorFullReferenceFrame = "TEME"
)

// Defines values for StateVectorFullSourcedDataTypes.
const (
	DOA   StateVectorFullSourcedDataTypes = "DOA"
	ELSET StateVectorFullSourcedDataTypes = "ELSET"
	EO    StateVectorFullSourcedDataTypes = "EO"
	RADAR StateVectorFullSourcedDataTypes = "RADAR"
	RF    StateVectorFullSourcedDataTypes = "RF"
	SV    StateVectorFullSourcedDataTypes = "SV"
)

// Defines values for StatusFullDataMode.
const (
	StatusFullDataModeEXERCISE  StatusFullDataMode = "EXERCISE"
	StatusFullDataModeREAL      StatusFullDataMode = "REAL"
	StatusFullDataModeSIMULATED StatusFullDataMode = "SIMULATED"
	StatusFullDataModeTEST      StatusFullDataMode = "TEST"
)

// Defines values for StatusFullOpsCap.
const (
	StatusFullOpsCapFMC StatusFullOpsCap = "FMC"
	StatusFullOpsCapNMC StatusFullOpsCap = "NMC"
	StatusFullOpsCapPMC StatusFullOpsCap = "PMC"
	StatusFullOpsCapUNK StatusFullOpsCap = "UNK"
)

// Defines values for StatusFullState.
const (
	StatusFullStateACTIVE   StatusFullState = "ACTIVE"
	StatusFullStateDEAD     StatusFullState = "DEAD"
	StatusFullStateRFACTIVE StatusFullState = "RF ACTIVE"
	StatusFullStateSTANDBY  StatusFullState = "STANDBY"
	StatusFullStateUNKNOWN  StatusFullState = "UNKNOWN"
)

// Defines values for StatusFullSysCap.
const (
	StatusFullSysCapFMC StatusFullSysCap = "FMC"
	StatusFullSysCapNMC StatusFullSysCap = "NMC"
	StatusFullSysCapPMC StatusFullSysCap = "PMC"
	StatusFullSysCapUNK StatusFullSysCap = "UNK"
)

// Defines values for SubStatusFullDataMode.
const (
	SubStatusFullDataModeEXERCISE  SubStatusFullDataMode = "EXERCISE"
	SubStatusFullDataModeREAL      SubStatusFullDataMode = "REAL"
	SubStatusFullDataModeSIMULATED SubStatusFullDataMode = "SIMULATED"
	SubStatusFullDataModeTEST      SubStatusFullDataMode = "TEST"
)

// Defines values for SubStatusFullStatus.
const (
	FMC SubStatusFullStatus = "FMC"
	NMC SubStatusFullStatus = "NMC"
	PMC SubStatusFullStatus = "PMC"
	UNK SubStatusFullStatus = "UNK"
)

// Defines values for SubStatusFullType.
const (
	MdCap SubStatusFullType = "mdCap"
	MwCap SubStatusFullType = "mwCap"
	SsCap SubStatusFullType = "ssCap"
)

// Defines values for TrackDetailsAbridgedDataMode.
const (
	TrackDetailsAbridgedDataModeEXERCISE  TrackDetailsAbridgedDataMode = "EXERCISE"
	TrackDetailsAbridgedDataModeREAL      TrackDetailsAbridgedDataMode = "REAL"
	TrackDetailsAbridgedDataModeSIMULATED TrackDetailsAbridgedDataMode = "SIMULATED"
	TrackDetailsAbridgedDataModeTEST      TrackDetailsAbridgedDataMode = "TEST"
)

// Defines values for TrackDetailsAbridgedEnv.
const (
	TrackDetailsAbridgedEnvAIR        TrackDetailsAbridgedEnv = "AIR"
	TrackDetailsAbridgedEnvLAND       TrackDetailsAbridgedEnv = "LAND"
	TrackDetailsAbridgedEnvSPACE      TrackDetailsAbridgedEnv = "SPACE"
	TrackDetailsAbridgedEnvSUBSURFACE TrackDetailsAbridgedEnv = "SUBSURFACE"
	TrackDetailsAbridgedEnvSURFACE    TrackDetailsAbridgedEnv = "SURFACE"
	TrackDetailsAbridgedEnvUNKNOWN    TrackDetailsAbridgedEnv = "UNKNOWN"
)

// Defines values for TrackDetailsAbridgedMslStatus.
const (
	TrackDetailsAbridgedMslStatusATLAUNCH      TrackDetailsAbridgedMslStatus = "AT LAUNCH"
	TrackDetailsAbridgedMslStatusATOBSERVATION TrackDetailsAbridgedMslStatus = "AT OBSERVATION"
	TrackDetailsAbridgedMslStatusDEBRIS        TrackDetailsAbridgedMslStatus = "DEBRIS"
	TrackDetailsAbridgedMslStatusFLYING        TrackDetailsAbridgedMslStatus = "FLYING"
	TrackDetailsAbridgedMslStatusIMPACTED      TrackDetailsAbridgedMslStatus = "IMPACTED"
	TrackDetailsAbridgedMslStatusLOST          TrackDetailsAbridgedMslStatus = "LOST"
	TrackDetailsAbridgedMslStatusSTALE         TrackDetailsAbridgedMslStatus = "STALE"
)

// Defines values for TrackDetailsAbridgedObjIdent.
const (
	TrackDetailsAbridgedObjIdentASSUMEDFRIEND TrackDetailsAbridgedObjIdent = "ASSUMED FRIEND"
	TrackDetailsAbridgedObjIdentFRIEND        TrackDetailsAbridgedObjIdent = "FRIEND"
	TrackDetailsAbridgedObjIdentHOSTILE       TrackDetailsAbridgedObjIdent = "HOSTILE"
	TrackDetailsAbridgedObjIdentNEUTRAL       TrackDetailsAbridgedObjIdent = "NEUTRAL"
	TrackDetailsAbridgedObjIdentPENDING       TrackDetailsAbridgedObjIdent = "PENDING"
	TrackDetailsAbridgedObjIdentSUSPECT       TrackDetailsAbridgedObjIdent = "SUSPECT"
	TrackDetailsAbridgedObjIdentUNKNOWN       TrackDetailsAbridgedObjIdent = "UNKNOWN"
)

// Defines values for TrackDetailsFullDataMode.
const (
	TrackDetailsFullDataModeEXERCISE  TrackDetailsFullDataMode = "EXERCISE"
	TrackDetailsFullDataModeREAL      TrackDetailsFullDataMode = "REAL"
	TrackDetailsFullDataModeSIMULATED TrackDetailsFullDataMode = "SIMULATED"
	TrackDetailsFullDataModeTEST      TrackDetailsFullDataMode = "TEST"
)

// Defines values for TrackDetailsFullEnv.
const (
	TrackDetailsFullEnvAIR        TrackDetailsFullEnv = "AIR"
	TrackDetailsFullEnvLAND       TrackDetailsFullEnv = "LAND"
	TrackDetailsFullEnvSPACE      TrackDetailsFullEnv = "SPACE"
	TrackDetailsFullEnvSUBSURFACE TrackDetailsFullEnv = "SUBSURFACE"
	TrackDetailsFullEnvSURFACE    TrackDetailsFullEnv = "SURFACE"
	TrackDetailsFullEnvUNKNOWN    TrackDetailsFullEnv = "UNKNOWN"
)

// Defines values for TrackDetailsFullMslStatus.
const (
	TrackDetailsFullMslStatusATLAUNCH      TrackDetailsFullMslStatus = "AT LAUNCH"
	TrackDetailsFullMslStatusATOBSERVATION TrackDetailsFullMslStatus = "AT OBSERVATION"
	TrackDetailsFullMslStatusDEBRIS        TrackDetailsFullMslStatus = "DEBRIS"
	TrackDetailsFullMslStatusFLYING        TrackDetailsFullMslStatus = "FLYING"
	TrackDetailsFullMslStatusIMPACTED      TrackDetailsFullMslStatus = "IMPACTED"
	TrackDetailsFullMslStatusLOST          TrackDetailsFullMslStatus = "LOST"
	TrackDetailsFullMslStatusSTALE         TrackDetailsFullMslStatus = "STALE"
)

// Defines values for TrackDetailsFullObjIdent.
const (
	TrackDetailsFullObjIdentASSUMEDFRIEND TrackDetailsFullObjIdent = "ASSUMED FRIEND"
	TrackDetailsFullObjIdentFRIEND        TrackDetailsFullObjIdent = "FRIEND"
	TrackDetailsFullObjIdentHOSTILE       TrackDetailsFullObjIdent = "HOSTILE"
	TrackDetailsFullObjIdentNEUTRAL       TrackDetailsFullObjIdent = "NEUTRAL"
	TrackDetailsFullObjIdentPENDING       TrackDetailsFullObjIdent = "PENDING"
	TrackDetailsFullObjIdentSUSPECT       TrackDetailsFullObjIdent = "SUSPECT"
	TrackDetailsFullObjIdentUNKNOWN       TrackDetailsFullObjIdent = "UNKNOWN"
)

// Defines values for TrackDetailsIngestDataMode.
const (
	TrackDetailsIngestDataModeEXERCISE  TrackDetailsIngestDataMode = "EXERCISE"
	TrackDetailsIngestDataModeREAL      TrackDetailsIngestDataMode = "REAL"
	TrackDetailsIngestDataModeSIMULATED TrackDetailsIngestDataMode = "SIMULATED"
	TrackDetailsIngestDataModeTEST      TrackDetailsIngestDataMode = "TEST"
)

// Defines values for TrackDetailsIngestEnv.
const (
	TrackDetailsIngestEnvAIR        TrackDetailsIngestEnv = "AIR"
	TrackDetailsIngestEnvLAND       TrackDetailsIngestEnv = "LAND"
	TrackDetailsIngestEnvSPACE      TrackDetailsIngestEnv = "SPACE"
	TrackDetailsIngestEnvSUBSURFACE TrackDetailsIngestEnv = "SUBSURFACE"
	TrackDetailsIngestEnvSURFACE    TrackDetailsIngestEnv = "SURFACE"
	TrackDetailsIngestEnvUNKNOWN    TrackDetailsIngestEnv = "UNKNOWN"
)

// Defines values for TrackDetailsIngestMslStatus.
const (
	ATLAUNCH      TrackDetailsIngestMslStatus = "AT LAUNCH"
	ATOBSERVATION TrackDetailsIngestMslStatus = "AT OBSERVATION"
	DEBRIS        TrackDetailsIngestMslStatus = "DEBRIS"
	FLYING        TrackDetailsIngestMslStatus = "FLYING"
	IMPACTED      TrackDetailsIngestMslStatus = "IMPACTED"
	LOST          TrackDetailsIngestMslStatus = "LOST"
	STALE         TrackDetailsIngestMslStatus = "STALE"
)

// Defines values for TrackDetailsIngestObjIdent.
const (
	TrackDetailsIngestObjIdentASSUMEDFRIEND TrackDetailsIngestObjIdent = "ASSUMED FRIEND"
	TrackDetailsIngestObjIdentFRIEND        TrackDetailsIngestObjIdent = "FRIEND"
	TrackDetailsIngestObjIdentHOSTILE       TrackDetailsIngestObjIdent = "HOSTILE"
	TrackDetailsIngestObjIdentNEUTRAL       TrackDetailsIngestObjIdent = "NEUTRAL"
	TrackDetailsIngestObjIdentPENDING       TrackDetailsIngestObjIdent = "PENDING"
	TrackDetailsIngestObjIdentSUSPECT       TrackDetailsIngestObjIdent = "SUSPECT"
	TrackDetailsIngestObjIdentUNKNOWN       TrackDetailsIngestObjIdent = "UNKNOWN"
)

// Defines values for TrackSensorAbridgedSensorFOVType.
const (
	TrackSensorAbridgedSensorFOVTypeBUTTERFLY        TrackSensorAbridgedSensorFOVType = "BUTTERFLY"
	TrackSensorAbridgedSensorFOVTypeCONEANGULAR      TrackSensorAbridgedSensorFOVType = "CONE ANGULAR"
	TrackSensorAbridgedSensorFOVTypeCONEDISTANCE     TrackSensorAbridgedSensorFOVType = "CONE DISTANCE"
	TrackSensorAbridgedSensorFOVTypeHORIZONTOHORIZON TrackSensorAbridgedSensorFOVType = "HORIZON TO HORIZON"
	TrackSensorAbridgedSensorFOVTypeUNKNOWN          TrackSensorAbridgedSensorFOVType = "UNKNOWN"
)

// Defines values for TrackSensorFullSensorFOVType.
const (
	TrackSensorFullSensorFOVTypeBUTTERFLY        TrackSensorFullSensorFOVType = "BUTTERFLY"
	TrackSensorFullSensorFOVTypeCONEANGULAR      TrackSensorFullSensorFOVType = "CONE ANGULAR"
	TrackSensorFullSensorFOVTypeCONEDISTANCE     TrackSensorFullSensorFOVType = "CONE DISTANCE"
	TrackSensorFullSensorFOVTypeHORIZONTOHORIZON TrackSensorFullSensorFOVType = "HORIZON TO HORIZON"
	TrackSensorFullSensorFOVTypeUNKNOWN          TrackSensorFullSensorFOVType = "UNKNOWN"
)

// Defines values for TrackSensorIngestSensorFOVType.
const (
	BUTTERFLY        TrackSensorIngestSensorFOVType = "BUTTERFLY"
	CONEANGULAR      TrackSensorIngestSensorFOVType = "CONE ANGULAR"
	CONEDISTANCE     TrackSensorIngestSensorFOVType = "CONE DISTANCE"
	HORIZONTOHORIZON TrackSensorIngestSensorFOVType = "HORIZON TO HORIZON"
	UNKNOWN          TrackSensorIngestSensorFOVType = "UNKNOWN"
)

// Defines values for TrackAbridgedDataMode.
const (
	TrackAbridgedDataModeEXERCISE  TrackAbridgedDataMode = "EXERCISE"
	TrackAbridgedDataModeREAL      TrackAbridgedDataMode = "REAL"
	TrackAbridgedDataModeSIMULATED TrackAbridgedDataMode = "SIMULATED"
	TrackAbridgedDataModeTEST      TrackAbridgedDataMode = "TEST"
)

// Defines values for TrackFullDataMode.
const (
	TrackFullDataModeEXERCISE  TrackFullDataMode = "EXERCISE"
	TrackFullDataModeREAL      TrackFullDataMode = "REAL"
	TrackFullDataModeSIMULATED TrackFullDataMode = "SIMULATED"
	TrackFullDataModeTEST      TrackFullDataMode = "TEST"
)

// Defines values for TrackIngestDataMode.
const (
	TrackIngestDataModeEXERCISE  TrackIngestDataMode = "EXERCISE"
	TrackIngestDataModeREAL      TrackIngestDataMode = "REAL"
	TrackIngestDataModeSIMULATED TrackIngestDataMode = "SIMULATED"
	TrackIngestDataModeTEST      TrackIngestDataMode = "TEST"
)

// Defines values for WeatherReportAbridgedDataMode.
const (
	WeatherReportAbridgedDataModeEXERCISE  WeatherReportAbridgedDataMode = "EXERCISE"
	WeatherReportAbridgedDataModeREAL      WeatherReportAbridgedDataMode = "REAL"
	WeatherReportAbridgedDataModeSIMULATED WeatherReportAbridgedDataMode = "SIMULATED"
	WeatherReportAbridgedDataModeTEST      WeatherReportAbridgedDataMode = "TEST"
)

// Defines values for WeatherReportFullDataMode.
const (
	WeatherReportFullDataModeEXERCISE  WeatherReportFullDataMode = "EXERCISE"
	WeatherReportFullDataModeREAL      WeatherReportFullDataMode = "REAL"
	WeatherReportFullDataModeSIMULATED WeatherReportFullDataMode = "SIMULATED"
	WeatherReportFullDataModeTEST      WeatherReportFullDataMode = "TEST"
)

// Defines values for WeatherReportIngestDataMode.
const (
	EXERCISE  WeatherReportIngestDataMode = "EXERCISE"
	REAL      WeatherReportIngestDataMode = "REAL"
	SIMULATED WeatherReportIngestDataMode = "SIMULATED"
	TEST      WeatherReportIngestDataMode = "TEST"
)

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISAbridged struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISAbridgedDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName *string `json:"shipName,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISAbridgedDataMode string

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISFull struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISFullDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName *string `json:"shipName,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISFullDataMode string

// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
type AISIngest struct {
	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port)
	AvgSpeed *float64 `json:"avgSpeed,omitempty"`

	// A uniquely designated identifier for the vessel's transmitter station
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The course-over-ground reported by the vessel, in degrees
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The US Geographic Unique Identifier of the current port hosting the vessel
	CurrentPortGUID *string `json:"currentPortGUID,omitempty"`

	// The UN Location Code of the current port hosting the vessel
	CurrentPortLOCODE *string `json:"currentPortLOCODE,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AISIngestDataMode `json:"dataMode"`

	// The destination of the vessel according to the AIS transmission
	Destination *string `json:"destination,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format
	DestinationETA *time.Time `json:"destinationETA,omitempty"`

	// The remaining distance, in kilometers, for the vessel to reach the reported destination
	DistanceToGo *float64 `json:"distanceToGo,omitempty"`

	// The distance, in kilometers, that the vessel has travelled since departing the last port
	DistanceTravelled *float64 `json:"distanceTravelled,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission
	Draught *float64 `json:"draught,omitempty"`

	// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other
	EngagedIn *string `json:"engagedIn,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format
	EtaCalculated *time.Time `json:"etaCalculated,omitempty"`

	// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format
	EtaUpdated *time.Time `json:"etaUpdated,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Track
	IdTrack *string `json:"idTrack,omitempty"`

	// Unique identifier of the vessel
	IdVessel *string `json:"idVessel,omitempty"`

	// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel
	Imon *int64 `json:"imon,omitempty"`

	// The US Geographic Unique Identifier of the last port visited by the vessel
	LastPortGUID *string `json:"lastPortGUID,omitempty"`

	// The UN Location Code of the last port visited by the vessel
	LastPortLOCODE *string `json:"lastPortLOCODE,omitempty"`

	// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port)
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel
	Mmsi *int64 `json:"mmsi,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The US Geographic Unique Identifier of the next destination port of the vessel
	NextPortGUID *string `json:"nextPortGUID,omitempty"`

	// The UN  Location Code of the next destination port of the vessel
	NextPortLOCODE *string `json:"nextPortLOCODE,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters)
	PosHiAccuracy *bool `json:"posHiAccuracy,omitempty"`

	// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds)
	PosHiLatency *bool `json:"posHiLatency,omitempty"`

	// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right
	RateOfTurn *float64 `json:"rateOfTurn,omitempty"`

	// Further description or explanation of the vessel or type
	ShipDescription *string `json:"shipDescription,omitempty"`

	// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name
	ShipName *string `json:"shipName,omitempty"`

	// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels
	ShipType *string `json:"shipType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft
	SpecialCraft *string `json:"specialCraft,omitempty"`

	// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation)
	SpecialManeuver *bool `json:"specialManeuver,omitempty"`

	// The speed-over-ground reported by the vessel, in kilometers/hour
	Speed *float64 `json:"speed,omitempty"`

	// The true heading reported by the vessel, in degrees
	TrueHeading *float64 `json:"trueHeading,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// The flag of the subject vessel according to AIS transmission
	VesselFlag *string `json:"vesselFlag,omitempty"`

	// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AISIngestDataMode string

// Information related to the planning, load, status, and deployment or dispatch of one aircraft to carry out a mission.
type AircraftSortieAbridged struct {
	// The actual arrival time, in ISO 8601 UTC format
	ActualArrTime *time.Time `json:"actualArrTime,omitempty"`

	// The actual departure time, in ISO 8601 UTC format
	ActualDepTime *time.Time `json:"actualDepTime,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Aircraft event text
	AircraftEvent *string `json:"aircraftEvent,omitempty"`

	// Remarks concerning the aircraft
	AircraftRemarks *string `json:"aircraftRemarks,omitempty"`

	// The amount of time allowed between launch order and takeoff, in seconds
	AlertStatus *int32 `json:"alertStatus,omitempty"`

	// The Alert Status code
	AlertStatusCode *string `json:"alertStatusCode,omitempty"`

	// The call sign assigned to the aircraft on this sortie
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftSortieAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft
	IdAircraft *string `json:"idAircraft,omitempty"`

	// the external system line number of this sortie
	LineNumber *int32 `json:"lineNumber,omitempty"`

	// The mission ID associated with this sortie
	MissionId *string `json:"missionId,omitempty"`

	// Remarks concerning the sortie objective
	ObjectiveRemarks *string `json:"objectiveRemarks,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to arrive,  in ISO 8601 UTC format
	PlannedArrTime *time.Time `json:"plannedArrTime,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to depart,  in ISO 8601 UTC format
	PlannedDepTime *time.Time `json:"plannedDepTime,omitempty"`

	// The planned primary Standard Conventional Load of the aircraft for this sortie
	PrimarySCL *string `json:"primarySCL,omitempty"`

	// Remarks concerning the results of this sortie
	ResultRemarks *string `json:"resultRemarks,omitempty"`

	// Remarks concerning the schedule
	ScheduleRemarks *string `json:"scheduleRemarks,omitempty"`

	// The planned secondary Standard Conventional Load of the aircraft for this sortie.
	SecondarySCL *string `json:"secondarySCL,omitempty"`

	// The scheduled UTC date for this sortie, in ISO 8601 date-only format (ex. YYYY-MM-DD)
	SortieDate *openapi_types.Date `json:"sortieDate,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftSortieAbridgedDataMode string

// Information related to the planning, load, status, and deployment or dispatch of one aircraft to carry out a mission.
type AircraftSortieFull struct {
	// The actual arrival time, in ISO 8601 UTC format
	ActualArrTime *time.Time `json:"actualArrTime,omitempty"`

	// The actual departure time, in ISO 8601 UTC format
	ActualDepTime *time.Time `json:"actualDepTime,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Aircraft event text
	AircraftEvent *string `json:"aircraftEvent,omitempty"`

	// Remarks concerning the aircraft
	AircraftRemarks *string `json:"aircraftRemarks,omitempty"`

	// The amount of time allowed between launch order and takeoff, in seconds
	AlertStatus *int32 `json:"alertStatus,omitempty"`

	// The Alert Status code
	AlertStatusCode *string `json:"alertStatusCode,omitempty"`

	// The call sign assigned to the aircraft on this sortie
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftSortieFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft
	IdAircraft *string `json:"idAircraft,omitempty"`

	// the external system line number of this sortie
	LineNumber *int32 `json:"lineNumber,omitempty"`

	// The mission ID associated with this sortie
	MissionId *string `json:"missionId,omitempty"`

	// Remarks concerning the sortie objective
	ObjectiveRemarks *string `json:"objectiveRemarks,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to arrive,  in ISO 8601 UTC format
	PlannedArrTime *time.Time `json:"plannedArrTime,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to depart,  in ISO 8601 UTC format
	PlannedDepTime *time.Time `json:"plannedDepTime,omitempty"`

	// The planned primary Standard Conventional Load of the aircraft for this sortie
	PrimarySCL *string `json:"primarySCL,omitempty"`

	// Remarks concerning the results of this sortie
	ResultRemarks *string `json:"resultRemarks,omitempty"`

	// Remarks concerning the schedule
	ScheduleRemarks *string `json:"scheduleRemarks,omitempty"`

	// The planned secondary Standard Conventional Load of the aircraft for this sortie.
	SecondarySCL *string `json:"secondarySCL,omitempty"`

	// The scheduled UTC date for this sortie, in ISO 8601 date-only format (ex. YYYY-MM-DD)
	SortieDate *openapi_types.Date `json:"sortieDate,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftSortieFullDataMode string

// Information related to the planning, load, status, and deployment or dispatch of one aircraft to carry out a mission.
type AircraftSortieIngest struct {
	// The actual arrival time, in ISO 8601 UTC format
	ActualArrTime *time.Time `json:"actualArrTime,omitempty"`

	// The actual departure time, in ISO 8601 UTC format
	ActualDepTime *time.Time `json:"actualDepTime,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Aircraft event text
	AircraftEvent *string `json:"aircraftEvent,omitempty"`

	// Remarks concerning the aircraft
	AircraftRemarks *string `json:"aircraftRemarks,omitempty"`

	// The amount of time allowed between launch order and takeoff, in seconds
	AlertStatus *int32 `json:"alertStatus,omitempty"`

	// The Alert Status code
	AlertStatusCode *string `json:"alertStatusCode,omitempty"`

	// The call sign assigned to the aircraft on this sortie
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftSortieIngestDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft
	IdAircraft *string `json:"idAircraft,omitempty"`

	// the external system line number of this sortie
	LineNumber *int32 `json:"lineNumber,omitempty"`

	// The mission ID associated with this sortie
	MissionId *string `json:"missionId,omitempty"`

	// Remarks concerning the sortie objective
	ObjectiveRemarks *string `json:"objectiveRemarks,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to arrive,  in ISO 8601 UTC format
	PlannedArrTime *time.Time `json:"plannedArrTime,omitempty"`

	// The scheduled time that the Aircraft sortie is planned to depart,  in ISO 8601 UTC format
	PlannedDepTime *time.Time `json:"plannedDepTime,omitempty"`

	// The planned primary Standard Conventional Load of the aircraft for this sortie
	PrimarySCL *string `json:"primarySCL,omitempty"`

	// Remarks concerning the results of this sortie
	ResultRemarks *string `json:"resultRemarks,omitempty"`

	// Remarks concerning the schedule
	ScheduleRemarks *string `json:"scheduleRemarks,omitempty"`

	// The planned secondary Standard Conventional Load of the aircraft for this sortie.
	SecondarySCL *string `json:"secondarySCL,omitempty"`

	// The scheduled UTC date for this sortie, in ISO 8601 date-only format (ex. YYYY-MM-DD)
	SortieDate *openapi_types.Date `json:"sortieDate,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftSortieIngestDataMode string

// Aircraft readiness and status data. Contains the dynamic data associated with the specific aircraft status, either in-flight or on-ground, including remaining fuel, mission readiness, and inventory, etc.
type AircraftStatusAbridged struct {
	// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToAirStatus *AircraftStatusAbridgedAirToAirStatus `json:"airToAirStatus,omitempty"`

	// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToGroundStatus *AircraftStatusAbridgedAirToGroundStatus `json:"airToGroundStatus,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The contamination status of the aircraft (e.g. Clear, Contaminated, Decontaminated, Unknown, etc.)
	ContaminationStatus *string `json:"contaminationStatus,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
	CurrentState *AircraftStatusAbridgedCurrentState `json:"currentState,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftStatusAbridgedDataMode `json:"dataMode"`

	// The earliest time that turnaround of the aircraft may complete, in ISO 8601 UTC format
	EarliestTAEndTime *time.Time `json:"earliestTAEndTime,omitempty"`

	// The parking location of this aircraft as designated by EMOC
	EmocParkLocation *string `json:"emocParkLocation,omitempty"`

	// The Expected Time in Commission (ETIC) for this aircraft, in ISO 8601 UTC format
	Etic *time.Time `json:"etic,omitempty"`

	// Fuel remaining, in kilograms
	Fuel *int32 `json:"fuel,omitempty"`

	// Used in conjunction with the fuel field to indicate either burnable or offload fuel
	FuelFunction *string `json:"fuelFunction,omitempty"`

	// The state of the aircraft fuel status (e.g. Delivered, Dumped, Empty, Full, Other, Requested, etc.)
	FuelStatus *string `json:"fuelStatus,omitempty"`

	// The ground status of the aircraft (e.g. Alert, Crew Ready, Engine Start, Hangar, etc.)
	GroundStatus *string `json:"groundStatus,omitempty"`

	// Flag indicating that the aircraft is capable of making at least one gun pass
	GunCapable *bool `json:"gunCapable,omitempty"`

	// The upper bound of the estimated number of gun rounds available
	GunRdsMax *int32 `json:"gunRdsMax,omitempty"`

	// The lower bound of the estimated number of gun rounds available
	GunRdsMin *int32 `json:"gunRdsMin,omitempty"`

	// The type of gun rounds available (e.g. 7.62 MM, 20 MM, 25 MM, etc.)
	GunRdsType *string `json:"gunRdsType,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft.
	IdAircraft *string `json:"idAircraft,omitempty"`

	// If not airborne, the ID of the installation currently hosting the aircraft
	IdSite *string `json:"idSite,omitempty"`

	// Array of inventory item(s) for which estimate(s) are available (CONVENTIONAL DEPTH BOMB, SPECIAL DEPTH BOMB, CONVENTIONAL TORPEDO, SPECIAL TORPEDO, CONVENTIONAL MISSILE, SPECIAL MISSILE, ROCKET, ACTIVE SONOBUOY, PASSIVE SONOBUOY, CHAFF, FLARE).  This array must be the same length as inventoryMin and inventoryMax.
	Inventory *[]string `json:"inventory,omitempty"`

	// Array of the upper bound quantity for each of the inventory items.  The values in this array must correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMin
	InventoryMax *[]int32 `json:"inventoryMax,omitempty"`

	// Array of the lower bound quantity for each of the inventory items.  The values in this must array correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMax.
	InventoryMin *[]int32 `json:"inventoryMin,omitempty"`

	// The name or ID of the external user that updated this status
	LastUpdatedBy *string `json:"lastUpdatedBy,omitempty"`

	// The maintenance status of the aircraft
	MaintStatus *string `json:"maintStatus,omitempty"`

	// The time of the last maintenance status update, in ISO 8601 UTC format
	MaintStatusUpdate *time.Time `json:"maintStatusUpdate,omitempty"`

	// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
	MissionReadiness *AircraftStatusAbridgedMissionReadiness `json:"missionReadiness,omitempty"`

	// Optional notes/comments for the aircraft status
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The parking location of this aircraft as designated by PEX
	PexParkLocation *string `json:"pexParkLocation,omitempty"`

	// The Point Of Interest (POI) ID related to this platform. This will generally represent the location of an aircraft on the ground.
	Poiid *string `json:"poiid,omitempty"`

	// Alternate site Identifier of the current location of this aircraft provided by source
	SiteAltId *string `json:"siteAltId,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The turnaround start time, in ISO 8601 UTC format
	TaStartTime *time.Time `json:"taStartTime,omitempty"`

	// The track ID related to this platform, if available
	TrkId *string `json:"trkId,omitempty"`
}

// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusAbridgedAirToAirStatus string

// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusAbridgedAirToGroundStatus string

// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
type AircraftStatusAbridgedCurrentState string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftStatusAbridgedDataMode string

// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
type AircraftStatusAbridgedMissionReadiness string

// Aircraft readiness and status data. Contains the dynamic data associated with the specific aircraft status, either in-flight or on-ground, including remaining fuel, mission readiness, and inventory, etc.
type AircraftStatusFull struct {
	// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToAirStatus *AircraftStatusFullAirToAirStatus `json:"airToAirStatus,omitempty"`

	// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToGroundStatus *AircraftStatusFullAirToGroundStatus `json:"airToGroundStatus,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The contamination status of the aircraft (e.g. Clear, Contaminated, Decontaminated, Unknown, etc.)
	ContaminationStatus *string `json:"contaminationStatus,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
	CurrentState *AircraftStatusFullCurrentState `json:"currentState,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftStatusFullDataMode `json:"dataMode"`

	// The earliest time that turnaround of the aircraft may complete, in ISO 8601 UTC format
	EarliestTAEndTime *time.Time `json:"earliestTAEndTime,omitempty"`

	// The parking location of this aircraft as designated by EMOC
	EmocParkLocation *string `json:"emocParkLocation,omitempty"`

	// The Expected Time in Commission (ETIC) for this aircraft, in ISO 8601 UTC format
	Etic *time.Time `json:"etic,omitempty"`

	// Fuel remaining, in kilograms
	Fuel *int32 `json:"fuel,omitempty"`

	// Used in conjunction with the fuel field to indicate either burnable or offload fuel
	FuelFunction *string `json:"fuelFunction,omitempty"`

	// The state of the aircraft fuel status (e.g. Delivered, Dumped, Empty, Full, Other, Requested, etc.)
	FuelStatus *string `json:"fuelStatus,omitempty"`

	// The ground status of the aircraft (e.g. Alert, Crew Ready, Engine Start, Hangar, etc.)
	GroundStatus *string `json:"groundStatus,omitempty"`

	// Flag indicating that the aircraft is capable of making at least one gun pass
	GunCapable *bool `json:"gunCapable,omitempty"`

	// The upper bound of the estimated number of gun rounds available
	GunRdsMax *int32 `json:"gunRdsMax,omitempty"`

	// The lower bound of the estimated number of gun rounds available
	GunRdsMin *int32 `json:"gunRdsMin,omitempty"`

	// The type of gun rounds available (e.g. 7.62 MM, 20 MM, 25 MM, etc.)
	GunRdsType *string `json:"gunRdsType,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft.
	IdAircraft *string `json:"idAircraft,omitempty"`

	// If not airborne, the ID of the installation currently hosting the aircraft
	IdSite *string `json:"idSite,omitempty"`

	// Array of inventory item(s) for which estimate(s) are available (CONVENTIONAL DEPTH BOMB, SPECIAL DEPTH BOMB, CONVENTIONAL TORPEDO, SPECIAL TORPEDO, CONVENTIONAL MISSILE, SPECIAL MISSILE, ROCKET, ACTIVE SONOBUOY, PASSIVE SONOBUOY, CHAFF, FLARE).  This array must be the same length as inventoryMin and inventoryMax.
	Inventory *[]string `json:"inventory,omitempty"`

	// Array of the upper bound quantity for each of the inventory items.  The values in this array must correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMin
	InventoryMax *[]int32 `json:"inventoryMax,omitempty"`

	// Array of the lower bound quantity for each of the inventory items.  The values in this must array correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMax.
	InventoryMin *[]int32 `json:"inventoryMin,omitempty"`

	// The name or ID of the external user that updated this status
	LastUpdatedBy *string `json:"lastUpdatedBy,omitempty"`

	// The maintenance status of the aircraft
	MaintStatus *string `json:"maintStatus,omitempty"`

	// The time of the last maintenance status update, in ISO 8601 UTC format
	MaintStatusUpdate *time.Time `json:"maintStatusUpdate,omitempty"`

	// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
	MissionReadiness *AircraftStatusFullMissionReadiness `json:"missionReadiness,omitempty"`

	// Optional notes/comments for the aircraft status
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The parking location of this aircraft as designated by PEX
	PexParkLocation *string `json:"pexParkLocation,omitempty"`

	// The Point Of Interest (POI) ID related to this platform. This will generally represent the location of an aircraft on the ground.
	Poiid *string `json:"poiid,omitempty"`

	// Alternate site Identifier of the current location of this aircraft provided by source
	SiteAltId *string `json:"siteAltId,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The turnaround start time, in ISO 8601 UTC format
	TaStartTime *time.Time `json:"taStartTime,omitempty"`

	// The track ID related to this platform, if available
	TrkId *string `json:"trkId,omitempty"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusFullAirToAirStatus string

// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusFullAirToGroundStatus string

// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
type AircraftStatusFullCurrentState string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftStatusFullDataMode string

// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
type AircraftStatusFullMissionReadiness string

// Aircraft readiness and status data. Contains the dynamic data associated with the specific aircraft status, either in-flight or on-ground, including remaining fuel, mission readiness, and inventory, etc.
type AircraftStatusIngest struct {
	// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToAirStatus *AircraftStatusIngestAirToAirStatus `json:"airToAirStatus,omitempty"`

	// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
	AirToGroundStatus *AircraftStatusIngestAirToGroundStatus `json:"airToGroundStatus,omitempty"`

	// Alternate Aircraft Identifier provided by source
	AircraftAltId *string `json:"aircraftAltId,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The contamination status of the aircraft (e.g. Clear, Contaminated, Decontaminated, Unknown, etc.)
	ContaminationStatus *string `json:"contaminationStatus,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
	CurrentState *AircraftStatusIngestCurrentState `json:"currentState,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftStatusIngestDataMode `json:"dataMode"`

	// The earliest time that turnaround of the aircraft may complete, in ISO 8601 UTC format
	EarliestTAEndTime *time.Time `json:"earliestTAEndTime,omitempty"`

	// The parking location of this aircraft as designated by EMOC
	EmocParkLocation *string `json:"emocParkLocation,omitempty"`

	// The Expected Time in Commission (ETIC) for this aircraft, in ISO 8601 UTC format
	Etic *time.Time `json:"etic,omitempty"`

	// Fuel remaining, in kilograms
	Fuel *int32 `json:"fuel,omitempty"`

	// Used in conjunction with the fuel field to indicate either burnable or offload fuel
	FuelFunction *string `json:"fuelFunction,omitempty"`

	// The state of the aircraft fuel status (e.g. Delivered, Dumped, Empty, Full, Other, Requested, etc.)
	FuelStatus *string `json:"fuelStatus,omitempty"`

	// The ground status of the aircraft (e.g. Alert, Crew Ready, Engine Start, Hangar, etc.)
	GroundStatus *string `json:"groundStatus,omitempty"`

	// Flag indicating that the aircraft is capable of making at least one gun pass
	GunCapable *bool `json:"gunCapable,omitempty"`

	// The upper bound of the estimated number of gun rounds available
	GunRdsMax *int32 `json:"gunRdsMax,omitempty"`

	// The lower bound of the estimated number of gun rounds available
	GunRdsMin *int32 `json:"gunRdsMin,omitempty"`

	// The type of gun rounds available (e.g. 7.62 MM, 20 MM, 25 MM, etc.)
	GunRdsType *string `json:"gunRdsType,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the aircraft.
	IdAircraft *string `json:"idAircraft,omitempty"`

	// If not airborne, the ID of the installation currently hosting the aircraft
	IdSite *string `json:"idSite,omitempty"`

	// Array of inventory item(s) for which estimate(s) are available (CONVENTIONAL DEPTH BOMB, SPECIAL DEPTH BOMB, CONVENTIONAL TORPEDO, SPECIAL TORPEDO, CONVENTIONAL MISSILE, SPECIAL MISSILE, ROCKET, ACTIVE SONOBUOY, PASSIVE SONOBUOY, CHAFF, FLARE).  This array must be the same length as inventoryMin and inventoryMax.
	Inventory *[]string `json:"inventory,omitempty"`

	// Array of the upper bound quantity for each of the inventory items.  The values in this array must correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMin
	InventoryMax *[]int32 `json:"inventoryMax,omitempty"`

	// Array of the lower bound quantity for each of the inventory items.  The values in this must array correspond to position index in the inventory array.  This array must be the same length as inventory and inventoryMax.
	InventoryMin *[]int32 `json:"inventoryMin,omitempty"`

	// The name or ID of the external user that updated this status
	LastUpdatedBy *string `json:"lastUpdatedBy,omitempty"`

	// The maintenance status of the aircraft
	MaintStatus *string `json:"maintStatus,omitempty"`

	// The time of the last maintenance status update, in ISO 8601 UTC format
	MaintStatusUpdate *time.Time `json:"maintStatusUpdate,omitempty"`

	// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
	MissionReadiness *AircraftStatusIngestMissionReadiness `json:"missionReadiness,omitempty"`

	// Optional notes/comments for the aircraft status
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The parking location of this aircraft as designated by PEX
	PexParkLocation *string `json:"pexParkLocation,omitempty"`

	// The Point Of Interest (POI) ID related to this platform. This will generally represent the location of an aircraft on the ground.
	Poiid *string `json:"poiid,omitempty"`

	// Alternate site Identifier of the current location of this aircraft provided by source
	SiteAltId *string `json:"siteAltId,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The turnaround start time, in ISO 8601 UTC format
	TaStartTime *time.Time `json:"taStartTime,omitempty"`

	// The track ID related to this platform, if available
	TrkId *string `json:"trkId,omitempty"`
}

// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusIngestAirToAirStatus string

// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF)
type AircraftStatusIngestAirToGroundStatus string

// The current readiness state of the aircraft (AVAILABLE, SUITUP, BATTLESTATION, RUNWAYALERT, AIRBORNE)
type AircraftStatusIngestCurrentState string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftStatusIngestDataMode string

// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE)
type AircraftStatusIngestMissionReadiness string

// General aircraft designation, characteristics, and capabilities. The aircraft schema contains static data of specific aircraft, including tail number, cruise speed, max speed, and minimum required runway length, etc.
type AircraftAbridged struct {
	// The aircraft Model Design Series designation (e.g. FA-18, F-15C, etc.)
	AircraftMDS string `json:"aircraftMDS"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The cruise speed of the aircraft, in kilometers/hour
	CruiseSpeed *float64 `json:"cruiseSpeed,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftAbridgedDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityAbridged `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site to which this aircraft is assigned
	IdSite *string `json:"idSite,omitempty"`

	// The maximum air speed of the aircraft, in kilometers/hour
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The minimum length of runway required to land the aircraft, in meters
	MinReqRunway *int32 `json:"minReqRunway,omitempty"`

	// The nominal turnaround time for this aircraft, in minutes
	NominalTATime *int32 `json:"nominalTATime,omitempty"`

	// Optional notes/comments for this aircraft
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The tail number of this aircraft
	TailNumber *string `json:"tailNumber,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftAbridgedDataMode string

// General aircraft designation, characteristics, and capabilities. The aircraft schema contains static data of specific aircraft, including tail number, cruise speed, max speed, and minimum required runway length, etc.
type AircraftFull struct {
	// The aircraft Model Design Series designation (e.g. FA-18, F-15C, etc.)
	AircraftMDS string `json:"aircraftMDS"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The cruise speed of the aircraft, in kilometers/hour
	CruiseSpeed *float64 `json:"cruiseSpeed,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftFullDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityFull `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site to which this aircraft is assigned
	IdSite *string `json:"idSite,omitempty"`

	// The maximum air speed of the aircraft, in kilometers/hour
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The minimum length of runway required to land the aircraft, in meters
	MinReqRunway *int32 `json:"minReqRunway,omitempty"`

	// The nominal turnaround time for this aircraft, in minutes
	NominalTATime *int32 `json:"nominalTATime,omitempty"`

	// Optional notes/comments for this aircraft
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The tail number of this aircraft
	TailNumber *string `json:"tailNumber,omitempty"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftFullDataMode string

// General aircraft designation, characteristics, and capabilities. The aircraft schema contains static data of specific aircraft, including tail number, cruise speed, max speed, and minimum required runway length, etc.
type AircraftIngest struct {
	// The aircraft Model Design Series designation (e.g. FA-18, F-15C, etc.)
	AircraftMDS string `json:"aircraftMDS"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The cruise speed of the aircraft, in kilometers/hour
	CruiseSpeed *float64 `json:"cruiseSpeed,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AircraftIngestDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityIngest `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site to which this aircraft is assigned
	IdSite *string `json:"idSite,omitempty"`

	// The maximum air speed of the aircraft, in kilometers/hour
	MaxSpeed *float64 `json:"maxSpeed,omitempty"`

	// The minimum length of runway required to land the aircraft, in meters
	MinReqRunway *int32 `json:"minReqRunway,omitempty"`

	// The nominal turnaround time for this aircraft, in minutes
	NominalTATime *int32 `json:"nominalTATime,omitempty"`

	// Optional notes/comments for this aircraft
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The tail number of this aircraft
	TailNumber *string `json:"tailNumber,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AircraftIngestDataMode string

// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
type AnalyticImageryAbridged struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
	AnnLims *[][]int32 `json:"annLims,omitempty"`

	// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
	AnnText *[]string `json:"annText,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
	ChecksumValue *string `json:"checksumValue,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
	Content string `json:"content"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data
	DataMode AnalyticImageryAbridgedDataMode `json:"dataMode"`

	// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
	DataStart *time.Time `json:"dataStart,omitempty"`

	// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
	DataStop *time.Time `json:"dataStop,omitempty"`

	// Description of the image content and utility.
	Description string `json:"description"`

	// The image file name.
	Filename string `json:"filename"`

	// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
	Filesize int64 `json:"filesize"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
	ImageSetId *string `json:"imageSetId,omitempty"`

	// The number of images in an image set.
	ImageSetLength *int32 `json:"imageSetLength,omitempty"`

	// The type of image associated with this record (GIF, JPG, PNG, TIF).
	ImageType string `json:"imageType"`

	// The image height (vertical), in pixels.
	ImgHeight *int32 `json:"imgHeight,omitempty"`

	// The image width (horizontal), in pixels.
	ImgWidth *int32 `json:"imgWidth,omitempty"`

	// Array of searchable keywords for this analytic imagery record.
	Keywords *[]string `json:"keywords,omitempty"`

	// The message time of this image record, in ISO8601 UTC format with millisecond precision.
	MsgTime time.Time `json:"msgTime"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
	SequenceId *int32 `json:"sequenceId,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
	XUnits *string `json:"xUnits,omitempty"`

	// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
	YUnits *string `json:"yUnits,omitempty"`

	// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
	ZUnits *string `json:"zUnits,omitempty"`
}

// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data
type AnalyticImageryAbridgedDataMode string

// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
type AnalyticImageryFull struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
	AnnLims *[][]int32 `json:"annLims,omitempty"`

	// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
	AnnText *[]string `json:"annText,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
	ChecksumValue *string `json:"checksumValue,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
	Content string `json:"content"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data
	DataMode AnalyticImageryFullDataMode `json:"dataMode"`

	// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
	DataStart *time.Time `json:"dataStart,omitempty"`

	// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
	DataStop *time.Time `json:"dataStop,omitempty"`

	// Description of the image content and utility.
	Description string `json:"description"`

	// The image file name.
	Filename string `json:"filename"`

	// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
	Filesize int64 `json:"filesize"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
	ImageSetId *string `json:"imageSetId,omitempty"`

	// The number of images in an image set.
	ImageSetLength *int32 `json:"imageSetLength,omitempty"`

	// The type of image associated with this record (GIF, JPG, PNG, TIF).
	ImageType string `json:"imageType"`

	// The image height (vertical), in pixels.
	ImgHeight *int32 `json:"imgHeight,omitempty"`

	// The image width (horizontal), in pixels.
	ImgWidth *int32 `json:"imgWidth,omitempty"`

	// Array of searchable keywords for this analytic imagery record.
	Keywords *[]string `json:"keywords,omitempty"`

	// The message time of this image record, in ISO8601 UTC format with millisecond precision.
	MsgTime time.Time `json:"msgTime"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
	SequenceId *int32 `json:"sequenceId,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
	XUnits *string `json:"xUnits,omitempty"`

	// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
	YUnits *string `json:"yUnits,omitempty"`

	// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
	ZUnits *string `json:"zUnits,omitempty"`
}

// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data
type AnalyticImageryFullDataMode string

// Detailed information for a spacecraft communication antenna. One antenna may have multiple AntennaDetails records, compiled by various sources.
type AntennaDetailsFull struct {
	// Boolean indicating if this is a beam forming antenna
	BeamForming *bool `json:"beamForming,omitempty"`

	// Array of angles between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaDetailsFullDataMode `json:"dataMode"`

	// Antenna description
	Description *string `json:"description,omitempty"`

	// Antenna diameter in meters
	Diameter *float64 `json:"diameter,omitempty"`

	// Antenna end of frequency range in Mhz
	EndFrequency *float64 `json:"endFrequency,omitempty"`

	// Antenna maximum gain in dBi
	Gain *float64 `json:"gain,omitempty"`

	// Antenna gain tolerance in dB
	GainTolerance *float64 `json:"gainTolerance,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Antenna
	IdAntenna string `json:"idAntenna"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the antenna
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Antenna mode (e.g. TX,RX)
	Mode *AntennaDetailsFullMode `json:"mode,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Antenna polarization in degrees
	Polarization *float64 `json:"polarization,omitempty"`

	// Antenna position (e.g. Top, Nadir, Side)
	Position *string `json:"position,omitempty"`

	// Array with 1-2 values specifying the length and width (for rectangular) and just length for dipole antennas in meters
	Size *[]float64 `json:"size,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Antenna start of frequency range in Mhz
	StartFrequency *float64 `json:"startFrequency,omitempty"`

	// Boolean indicating if this antenna is steerable
	Steerable *bool `json:"steerable,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of antenna (e.g. Reflector, Double Reflector, Shaped Reflector, Horn, Parabolic, etc.)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaDetailsFullDataMode string

// Antenna mode (e.g. TX,RX)
type AntennaDetailsFullMode string

// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
type AntennaFull struct {
	// Read-only collection of additional AntennaDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/antennadetails operations.
	AntennaDetails *[]AntennaDetailsFull `json:"antennaDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Antenna name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AntennaFullDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataAbridged struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataAbridgedDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataFull struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataFullDataMode string

// These services provide operations for posting and querying attitude of on-orbit objects.  Attitude describes the orientation of an object, which can be represented by quaternions or euler angles.  The AttitudeSet ID (asId) identifies the 'AttitudeSet' record which contains details of the underlying data as well as a collection of attitude points. Points must be retrieved by first identifying a desired AttitudeSet and pulling its points by that AttitudeSet ID 'asId.'
type AttitudeDataIngest struct {
	// Unique identifier of the parent AttitudeSet associated with this record.
	AsId string `json:"asId"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeDataIngestDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude record applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude record. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Quaternion vector component 1.
	Q1 *float64 `json:"q1,omitempty"`

	// Derivative of quaternion vector component 1.
	Q1Dot *float64 `json:"q1Dot,omitempty"`

	// Quaternion vector component 2.
	Q2 *float64 `json:"q2,omitempty"`

	// Derivative of quaternion vector component 2.
	Q2Dot *float64 `json:"q2Dot,omitempty"`

	// Quaternion vector component 3.
	Q3 *float64 `json:"q3,omitempty"`

	// Derivative of quaternion vector component 3.
	Q3Dot *float64 `json:"q3Dot,omitempty"`

	// Quaternion scalar component.
	Qc *float64 `json:"qc,omitempty"`

	// Derivative of quaternion scalar component.
	QcDot *float64 `json:"qcDot,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude record applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Time associated with this attitude record, in ISO 8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// Array of X body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	XAngle *[]float64 `json:"xAngle,omitempty"`

	// Array of X body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	XRate *[]float64 `json:"xRate,omitempty"`

	// Array of Y body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	YAngle *[]float64 `json:"yAngle,omitempty"`

	// Array of Y body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence.  Attitude rates are expressed in frame1 with respect to frame2.
	YRate *[]float64 `json:"yRate,omitempty"`

	// Array of Z body rotation Euler angle(s), in degrees (-180 to 180).  For repeated axis rotations, the array elements should be placed in the order that the angles apply in the sequence.
	ZAngle *[]float64 `json:"zAngle,omitempty"`

	// Array of Z body rotation rate(s), in degrees per second.  For repeated axis rotations, the array elements should be placed in the order that the rates apply in the sequence  Attitude rates are expressed in frame1 with respect to frame2.
	ZRate *[]float64 `json:"zRate,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeDataIngestDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetAbridgedDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetAbridgedDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetFull struct {
	// Array of UDL UUIDs of one or more AttitudeSet records associated with this set.  For example, a spacecraft Attitude Ephemeris Set might include a reference to an Attitude Parameter Message defining the sensor to body frame transformation for a sensor onboard the spacecraft, which allows for calculation of the sensor orientation in frame2 of the attitude ephemeris.
	AsRef *[]string `json:"asRef,omitempty"`

	// Collection of attitude data associated with this Attitude Set
	AttitudeList *[]AttitudeDataFull `json:"attitudeList,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetFullDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetFullDataMode string

// AttitudeSet represents a wrapper or collection of Onorbit Attitude 'points' and meta data indicating the specifics of the orientation of an on-orbit object.  Attitude is typically distributed in a flat file containing details of the attitude generation as well as a large collection of individual points at varying time steps. AttitudeSet is analogous to this flat file.
type AttitudeSetIngest struct {
	// Array of UDL UUIDs of one or more AttitudeSet records associated with this set.  For example, a spacecraft Attitude Ephemeris Set might include a reference to an Attitude Parameter Message defining the sensor to body frame transformation for a sensor onboard the spacecraft, which allows for calculation of the sensor orientation in frame2 of the attitude ephemeris.
	AsRef *[]string `json:"asRef,omitempty"`

	// Collection of attitude data associated with this Attitude Set
	AttitudeList *[]AttitudeDataIngest `json:"attitudeList,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode AttitudeSetIngestDataMode `json:"dataMode"`

	// The end time of the attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single epoch attitude message then endTime should match the startTime.
	EndTime time.Time `json:"endTime"`

	// Unique identifier of the parent (positional) Ephemeris Set, if this data is correlated with an Ephemeris.
	EsId *string `json:"esId,omitempty"`

	// The rotation sequence of the Euler angles in which attitude reference frame transformation occurs (from left to right). One, two, or three axis rotations are supported and are represented by one, two, or three characters respectively.  Repeated axis rotations are also supported, however, these rotations should not be sequential.  The numeric sequence values correspond to the body angles/rates as follows: 1 - xAngle/xRate, 2 - yAngle/yRate, and 3 - zAngle/zRate.  Valid sequences are: 123, 132, 213, 231, 312, 321, 121, 131, 212, 232, 313, 323, 12, 13, 21, 23, 31, 32, 1, 2, and 3.
	//
	//
	//
	// The following represent examples of possible rotation sequences:  A single rotation about the Y-axis can be expressed as '2', a double rotation with X-Z sequence can be expressed as '13', and a triple rotation with Z-X-Y sequence can be expressed as '312'.
	EulerRotSeq *string `json:"eulerRotSeq,omitempty"`

	// Reference frame 1 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame1 string `json:"frame1"`

	// Reference frame 2 of the quaternion or Euler angle transformation utilized in this attitude parameter or attitude ephemeris.  The UDL convention is that transformations occur FROM frame1 TO frame2.  A specific spacecraft frame or instrument name may be provided with the assumption the consumer understands the location of these frames (ex. SC BODY, J2000, LVLH, ICRF, INSTRUMENTx, THRUSTERx, etc.).
	Frame2 string `json:"frame2"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite to which this attitude set applies.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the sensor to which this attitude set applies IF this set is reporting a single sensor orientation.
	IdSensor *string `json:"idSensor,omitempty"`

	// Recommended interpolation method for estimating attitude ephemeris data.
	Interpolator *string `json:"interpolator,omitempty"`

	// Recommended polynomial interpolation degree.
	InterpolatorDegree *int32 `json:"interpolatorDegree,omitempty"`

	// Optional notes/comments for this attitude set.
	Notes *string `json:"notes,omitempty"`

	// Number of attitude records contained in this set.
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by the record source to indicate the target object of this attitude set. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Optional identifier provided by the record source to indicate the sensor identifier to which this attitude set applies IF this set is reporting a single sensor orientation. This may be an internal identifier and not necessarily a valid sensor ID.
	OrigSensorId *string `json:"origSensorId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/catalog number of the on-orbit object to which this attitude set applies.
	SatNo *int32 `json:"satNo,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch.
	StartTime time.Time `json:"startTime"`

	// Attitude ephemeris step size, in seconds. This applies to Attitude Ephemeris Messages (AEM) that employ a fixed step size.
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type of attitude message or messages associated with this set.
	//
	// AEM = Attitude Ephemeris Message, specifying the attitude state of a single object at multiple epochs.
	//
	// APM = Attitude Parameters Message, specifying the attitude state of a single object at a single epoch.
	Type string `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type AttitudeSetIngestDataMode string

// Detailed information on a spacecraft battery type compiled by a particular source. A Battery record may have multiple details records from several sources.
type BatteryDetailsFull struct {
	// Battery capacity in Ah
	Capacity *float64 `json:"capacity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryDetailsFullDataMode `json:"dataMode"`

	// Battery description/notes
	Description *string `json:"description,omitempty"`

	// Depth of discharge as a percentage/fraction
	DischargeDepth *float64 `json:"dischargeDepth,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent battery type record
	IdBattery string `json:"idBattery"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the battery
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Battery model number or name
	Model *string `json:"model,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Type of battery technology (e.g. Ni-Cd, Ni-H2, Li-ion, etc.)
	Technology *string `json:"technology,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryDetailsFullDataMode string

// Model representation of specific spacecraft battery types
type BatteryFull struct {
	// Read-only collection of additional BatteryDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/batterydetails operations.
	BatteryDetails *[]BatteryDetailsFull `json:"batteryDetails,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode BatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Battery name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type BatteryFullDataMode string

// Schema for the CotChatData to post.
type CotChatDataIngest struct {
	// Contents of a chat message
	ChatMsg *string `json:"chatMsg,omitempty"`

	// Chat room name to send chat message to
	ChatRoom *string `json:"chatRoom,omitempty"`

	// Callsign of chat sender
	ChatSenderCallSign *string `json:"chatSenderCallSign,omitempty"`
}

// Schema for the CotData to post.
type CotDataIngest struct {
	// Point height above ellipsoid (WGS-84), in meters
	Alt *float64 `json:"alt,omitempty"`

	// Optional list of call signs to send message to directly
	CallSigns *[]string `json:"callSigns,omitempty"`

	// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error)
	Ce *float64 `json:"ce,omitempty"`

	// Schema for the CotChatData to post.
	CotChatData *CotChatDataIngest `json:"cotChatData,omitempty"`

	// Schema for the CotPositionData to post.
	CotPositionData *CotPositionDataIngest `json:"cotPositionData,omitempty"`

	// Optional set of groups to send message to specifically.  If not specified, the message will be sent to the default _ANON_ group
	Groups *[]string `json:"groups,omitempty"`

	// How the event point was generated, in CoT object heirarchy notation (optional, CoT)
	How *string `json:"how,omitempty"`

	// WGS-84 latitude of the POI, in degrees (+N, -S), -90 to 90
	Lat float64 `json:"lat"`

	// Height above lat/lon point, in meters (1-sigma, if representing linear error)
	Le *float64 `json:"le,omitempty"`

	// WGS-84 longitude of the POI, in degrees (+E, -W), -180 to 180
	Lon float64 `json:"lon"`

	// Identifier of the sender of the cot message which should remain the same on subsequent POI records of the same point of interest
	SenderUid *string `json:"senderUid,omitempty"`

	// Stale timestamp (optional), in ISO8601 UTC format
	Stale *time.Time `json:"stale,omitempty"`

	// Start time of event validity (optional), in ISO8601 UTC format
	Start *time.Time `json:"start,omitempty"`

	// Event type, in CoT object heirarchy notation (optional, CoT)
	Type *string `json:"type,omitempty"`

	// Optional list of TAK user ids to send message to directly
	Uids *[]string `json:"uids,omitempty"`
}

// Schema for the CotPositionData to post.
type CotPositionDataIngest struct {
	// Name of the POI target Object
	CallSign string `json:"callSign"`

	// Description of the POI target Object
	Team string `json:"team"`

	// Team role  (Team Member| Team Lead | HQ | Sniper | Medic | Forward Observer | RTO | K9)
	TeamRole string `json:"teamRole"`
}

// DataMode defines model for DataMode.
type DataMode string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetAbridged struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetAbridgedDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetAbridgedDataMode string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetFull struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// Read-only start time at which this elset was the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// Read-only end time at which this elset was no longer the 'current' elset for its satellite. This field and is set by the system automatically and ignored on create/edit operations.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetFullDataMode string

// ElsetFullSourcedDataTypes defines model for ElsetFull.SourcedDataTypes.
type ElsetFullSourcedDataTypes string

// An element set is a collection of Keplerian orbital elements describing an orbit of a particular satellite. The data is used along with an orbit propagator in order to predict the motion of a satellite. The element set, or elset for short, consists of identification data, the classical elements and drag parameters.
type ElsetIngest struct {
	// AGOM, expressed in m^2/kg, is the value of the (averaged) object Area times the solar radiation pressure coefficient(Gamma) over the object Mass. Applicable only with ephemType4
	Agom *float64 `json:"agom,omitempty"`

	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// The orbit point furthest from the center of the earth in kilometers. If not provided, apogee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, apogee = (A * (1 + E)) in km. Note that the calculations are for computing the apogee radius from the center of the earth, to compute apogee altitude the radius of the earth should be subtracted (6378.135 km).
	Apogee *float64 `json:"apogee,omitempty"`

	// The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
	ArgOfPerigee *float64 `json:"argOfPerigee,omitempty"`

	// The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
	BStar *float64 `json:"bStar,omitempty"`

	// Ballistic coefficient, in m^2/kg. Applicable only with ephemType4.
	BallisticCoeff *float64 `json:"ballisticCoeff,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode ElsetIngestDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
	Eccentricity *float64 `json:"eccentricity,omitempty"`

	// The ephemeris type associated with this TLE:
	//
	// 0:&nbsp;SGP4 if orbital period&nbsp;&lt;&nbsp;225 minutes, and SDP4 otherwise
	//
	// 1:&nbsp;SGP
	//
	// 2:&nbsp;SGP4
	//
	// 3:&nbsp;SDP4
	//
	// 4:&nbsp;SGP8, also referred to as SGP4-XP
	//
	// 5:&nbsp;SDP8
	//
	EphemType *int32 `json:"ephemType,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// Unique identifier of the record, auto-generated by the system
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
	Inclination *float64 `json:"inclination,omitempty"`

	// Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line1 *string `json:"line1,omitempty"`

	// Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations
	Line2 *string `json:"line2,omitempty"`

	// Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
	MeanAnomaly *float64 `json:"meanAnomaly,omitempty"`

	// Mean motion is the angular speed required for a body to complete one orbit, assuming constant speed in a circular orbit which completes in the same time as the variable speed, elliptical orbit of the actual body. Measured in revolutions per day.
	MeanMotion *float64 `json:"meanMotion,omitempty"`

	// 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
	MeanMotionDDot *float64 `json:"meanMotionDDot,omitempty"`

	// 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
	MeanMotionDot *float64 `json:"meanMotionDot,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by elset source to indicate the target onorbit object of this elset. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The orbit point nearest to the center of the earth in kilometers. If not provided, perigee will be computed from the TLE according to the following. Using mu, the standard gravitational parameter for the earth (398600.4418), semi-major axis A = (mu/(n * 2 * pi/(24*3600))^2)(1/3). Using semi-major axis A, eccentricity E, perigee = (A * (1 - E)) in km. Note that the calculations are for computing the perigee radius from the center of the earth, to compute perigee altitude the radius of the earth should be subtracted (6378.135 km).
	Perigee *float64 `json:"perigee,omitempty"`

	// Period of the orbit equal to inverse of mean motion, in minutes.
	Period *float64 `json:"period,omitempty"`

	// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
	Raan *float64 `json:"raan,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
	RevNo *int64 `json:"revNo,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass. Units are kilometers.
	SemiMajorAxis *float64 `json:"semiMajorAxis,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this element set. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this element set (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *ElsetIngestSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this Elset was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type ElsetIngestDataMode string

// ElsetIngestSourcedDataTypes defines model for ElsetIngest.SourcedDataTypes.
type ElsetIngestSourcedDataTypes string

// Known launch vehicle engine details and performance characteristics and limits compiled by a particular source.  A launch vehicle engine may have several details records from multiple sources.
type EngineDetailsFull struct {
	// Launch engine maximum burn time in seconds
	BurnTime *float64 `json:"burnTime,omitempty"`

	// Engine chamber pressure in bars
	ChamberPressure *float64 `json:"chamberPressure,omitempty"`

	// Engine characteristic type (e.g. Electric, Mono-propellant, Bi-propellant, etc.)
	CharacteristicType *string `json:"characteristicType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Engine cycle type (e.g. Electrostatic Ion, Pressure Fed, Hall, Catalytic Decomposition, etc.)
	CycleType *string `json:"cycleType,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineDetailsFullDataMode `json:"dataMode"`

	// Engine type or family
	Family *string `json:"family,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the parent engine record
	IdEngine string `json:"idEngine"`

	// Organization ID of the engine manufacturer
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// Engine maximum number of firings
	MaxFirings *int32 `json:"maxFirings,omitempty"`

	// Notes/Description of the engine
	Notes *string `json:"notes,omitempty"`

	// Engine nozzle expansion ratio
	NozzleExpansionRatio *float64 `json:"nozzleExpansionRatio,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Oxidizer type (e.g. Nitrogen Tetroxide, Liquid Oxygen, etc)
	Oxidizer *string `json:"oxidizer,omitempty"`

	// Propellant/fuel type of the engine (e.g. Liquid Hydrogen, Kerosene, Aerozine, etc).
	Propellant *string `json:"propellant,omitempty"`

	// Engine maximum thrust at sea level in Kilo-Newtons
	SeaLevelThrust *float64 `json:"seaLevelThrust,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Launch engine specific impulse in seconds
	SpecificImpulse *float64 `json:"specificImpulse,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Engine maximum thrust in a vacuum in Kilo-Newtons
	VacuumThrust *float64 `json:"vacuumThrust,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineDetailsFullDataMode string

// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
type EngineFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EngineFullDataMode `json:"dataMode"`

	// Read-only collection of additional EngineDetails by various sources for this engine, ignored on create/update. These details must be created separately via the /udl/enginedetails operations.
	EngineDetails *[]EngineDetailsFull `json:"engineDetails,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Engine name/variant
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EngineFullDataMode string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationAbridged `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitAbridged `json:"onOrbit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityAbridgedOwnerType `json:"ownerType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityAbridgedType `json:"type"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityAbridgedDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityAbridgedOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityAbridgedType string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityFullDataMode `json:"dataMode"`

	// Unique identifier of the record
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
	OperatingUnit *OperatingunitFull `json:"operatingUnit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityFullOwnerType `json:"ownerType,omitempty"`

	// Read-only collection of RF bands utilized by this entity for communication and/or operation
	RfBands *[]RFBandFull `json:"rfBands,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of statuses which can be collected by multiple sources
	StatusCollection *[]StatusFull `json:"statusCollection,omitempty"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityFullType `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// List of URLs to additional details/documents for this entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityFullDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityFullOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityFullType string

// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
type EntityIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country or consortium code as reported by 18th SPCS.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EntityIngestDataMode `json:"dataMode"`

	// Unique identifier of the record
	IdEntity *string `json:"idEntity,omitempty"`

	// Unique identifier of the entity location, if terrestrial/fixed.
	IdLocation *string `json:"idLocation,omitempty"`

	// Onorbit identifier if this entity is part of an on-orbit object. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the associated operating unit object
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationIngest `json:"location,omitempty"`

	// Unique entity name
	Name string `json:"name"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitIngest `json:"onOrbit,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
	OwnerType *EntityIngestOwnerType `json:"ownerType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Boolean indicating if this entity is taskable
	Taskable *bool `json:"taskable,omitempty"`

	// Type of entity (e.g. SENSOR, ONORBIT, etc).
	Type EntityIngestType `json:"type"`

	// List of URLs to additional details/documents for this entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EntityIngestDataMode string

// Type of organization which owns this entity (e.g. Commercial, Government, Academic, Consortium, etc)
type EntityIngestOwnerType string

// Type of entity (e.g. SENSOR, ONORBIT, etc).
type EntityIngestType string

// EphemFormatType defines model for EphemFormatType.
type EphemFormatType string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetAbridged struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetAbridgedCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetAbridgedDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetAbridgedReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetAbridgedDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetAbridgedReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetFull struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetFullDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisFull `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
	StateVector *StateVectorFull `json:"stateVector,omitempty"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetFullReferenceFrame string

// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
type EphemerisSetIngest struct {
	// First derivative of ballistic coefficient (m^2/kg-s)
	BDot *float64 `json:"bDot,omitempty"`

	// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL)
	Category string `json:"category"`

	// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated
	CentBody *string `json:"centBody,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *EphemerisSetIngestCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, in UTC
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisSetIngestDataMode `json:"dataMode"`

	// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
	Description *string `json:"description,omitempty"`

	// Optional source-provided and searchable metadata or descriptor of the data
	Descriptor *string `json:"descriptor,omitempty"`

	// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR), expressed in w/kg
	Edr *float64 `json:"edr,omitempty"`

	// Ephemeris associated with this Ephemeris
	EphemerisList *[]EphemerisIngest `json:"ephemerisList,omitempty"`

	// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the'EphemerisSet' OpenAPI docs.
	Filename *string `json:"filename,omitempty"`

	// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T)
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Boolean indicating whether acceleration data is provided with the ephemeris
	HasAccel *bool `json:"hasAccel,omitempty"`

	// Boolean indicating whether covariance data is provided with the ephemeris
	HasCov *bool `json:"hasCov,omitempty"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris
	HasMnvr *bool `json:"hasMnvr,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris
	IdManeuvers *[]string `json:"idManeuvers,omitempty"`

	// Unique identifier of the primary satellite on-orbit object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// ID of the State Vector used to generate the ephemeris
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY)
	Integrator *string `json:"integrator,omitempty"`

	// Boolean indicating use of lunar/solar data in ephemeris generation
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Number of points contained in the ephemeris
	NumPoints int32 `json:"numPoints"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID)
	Pedigree *string `json:"pedigree,omitempty"`

	// End time/last time point of the ephemeris, in ISO 8601 UTC format
	PointEndTime time.Time `json:"pointEndTime"`

	// Start time/first time point of the ephemeris, in ISO 8601 UTC format
	PointStartTime time.Time `json:"pointStartTime"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *EphemerisSetIngestReferenceFrame `json:"referenceFrame,omitempty"`

	// Satellite/catalog number of the target on-orbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Boolean indicating use of solid earth tide data in ephemeris generation
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Ephemeris step size, in seconds
	StepSize *int32 `json:"stepSize,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// The type/purpose of the ephemeris (e.g. LAUNCH, ROUTINE, MNVR_PLAN, SCREENING)
	Type string `json:"type"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type EphemerisSetIngestCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisSetIngestDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type EphemerisSetIngestReferenceFrame string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisAbridgedDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisFullDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisFullDataMode string

// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID ('esId')
type EphemerisIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EphemerisIngestDataMode `json:"dataMode"`

	// Unique identifier of the parent EphemerisSet
	EsId string `json:"esId"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the on-orbit satellite object
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time associated with the Ephemeris Point, in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xaccel *float64 `json:"xaccel,omitempty"`

	// Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos float64 `json:"xpos"`

	// Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel float64 `json:"xvel"`

	// Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yaccel *float64 `json:"yaccel,omitempty"`

	// Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos float64 `json:"ypos"`

	// Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel float64 `json:"yvel"`

	// Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zaccel *float64 `json:"zaccel,omitempty"`

	// Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
	Zpos float64 `json:"zpos"`

	// Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel float64 `json:"zvel"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EphemerisIngestDataMode string

// Event Evolution is a unique service supporting the association of UDL records of various data types to a common event or activity. The associations may be a one time summary, aggregating sources of a past event, or of an ongoing activity that evolves over a period of time.
type EventEvolutionAbridged struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The activity or event type associated with this record (e.g. BREAKUP, DIRECT FIRE, IED, LAUNCH, PROTEST, etc.). For Significant Activities, recommended but not constrained to, CAMEO.Manual.1.1b3 Chapter 6. Note that the evolution of an event may incorporate records of various types, for example, a LAUNCH event may evolve into a BREAKUP event.
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// The country code for the country with which the activity or event is associated.  This may be the country in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional description of the relationship between the records provided in the srcTyps/srcIds and the activity or event.
	DataDescription *string `json:"dataDescription,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EventEvolutionAbridgedDataMode `json:"dataMode"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId string `json:"eventId"`

	// Administrative boundaries of the first sub-national level. Level 1 is simply the largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the state/province in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel1 *string `json:"geoAdminLevel1,omitempty"`

	// Administrative boundaries of the second sub-national level. Level 2 is simply the second largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the city/district in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel2 *string `json:"geoAdminLevel2,omitempty"`

	// Administrative boundaries of the third sub-national level. Level 3 is simply the third largest demarcation under whatever demarcation criteria has been determined by the governing body.
	GeoAdminLevel3 *string `json:"geoAdminLevel3,omitempty"`

	// Unique identifier of the record, auto-generated by the system.
	Id *string `json:"id,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Flag indicating that this record is for the purpose of redacting one or more previously specified records from association with this activity or event.  If this flag is set then all records indicated in srcTyps/srcIds should be removed from event association.
	Redact *bool `json:"redact,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Array of UUIDs of the UDL data records that are related to the determination of this activity or event. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this activity or event. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	StartTime time.Time `json:"startTime"`

	// The status of this activity or event.  (ACTIVE, CONCLUDED, UNKNOWN).
	Status *string `json:"status,omitempty"`

	// Summary or description of the activity or event.
	Summary string `json:"summary"`

	// List of URLs to before/after images of this point of interest entity
	Url *[]string `json:"url,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EventEvolutionAbridgedDataMode string

// Event Evolution is a unique service supporting the association of UDL records of various data types to a common event or activity. The associations may be a one time summary, aggregating sources of a past event, or of an ongoing activity that evolves over a period of time.
type EventEvolutionFull struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The activity or event type associated with this record (e.g. BREAKUP, DIRECT FIRE, IED, LAUNCH, PROTEST, etc.). For Significant Activities, recommended but not constrained to, CAMEO.Manual.1.1b3 Chapter 6. Note that the evolution of an event may incorporate records of various types, for example, a LAUNCH event may evolve into a BREAKUP event.
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// The country code for the country with which the activity or event is associated.  This may be the country in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional description of the relationship between the records provided in the srcTyps/srcIds and the activity or event.
	DataDescription *string `json:"dataDescription,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EventEvolutionFullDataMode `json:"dataMode"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId string `json:"eventId"`

	// Administrative boundaries of the first sub-national level. Level 1 is simply the largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the state/province in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel1 *string `json:"geoAdminLevel1,omitempty"`

	// Administrative boundaries of the second sub-national level. Level 2 is simply the second largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the city/district in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel2 *string `json:"geoAdminLevel2,omitempty"`

	// Administrative boundaries of the third sub-national level. Level 3 is simply the third largest demarcation under whatever demarcation criteria has been determined by the governing body.
	GeoAdminLevel3 *string `json:"geoAdminLevel3,omitempty"`

	// Unique identifier of the record, auto-generated by the system.
	Id *string `json:"id,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Flag indicating that this record is for the purpose of redacting one or more previously specified records from association with this activity or event.  If this flag is set then all records indicated in srcTyps/srcIds should be removed from event association.
	Redact *bool `json:"redact,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Array of UUIDs of the UDL data records that are related to the determination of this activity or event. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this activity or event. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	StartTime time.Time `json:"startTime"`

	// The status of this activity or event.  (ACTIVE, CONCLUDED, UNKNOWN).
	Status *string `json:"status,omitempty"`

	// Summary or description of the activity or event.
	Summary string `json:"summary"`

	// List of URLs to before/after images of this point of interest entity
	Url *[]string `json:"url,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EventEvolutionFullDataMode string

// Event Evolution is a unique service supporting the association of UDL records of various data types to a common event or activity. The associations may be a one time summary, aggregating sources of a past event, or of an ongoing activity that evolves over a period of time.
type EventEvolutionIngest struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The activity or event type associated with this record (e.g. BREAKUP, DIRECT FIRE, IED, LAUNCH, PROTEST, etc.). For Significant Activities, recommended but not constrained to, CAMEO.Manual.1.1b3 Chapter 6. Note that the evolution of an event may incorporate records of various types, for example, a LAUNCH event may evolve into a BREAKUP event.
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// The country code for the country with which the activity or event is associated.  This may be the country in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional description of the relationship between the records provided in the srcTyps/srcIds and the activity or event.
	DataDescription *string `json:"dataDescription,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode EventEvolutionIngestDataMode `json:"dataMode"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	EndTime *time.Time `json:"endTime,omitempty"`

	// User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId string `json:"eventId"`

	// Administrative boundaries of the first sub-national level. Level 1 is simply the largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the state/province in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel1 *string `json:"geoAdminLevel1,omitempty"`

	// Administrative boundaries of the second sub-national level. Level 2 is simply the second largest demarcation under whatever demarcation criteria has been determined by the governing body. For example this may be the city/district in which a terrestrial event takes place, or with which the event is attributed for non-localized or non-terrestrial activity.
	GeoAdminLevel2 *string `json:"geoAdminLevel2,omitempty"`

	// Administrative boundaries of the third sub-national level. Level 3 is simply the third largest demarcation under whatever demarcation criteria has been determined by the governing body.
	GeoAdminLevel3 *string `json:"geoAdminLevel3,omitempty"`

	// Unique identifier of the record, auto-generated by the system.
	Id *string `json:"id,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Flag indicating that this record is for the purpose of redacting one or more previously specified records from association with this activity or event.  If this flag is set then all records indicated in srcTyps/srcIds should be removed from event association.
	Redact *bool `json:"redact,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Array of UUIDs of the UDL data records that are related to the determination of this activity or event. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this activity or event. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The actual or estimated start time of the activity or event, in ISO 8601 UTC format.
	StartTime time.Time `json:"startTime"`

	// The status of this activity or event.  (ACTIVE, CONCLUDED, UNKNOWN).
	Status *string `json:"status,omitempty"`

	// Summary or description of the activity or event.
	Summary string `json:"summary"`

	// List of URLs to before/after images of this point of interest entity
	Url *[]string `json:"url,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type EventEvolutionIngestDataMode string

// A Hazard is a Chemical, Biological, Radiological, or Nuclear (CBRN) material exposured to a geographic area. Hazard includes optional information regarding the identity/type of the material, if known.
type HazardAbridged struct {
	// The (rounded) Mass Number of the material associated with this detection. The rounded value is the mass number of the most abundant isotope of the element.
	A *int32 `json:"a,omitempty"`

	// The radioactivity measurement of the material associated with this detection, in becquerels (Bq). One becquerel (Bq) is equal to one nuclear decay per second.
	Activity *float64 `json:"activity,omitempty"`

	// Array of the values that correspond to each of the alarms contained in alarms. The alarms and alarmValues arrays must contain the same number of elements.
	AlarmValues []float64 `json:"alarmValues"`

	// Array of the specific alarms associated with this detection. The alarms and alarmValues arrays must contain the same number of elements.
	Alarms []string `json:"alarms"`

	// The specific bottle ID associated with this detection.
	BottleId *string `json:"bottleId,omitempty"`

	// The CAS Registry Number, also referred to as CAS Number or CAS RN, associated with the this detection. The CAS Number is a unique numerical identifier assigned by the Chemical Abstracts Service (CAS), to every chemical substance described in the open scientific literature. It includes organic and inorganic compounds, minerals, isotopes, alloys, mixtures, and nonstructurable materials (UVCBs, substances of unknown or variable composition, complex reaction products, or biological origin). For further information, reference https://www.cas.org/cas-data/cas-registry.
	CasRN *string `json:"casRN,omitempty"`

	// The applicable channel involved in this biological material detection (e.g. Digestive, Eyes, Respiratory, Skin, etc.) .
	Channel *string `json:"channel,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The concentration time, in (kg/sec)/m^3, associated with this material detection.
	CtrnTime *float64 `json:"ctrnTime,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode HazardAbridgedDataMode `json:"dataMode"`

	// Measure of density of the material associated with this detection, in kg/m^3.
	Density *float64 `json:"density,omitempty"`

	// The deposition measurement of the contaminant to surface area, in kg/m^2.
	Dep *float64 `json:"dep,omitempty"`

	// The deposition concentration of the contaminant to surface area, in becquerels/m^2.
	DepCtrn *float64 `json:"depCtrn,omitempty"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision.
	DetectTime time.Time `json:"detectTime"`

	// The type of hazard (Chemical, Biological, Radiological, Nuclear) detect associated with this record.
	DetectType string `json:"detectType"`

	// The dose associated with this detection, in gray. Dose is the measure of the energy deposited in matter by ionizing radiation per unit mass. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	Dose *float64 `json:"dose,omitempty"`

	// The dose rate associated with this detection, in gray/sec. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	DoseRate *float64 `json:"doseRate,omitempty"`

	// The known or projected hazard duration, in seconds, associated with this material detection.
	Duration *int32 `json:"duration,omitempty"`

	// Chemical Agent Monitor (CAM) G-type agent measurement, in number of display bars. In G-mode, CAMs monitor for G-series nerve agents.
	GBar *float64 `json:"gBar,omitempty"`

	// Chemical Agent Monitor (CAM) H-type agent measurement, in number of display bars. In H-mode, CAMs monitor for blister agents.
	HBar *float64 `json:"hBar,omitempty"`

	// Flag indicating whether this detection is harmful to humans.
	Harmful *bool `json:"harmful,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Point of Interest (POI) record related to this hazard record.
	IdPOI *string `json:"idPOI,omitempty"`

	// ID of the Track record related to this hazard record.
	IdTrack *string `json:"idTrack,omitempty"`

	// Ratio of the chemical substance mass to the total mass of the mixture.
	MassFrac *float64 `json:"massFrac,omitempty"`

	// The Radiological Category (1 - 5) which applies to the material associated with this detection, according to the following definitions:
	//
	// Category 1: If not safely or securely managed, would be likely to cause permanent injury to a person who handled them or was otherwise in contact with them for more than a few minutes. It would probably be fatal to be close to this amount of unshielded material for a period of a few minutes to an hour.
	//
	// Category 2: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for a short time (minutes to hours). It could possibly be fatal to be close to this amount of unshielded radioactive material for a period of hours to days.
	//
	// Category 3: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for hours. It could possibly - although it is unlikely to be - fatal to be close to this amount of unshielded radioactive material for a period of days to weeks.
	//
	// Category 4: If not safely managed or securely protected, could possibly cause temporary injury to someone who handled them or was otherwise in contact with or close to them for a period of many weeks, though this is unlikely. It is very unlikely anyone would be permanently injured by this amount of radioactive material.
	//
	// Category 5: Cannot cause permanent injury. This category applies to x-ray fluorescence devices and electron capture devices.
	MatCat *int32 `json:"matCat,omitempty"`

	// The specific Material Class for the material associated with this detect. The material class is generally associated with chemical and biological detections.
	MatClass *string `json:"matClass,omitempty"`

	// The material common name associated with this detection.
	MatName *string `json:"matName,omitempty"`

	// The specific material type (MT) or MT Code involved in this detection, when applicable. The material type is generally associated with radiological and/or nuclear detections. For further information, reference Nuclear Materials Management and Safeguards System (NMMSS) Users GuideRev. 2.1.
	MatType *string `json:"matType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Measure of the concentration of the material associated with this detection, in parts per million (units of contaminant mass per million parts of total mass).
	Ppm *int32 `json:"ppm,omitempty"`

	// Measure of radioactive concentration of the material associated with this detection, in becquerels/m^3. One becquerel (Bq) is equal to one nuclear decay per second.
	RadCtrn *float64 `json:"radCtrn,omitempty"`

	// Array of the units that correspond to each of the readingValues. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingUnits *[]string `json:"readingUnits,omitempty"`

	// Array of the values that correspond to each of the readings contained in readings. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingValues *[]float64 `json:"readingValues,omitempty"`

	// Array of the specific readings associated with this detection. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	Readings *[]string `json:"readings,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The Atomic Number of the material associated with this detection.
	Z *int32 `json:"z,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type HazardAbridgedDataMode string

// A Hazard is a Chemical, Biological, Radiological, or Nuclear (CBRN) material exposured to a geographic area. Hazard includes optional information regarding the identity/type of the material, if known.
type HazardFull struct {
	// The (rounded) Mass Number of the material associated with this detection. The rounded value is the mass number of the most abundant isotope of the element.
	A *int32 `json:"a,omitempty"`

	// The radioactivity measurement of the material associated with this detection, in becquerels (Bq). One becquerel (Bq) is equal to one nuclear decay per second.
	Activity *float64 `json:"activity,omitempty"`

	// Array of the values that correspond to each of the alarms contained in alarms. The alarms and alarmValues arrays must contain the same number of elements.
	AlarmValues []float64 `json:"alarmValues"`

	// Array of the specific alarms associated with this detection. The alarms and alarmValues arrays must contain the same number of elements.
	Alarms []string `json:"alarms"`

	// The specific bottle ID associated with this detection.
	BottleId *string `json:"bottleId,omitempty"`

	// The CAS Registry Number, also referred to as CAS Number or CAS RN, associated with the this detection. The CAS Number is a unique numerical identifier assigned by the Chemical Abstracts Service (CAS), to every chemical substance described in the open scientific literature. It includes organic and inorganic compounds, minerals, isotopes, alloys, mixtures, and nonstructurable materials (UVCBs, substances of unknown or variable composition, complex reaction products, or biological origin). For further information, reference https://www.cas.org/cas-data/cas-registry.
	CasRN *string `json:"casRN,omitempty"`

	// The applicable channel involved in this biological material detection (e.g. Digestive, Eyes, Respiratory, Skin, etc.) .
	Channel *string `json:"channel,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The concentration time, in (kg/sec)/m^3, associated with this material detection.
	CtrnTime *float64 `json:"ctrnTime,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode HazardFullDataMode `json:"dataMode"`

	// Measure of density of the material associated with this detection, in kg/m^3.
	Density *float64 `json:"density,omitempty"`

	// The deposition measurement of the contaminant to surface area, in kg/m^2.
	Dep *float64 `json:"dep,omitempty"`

	// The deposition concentration of the contaminant to surface area, in becquerels/m^2.
	DepCtrn *float64 `json:"depCtrn,omitempty"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision.
	DetectTime time.Time `json:"detectTime"`

	// The type of hazard (Chemical, Biological, Radiological, Nuclear) detect associated with this record.
	DetectType string `json:"detectType"`

	// The dose associated with this detection, in gray. Dose is the measure of the energy deposited in matter by ionizing radiation per unit mass. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	Dose *float64 `json:"dose,omitempty"`

	// The dose rate associated with this detection, in gray/sec. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	DoseRate *float64 `json:"doseRate,omitempty"`

	// The known or projected hazard duration, in seconds, associated with this material detection.
	Duration *int32 `json:"duration,omitempty"`

	// Chemical Agent Monitor (CAM) G-type agent measurement, in number of display bars. In G-mode, CAMs monitor for G-series nerve agents.
	GBar *float64 `json:"gBar,omitempty"`

	// Chemical Agent Monitor (CAM) H-type agent measurement, in number of display bars. In H-mode, CAMs monitor for blister agents.
	HBar *float64 `json:"hBar,omitempty"`

	// Flag indicating whether this detection is harmful to humans.
	Harmful *bool `json:"harmful,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Point of Interest (POI) record related to this hazard record.
	IdPOI *string `json:"idPOI,omitempty"`

	// ID of the Track record related to this hazard record.
	IdTrack *string `json:"idTrack,omitempty"`

	// Ratio of the chemical substance mass to the total mass of the mixture.
	MassFrac *float64 `json:"massFrac,omitempty"`

	// The Radiological Category (1 - 5) which applies to the material associated with this detection, according to the following definitions:
	//
	// Category 1: If not safely or securely managed, would be likely to cause permanent injury to a person who handled them or was otherwise in contact with them for more than a few minutes. It would probably be fatal to be close to this amount of unshielded material for a period of a few minutes to an hour.
	//
	// Category 2: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for a short time (minutes to hours). It could possibly be fatal to be close to this amount of unshielded radioactive material for a period of hours to days.
	//
	// Category 3: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for hours. It could possibly - although it is unlikely to be - fatal to be close to this amount of unshielded radioactive material for a period of days to weeks.
	//
	// Category 4: If not safely managed or securely protected, could possibly cause temporary injury to someone who handled them or was otherwise in contact with or close to them for a period of many weeks, though this is unlikely. It is very unlikely anyone would be permanently injured by this amount of radioactive material.
	//
	// Category 5: Cannot cause permanent injury. This category applies to x-ray fluorescence devices and electron capture devices.
	MatCat *int32 `json:"matCat,omitempty"`

	// The specific Material Class for the material associated with this detect. The material class is generally associated with chemical and biological detections.
	MatClass *string `json:"matClass,omitempty"`

	// The material common name associated with this detection.
	MatName *string `json:"matName,omitempty"`

	// The specific material type (MT) or MT Code involved in this detection, when applicable. The material type is generally associated with radiological and/or nuclear detections. For further information, reference Nuclear Materials Management and Safeguards System (NMMSS) Users GuideRev. 2.1.
	MatType *string `json:"matType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Measure of the concentration of the material associated with this detection, in parts per million (units of contaminant mass per million parts of total mass).
	Ppm *int32 `json:"ppm,omitempty"`

	// Measure of radioactive concentration of the material associated with this detection, in becquerels/m^3. One becquerel (Bq) is equal to one nuclear decay per second.
	RadCtrn *float64 `json:"radCtrn,omitempty"`

	// Array of the units that correspond to each of the readingValues. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingUnits *[]string `json:"readingUnits,omitempty"`

	// Array of the values that correspond to each of the readings contained in readings. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingValues *[]float64 `json:"readingValues,omitempty"`

	// Array of the specific readings associated with this detection. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	Readings *[]string `json:"readings,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The Atomic Number of the material associated with this detection.
	Z *int32 `json:"z,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type HazardFullDataMode string

// A Hazard is a Chemical, Biological, Radiological, or Nuclear (CBRN) material exposured to a geographic area. Hazard includes optional information regarding the identity/type of the material, if known.
type HazardIngest struct {
	// The (rounded) Mass Number of the material associated with this detection. The rounded value is the mass number of the most abundant isotope of the element.
	A *int32 `json:"a,omitempty"`

	// The radioactivity measurement of the material associated with this detection, in becquerels (Bq). One becquerel (Bq) is equal to one nuclear decay per second.
	Activity *float64 `json:"activity,omitempty"`

	// Array of the values that correspond to each of the alarms contained in alarms. The alarms and alarmValues arrays must contain the same number of elements.
	AlarmValues []float64 `json:"alarmValues"`

	// Array of the specific alarms associated with this detection. The alarms and alarmValues arrays must contain the same number of elements.
	Alarms []string `json:"alarms"`

	// The specific bottle ID associated with this detection.
	BottleId *string `json:"bottleId,omitempty"`

	// The CAS Registry Number, also referred to as CAS Number or CAS RN, associated with the this detection. The CAS Number is a unique numerical identifier assigned by the Chemical Abstracts Service (CAS), to every chemical substance described in the open scientific literature. It includes organic and inorganic compounds, minerals, isotopes, alloys, mixtures, and nonstructurable materials (UVCBs, substances of unknown or variable composition, complex reaction products, or biological origin). For further information, reference https://www.cas.org/cas-data/cas-registry.
	CasRN *string `json:"casRN,omitempty"`

	// The applicable channel involved in this biological material detection (e.g. Digestive, Eyes, Respiratory, Skin, etc.) .
	Channel *string `json:"channel,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// The concentration time, in (kg/sec)/m^3, associated with this material detection.
	CtrnTime *float64 `json:"ctrnTime,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode HazardIngestDataMode `json:"dataMode"`

	// Measure of density of the material associated with this detection, in kg/m^3.
	Density *float64 `json:"density,omitempty"`

	// The deposition measurement of the contaminant to surface area, in kg/m^2.
	Dep *float64 `json:"dep,omitempty"`

	// The deposition concentration of the contaminant to surface area, in becquerels/m^2.
	DepCtrn *float64 `json:"depCtrn,omitempty"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision.
	DetectTime time.Time `json:"detectTime"`

	// The type of hazard (Chemical, Biological, Radiological, Nuclear) detect associated with this record.
	DetectType string `json:"detectType"`

	// The dose associated with this detection, in gray. Dose is the measure of the energy deposited in matter by ionizing radiation per unit mass. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	Dose *float64 `json:"dose,omitempty"`

	// The dose rate associated with this detection, in gray/sec. One gray is defined as one Joule of energy absorbed per kilogram of matter.
	DoseRate *float64 `json:"doseRate,omitempty"`

	// The known or projected hazard duration, in seconds, associated with this material detection.
	Duration *int32 `json:"duration,omitempty"`

	// Chemical Agent Monitor (CAM) G-type agent measurement, in number of display bars. In G-mode, CAMs monitor for G-series nerve agents.
	GBar *float64 `json:"gBar,omitempty"`

	// Chemical Agent Monitor (CAM) H-type agent measurement, in number of display bars. In H-mode, CAMs monitor for blister agents.
	HBar *float64 `json:"hBar,omitempty"`

	// Flag indicating whether this detection is harmful to humans.
	Harmful *bool `json:"harmful,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Point of Interest (POI) record related to this hazard record.
	IdPOI *string `json:"idPOI,omitempty"`

	// ID of the Track record related to this hazard record.
	IdTrack *string `json:"idTrack,omitempty"`

	// Ratio of the chemical substance mass to the total mass of the mixture.
	MassFrac *float64 `json:"massFrac,omitempty"`

	// The Radiological Category (1 - 5) which applies to the material associated with this detection, according to the following definitions:
	//
	// Category 1: If not safely or securely managed, would be likely to cause permanent injury to a person who handled them or was otherwise in contact with them for more than a few minutes. It would probably be fatal to be close to this amount of unshielded material for a period of a few minutes to an hour.
	//
	// Category 2: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for a short time (minutes to hours). It could possibly be fatal to be close to this amount of unshielded radioactive material for a period of hours to days.
	//
	// Category 3: If not safely or securely managed, could cause permanent injury to a person who handled them or was otherwise in contact with them for hours. It could possibly - although it is unlikely to be - fatal to be close to this amount of unshielded radioactive material for a period of days to weeks.
	//
	// Category 4: If not safely managed or securely protected, could possibly cause temporary injury to someone who handled them or was otherwise in contact with or close to them for a period of many weeks, though this is unlikely. It is very unlikely anyone would be permanently injured by this amount of radioactive material.
	//
	// Category 5: Cannot cause permanent injury. This category applies to x-ray fluorescence devices and electron capture devices.
	MatCat *int32 `json:"matCat,omitempty"`

	// The specific Material Class for the material associated with this detect. The material class is generally associated with chemical and biological detections.
	MatClass *string `json:"matClass,omitempty"`

	// The material common name associated with this detection.
	MatName *string `json:"matName,omitempty"`

	// The specific material type (MT) or MT Code involved in this detection, when applicable. The material type is generally associated with radiological and/or nuclear detections. For further information, reference Nuclear Materials Management and Safeguards System (NMMSS) Users GuideRev. 2.1.
	MatType *string `json:"matType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Measure of the concentration of the material associated with this detection, in parts per million (units of contaminant mass per million parts of total mass).
	Ppm *int32 `json:"ppm,omitempty"`

	// Measure of radioactive concentration of the material associated with this detection, in becquerels/m^3. One becquerel (Bq) is equal to one nuclear decay per second.
	RadCtrn *float64 `json:"radCtrn,omitempty"`

	// Array of the units that correspond to each of the readingValues. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingUnits *[]string `json:"readingUnits,omitempty"`

	// Array of the values that correspond to each of the readings contained in readings. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	ReadingValues *[]float64 `json:"readingValues,omitempty"`

	// Array of the specific readings associated with this detection. The readings, readingUnits, and readingValues arrays must contain the same number of elements.
	Readings *[]string `json:"readings,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The Atomic Number of the material associated with this detection.
	Z *int32 `json:"z,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type HazardIngestDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationAbridged struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationAbridgedDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationFull struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationFullDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationFullDataMode string

// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
type LocationIngest struct {
	// Altitude of the location, in kilometers.
	Altitude *float64 `json:"altitude,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code for this location
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode LocationIngestDataMode `json:"dataMode"`

	// Unique identifier of the location, auto-generated by the system
	IdLocation *string `json:"idLocation,omitempty"`

	// WGS84 latitude of the location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude of the location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// Location name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type LocationIngestDataMode string

// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
type MissileTrackAbridged struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM.
	//
	// &nbsp;SRBM - Short-Range Ballistic Missile
	//
	// &nbsp;MRBM - Medium-Range Ballistic Missile
	//
	// &nbsp;IRBM - Intermediate-Range Ballistic Missile
	//
	// &nbsp;LRBM - Long-Range Ballistic Missile
	//
	// &nbsp;ICBM - Intercontinental Ballistic Missile
	//
	// &nbsp;SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A track may be designated as a non-alert track or an alert track.
	//
	// &nbsp;Non-alert tracks  choose None (Blank).
	//
	// &nbsp;Alert tracks  enter the proper alert classification:
	//
	// &nbsp;HIT - High Interest Track
	//
	// &nbsp;TGT - Target
	//
	// &nbsp;SUS - Suspect Carrier
	//
	// &nbsp;NSP - Cleared Suspect
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Angle of elevation/depression between observer and missile.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Missile azimuth corridor data.
	AzCorr *float64 `json:"azCorr,omitempty"`

	// Indicates whether or not the missile is currently in a state of boosting.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// The call sign currently assigned to the track object.
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The percentage of time that the estimated AoU will "cover" the true position of the track.
	Containment *float64 `json:"containment,omitempty"`

	// Track object course, in degrees clockwise from true north.
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissileTrackAbridgedDataMode `json:"dataMode"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Indicates whether or not a track has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *MissileTrackAbridgedEnv `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Indicates whether or not the missile is considered lost.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// Missile status enumeration:
	//
	// &nbsp;AT LAUNCH
	//
	// &nbsp;AT OBSERVATION
	//
	// &nbsp;FLYING
	//
	// &nbsp;IMPACTED
	//
	// &nbsp;LOST
	//
	// &nbsp;STALE
	//
	// &nbsp;DEBRIS
	//
	MslStatus *string `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *MissileTrackAbridgedObjIdent `json:"objIdent,omitempty"`

	// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// Type of missile. Examples: Ballistic, Cruise, Surface-to-Air. The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Azimuth corridor reference point latitude.
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// Azimuth corridor reference point longitude.
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// Last report type received from the sensor (for example, OBSBO = observation burnout)
	SenMode *string `json:"senMode,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics. Values range from 0 to 6.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissileTrackAbridgedDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type MissileTrackAbridgedEnv string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type MissileTrackAbridgedObjIdent string

// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
type MissileTrackFull struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM.
	//
	// &nbsp;SRBM - Short-Range Ballistic Missile
	//
	// &nbsp;MRBM - Medium-Range Ballistic Missile
	//
	// &nbsp;IRBM - Intermediate-Range Ballistic Missile
	//
	// &nbsp;LRBM - Long-Range Ballistic Missile
	//
	// &nbsp;ICBM - Intercontinental Ballistic Missile
	//
	// &nbsp;SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A track may be designated as a non-alert track or an alert track.
	//
	// &nbsp;Non-alert tracks  choose None (Blank).
	//
	// &nbsp;Alert tracks  enter the proper alert classification:
	//
	// &nbsp;HIT - High Interest Track
	//
	// &nbsp;TGT - Target
	//
	// &nbsp;SUS - Suspect Carrier
	//
	// &nbsp;NSP - Cleared Suspect
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Angle of elevation/depression between observer and missile.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Missile azimuth corridor data.
	AzCorr *float64 `json:"azCorr,omitempty"`

	// Indicates whether or not the missile is currently in a state of boosting.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// The call sign currently assigned to the track object.
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The percentage of time that the estimated AoU will "cover" the true position of the track.
	Containment *float64 `json:"containment,omitempty"`

	// Track object course, in degrees clockwise from true north.
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissileTrackFullDataMode `json:"dataMode"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Indicates whether or not a track has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *MissileTrackFullEnv `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Indicates whether or not the missile is considered lost.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// Missile status enumeration:
	//
	// &nbsp;AT LAUNCH
	//
	// &nbsp;AT OBSERVATION
	//
	// &nbsp;FLYING
	//
	// &nbsp;IMPACTED
	//
	// &nbsp;LOST
	//
	// &nbsp;STALE
	//
	// &nbsp;DEBRIS
	//
	MslStatus *string `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *MissileTrackFullObjIdent `json:"objIdent,omitempty"`

	// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// Type of missile. Examples: Ballistic, Cruise, Surface-to-Air. The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Azimuth corridor reference point latitude.
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// Azimuth corridor reference point longitude.
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// Last report type received from the sensor (for example, OBSBO = observation burnout)
	SenMode *string `json:"senMode,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics. Values range from 0 to 6.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissileTrackFullDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type MissileTrackFullEnv string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type MissileTrackFullObjIdent string

// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
type MissileTrackIngest struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM.
	//
	// &nbsp;SRBM - Short-Range Ballistic Missile
	//
	// &nbsp;MRBM - Medium-Range Ballistic Missile
	//
	// &nbsp;IRBM - Intermediate-Range Ballistic Missile
	//
	// &nbsp;LRBM - Long-Range Ballistic Missile
	//
	// &nbsp;ICBM - Intercontinental Ballistic Missile
	//
	// &nbsp;SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A track may be designated as a non-alert track or an alert track.
	//
	// &nbsp;Non-alert tracks  choose None (Blank).
	//
	// &nbsp;Alert tracks  enter the proper alert classification:
	//
	// &nbsp;HIT - High Interest Track
	//
	// &nbsp;TGT - Target
	//
	// &nbsp;SUS - Suspect Carrier
	//
	// &nbsp;NSP - Cleared Suspect
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Angle of elevation/depression between observer and missile.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Missile azimuth corridor data.
	AzCorr *float64 `json:"azCorr,omitempty"`

	// Indicates whether or not the missile is currently in a state of boosting.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// The call sign currently assigned to the track object.
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The percentage of time that the estimated AoU will "cover" the true position of the track.
	Containment *float64 `json:"containment,omitempty"`

	// Track object course, in degrees clockwise from true north.
	Course *float64 `json:"course,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissileTrackIngestDataMode `json:"dataMode"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Indicates whether or not a track has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *MissileTrackIngestEnv `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// &nbsp;ELLIPSE:
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the ellipse
	//
	// &nbsp;&nbsp;a1 - semi-major axis in meters
	//
	// &nbsp;&nbsp;a2 - semi-minor axis in meters
	//
	//
	//
	// &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
	//
	// &nbsp;&nbsp;brg - orientation in degrees of the bearing box
	//
	// &nbsp;&nbsp;a1 - length of bearing box in meters
	//
	// &nbsp;&nbsp;a2 - half-width of bearing box in meters
	//
	//
	//
	// &nbsp;OTHER (All other type values):
	//
	// &nbsp;&nbsp;brg - line of bearing in degrees true
	//
	// &nbsp;&nbsp;a1 - bearing error in degrees
	//
	// &nbsp;&nbsp;a2 - estimated range in meters.
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Indicates whether or not the missile is considered lost.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// Missile status enumeration:
	//
	// &nbsp;AT LAUNCH
	//
	// &nbsp;AT OBSERVATION
	//
	// &nbsp;FLYING
	//
	// &nbsp;IMPACTED
	//
	// &nbsp;LOST
	//
	// &nbsp;STALE
	//
	// &nbsp;DEBRIS
	//
	MslStatus *string `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *MissileTrackIngestObjIdent `json:"objIdent,omitempty"`

	// Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// Type of missile. Examples: Ballistic, Cruise, Surface-to-Air. The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Azimuth corridor reference point latitude.
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// Azimuth corridor reference point longitude.
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// Last report type received from the sensor (for example, OBSBO = observation burnout)
	SenMode *string `json:"senMode,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics. Values range from 0 to 6.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissileTrackIngestDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type MissileTrackIngestEnv string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type MissileTrackIngestObjIdent string

// Platform mission assignment data
type MissionAssignmentAbridged struct {
	// TARGET POSITION CONTINUATION WORD - number of associated dmpis
	C1associateddmpis *int32 `json:"c1associateddmpis,omitempty"`

	// TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21
	C2air *string `json:"c2air,omitempty"`

	// TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS
	C2alt *int32 `json:"c2alt,omitempty"`

	// TARGET DATA CONTINUATION WORD - course in increments of 1 degree
	C2crs *int32 `json:"c2crs,omitempty"`

	// TARGET DATA CONTINUATION WORD - exercise indicator
	C2exerciseindicator *string `json:"c2exerciseindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - method of fire
	C2exercisemof *string `json:"c2exercisemof,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity
	C2id *string `json:"c2id,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity amplifying desriptor
	C2idamplifyingdescriptor *string `json:"c2idamplifyingdescriptor,omitempty"`

	// TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21
	C2lnd *string `json:"c2lnd,omitempty"`

	// TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39
	C2spc *string `json:"c2spc,omitempty"`

	// TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS
	C2spd *int32 `json:"c2spd,omitempty"`

	// TARGET DATA CONTINUATION WORD - special interest indicator
	C2specialinterestindicator *string `json:"c2specialinterestindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21
	C2sur *string `json:"c2sur,omitempty"`

	// POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS
	C3elv *float64 `json:"c3elv,omitempty"`

	// POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE
	C3lat *float64 `json:"c3lat,omitempty"`

	// POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE
	C3lon *float64 `json:"c3lon,omitempty"`

	// TARGET DATA CONTINUATION WORD - point type 1
	C3ptl *string `json:"c3ptl,omitempty"`

	// TARGET DATA CONTINUATION WORD - point number
	C3ptnum *string `json:"c3ptnum,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - minute
	C4colon *int32 `json:"c4colon,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - target defenses
	C4def *string `json:"c4def,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4egress *int32 `json:"c4egress,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - mode of delivery
	C4mod *int32 `json:"c4mod,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63
	C4numberofstores *int32 `json:"c4numberofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4runin *int32 `json:"c4runin,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - taget type - see TABLE B-32
	C4tgt *string `json:"c4tgt,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - time discrete
	C4timediscrete *string `json:"c4timediscrete,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - hour
	C4tm *int32 `json:"c4tm,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - type of stores
	C4typeofstores *int32 `json:"c4typeofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec
	C5colon *int32 `json:"c5colon,omitempty"`

	// CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft
	C5elevationlsbs *int32 `json:"c5elevationlsbs,omitempty"`

	// CONTINUATION WORD - hae adjustment, measured in 3.125 FT
	C5haeadj *int32 `json:"c5haeadj,omitempty"`

	// CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft
	C5latlsb *int32 `json:"c5latlsb,omitempty"`

	// CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft
	C5lonlsb *int32 `json:"c5lonlsb,omitempty"`

	// CONTINUATION WORD - target bearing
	C5tgtbrng *int32 `json:"c5tgtbrng,omitempty"`

	// CONTINUATION WORD - time window
	C5tw *int32 `json:"c5tw,omitempty"`

	// TARGETING CONTINUATION WORD - designator/ seeker pulse code
	C6dspc *string `json:"c6dspc,omitempty"`

	// TARGETING CONTINUATION WORD - designator/seeker pulse code type
	C6dspct *string `json:"c6dspct,omitempty"`

	// TARGETING CONTINUATION WORD - first pulse/last pulse mode
	C6fplpm *string `json:"c6fplpm,omitempty"`

	// TARGETING CONTINUATION WORD - index number, related, 0=NS
	C6intel *int32 `json:"c6intel,omitempty"`

	// TARGETING CONTINUATION WORD - laser illuminator code
	C6laser *int32 `json:"c6laser,omitempty"`

	// TARGETING CONTINUATION WORD - long pulse mode
	C6longpm *string `json:"c6longpm,omitempty"`

	// TARGETING CONTINUATION WORD - track number, related to 3
	C6tnr3 *int32 `json:"c6tnr3,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - elevation angle, 2
	C7elang2 *float64 `json:"c7elang2,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - index number, third party
	C7in3p *int32 `json:"c7in3p,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - track number, index originator
	C7tnor *string `json:"c7tnor,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissionAssignmentAbridgedDataMode `json:"dataMode"`

	// Environment
	Env *string `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Index number
	Index *int32 `json:"index,omitempty"`

	// WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The mission assignment discrete value
	Mad string `json:"mad"`

	// Origin of index number
	Orginx *string `json:"orginx,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Receipt/Compliance, values from TABLE B-9
	Rc *string `json:"rc,omitempty"`

	// Recurrence rate, receipt/compliance
	Rr *int32 `json:"rr,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Strength
	Sz *string `json:"sz,omitempty"`

	// Track number objective
	Tno *string `json:"tno,omitempty"`

	// The track ID that the status is referencing, addressee
	TrkId *string `json:"trkId,omitempty"`

	// the timestamp of the mission data, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// threat warning environment
	Twenv *string `json:"twenv,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissionAssignmentAbridgedDataMode string

// Platform mission assignment data
type MissionAssignmentFull struct {
	// TARGET POSITION CONTINUATION WORD - number of associated dmpis
	C1associateddmpis *int32 `json:"c1associateddmpis,omitempty"`

	// TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21
	C2air *string `json:"c2air,omitempty"`

	// TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS
	C2alt *int32 `json:"c2alt,omitempty"`

	// TARGET DATA CONTINUATION WORD - course in increments of 1 degree
	C2crs *int32 `json:"c2crs,omitempty"`

	// TARGET DATA CONTINUATION WORD - exercise indicator
	C2exerciseindicator *string `json:"c2exerciseindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - method of fire
	C2exercisemof *string `json:"c2exercisemof,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity
	C2id *string `json:"c2id,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity amplifying desriptor
	C2idamplifyingdescriptor *string `json:"c2idamplifyingdescriptor,omitempty"`

	// TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21
	C2lnd *string `json:"c2lnd,omitempty"`

	// TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39
	C2spc *string `json:"c2spc,omitempty"`

	// TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS
	C2spd *int32 `json:"c2spd,omitempty"`

	// TARGET DATA CONTINUATION WORD - special interest indicator
	C2specialinterestindicator *string `json:"c2specialinterestindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21
	C2sur *string `json:"c2sur,omitempty"`

	// POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS
	C3elv *float64 `json:"c3elv,omitempty"`

	// POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE
	C3lat *float64 `json:"c3lat,omitempty"`

	// POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE
	C3lon *float64 `json:"c3lon,omitempty"`

	// TARGET DATA CONTINUATION WORD - point type 1
	C3ptl *string `json:"c3ptl,omitempty"`

	// TARGET DATA CONTINUATION WORD - point number
	C3ptnum *string `json:"c3ptnum,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - minute
	C4colon *int32 `json:"c4colon,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - target defenses
	C4def *string `json:"c4def,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4egress *int32 `json:"c4egress,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - mode of delivery
	C4mod *int32 `json:"c4mod,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63
	C4numberofstores *int32 `json:"c4numberofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4runin *int32 `json:"c4runin,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - taget type - see TABLE B-32
	C4tgt *string `json:"c4tgt,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - time discrete
	C4timediscrete *string `json:"c4timediscrete,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - hour
	C4tm *int32 `json:"c4tm,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - type of stores
	C4typeofstores *int32 `json:"c4typeofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec
	C5colon *int32 `json:"c5colon,omitempty"`

	// CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft
	C5elevationlsbs *int32 `json:"c5elevationlsbs,omitempty"`

	// CONTINUATION WORD - hae adjustment, measured in 3.125 FT
	C5haeadj *int32 `json:"c5haeadj,omitempty"`

	// CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft
	C5latlsb *int32 `json:"c5latlsb,omitempty"`

	// CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft
	C5lonlsb *int32 `json:"c5lonlsb,omitempty"`

	// CONTINUATION WORD - target bearing
	C5tgtbrng *int32 `json:"c5tgtbrng,omitempty"`

	// CONTINUATION WORD - time window
	C5tw *int32 `json:"c5tw,omitempty"`

	// TARGETING CONTINUATION WORD - designator/ seeker pulse code
	C6dspc *string `json:"c6dspc,omitempty"`

	// TARGETING CONTINUATION WORD - designator/seeker pulse code type
	C6dspct *string `json:"c6dspct,omitempty"`

	// TARGETING CONTINUATION WORD - first pulse/last pulse mode
	C6fplpm *string `json:"c6fplpm,omitempty"`

	// TARGETING CONTINUATION WORD - index number, related, 0=NS
	C6intel *int32 `json:"c6intel,omitempty"`

	// TARGETING CONTINUATION WORD - laser illuminator code
	C6laser *int32 `json:"c6laser,omitempty"`

	// TARGETING CONTINUATION WORD - long pulse mode
	C6longpm *string `json:"c6longpm,omitempty"`

	// TARGETING CONTINUATION WORD - track number, related to 3
	C6tnr3 *int32 `json:"c6tnr3,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - elevation angle, 2
	C7elang2 *float64 `json:"c7elang2,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - index number, third party
	C7in3p *int32 `json:"c7in3p,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - track number, index originator
	C7tnor *string `json:"c7tnor,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissionAssignmentFullDataMode `json:"dataMode"`

	// Environment
	Env *string `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Index number
	Index *int32 `json:"index,omitempty"`

	// WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The mission assignment discrete value
	Mad string `json:"mad"`

	// Origin of index number
	Orginx *string `json:"orginx,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Receipt/Compliance, values from TABLE B-9
	Rc *string `json:"rc,omitempty"`

	// Recurrence rate, receipt/compliance
	Rr *int32 `json:"rr,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Strength
	Sz *string `json:"sz,omitempty"`

	// Track number objective
	Tno *string `json:"tno,omitempty"`

	// The track ID that the status is referencing, addressee
	TrkId *string `json:"trkId,omitempty"`

	// the timestamp of the mission data, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// threat warning environment
	Twenv *string `json:"twenv,omitempty"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissionAssignmentFullDataMode string

// Platform mission assignment data
type MissionAssignmentIngest struct {
	// TARGET POSITION CONTINUATION WORD - number of associated dmpis
	C1associateddmpis *int32 `json:"c1associateddmpis,omitempty"`

	// TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21
	C2air *string `json:"c2air,omitempty"`

	// TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS
	C2alt *int32 `json:"c2alt,omitempty"`

	// TARGET DATA CONTINUATION WORD - course in increments of 1 degree
	C2crs *int32 `json:"c2crs,omitempty"`

	// TARGET DATA CONTINUATION WORD - exercise indicator
	C2exerciseindicator *string `json:"c2exerciseindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - method of fire
	C2exercisemof *string `json:"c2exercisemof,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity
	C2id *string `json:"c2id,omitempty"`

	// TARGET DATA CONTINUATION WORD - identity amplifying desriptor
	C2idamplifyingdescriptor *string `json:"c2idamplifyingdescriptor,omitempty"`

	// TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21
	C2lnd *string `json:"c2lnd,omitempty"`

	// TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39
	C2spc *string `json:"c2spc,omitempty"`

	// TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS
	C2spd *int32 `json:"c2spd,omitempty"`

	// TARGET DATA CONTINUATION WORD - special interest indicator
	C2specialinterestindicator *string `json:"c2specialinterestindicator,omitempty"`

	// TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21
	C2sur *string `json:"c2sur,omitempty"`

	// POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS
	C3elv *float64 `json:"c3elv,omitempty"`

	// POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE
	C3lat *float64 `json:"c3lat,omitempty"`

	// POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE
	C3lon *float64 `json:"c3lon,omitempty"`

	// TARGET DATA CONTINUATION WORD - point type 1
	C3ptl *string `json:"c3ptl,omitempty"`

	// TARGET DATA CONTINUATION WORD - point number
	C3ptnum *string `json:"c3ptnum,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - minute
	C4colon *int32 `json:"c4colon,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - target defenses
	C4def *string `json:"c4def,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4egress *int32 `json:"c4egress,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - mode of delivery
	C4mod *int32 `json:"c4mod,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63
	C4numberofstores *int32 `json:"c4numberofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511
	C4runin *int32 `json:"c4runin,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - taget type - see TABLE B-32
	C4tgt *string `json:"c4tgt,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - time discrete
	C4timediscrete *string `json:"c4timediscrete,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - hour
	C4tm *int32 `json:"c4tm,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - type of stores
	C4typeofstores *int32 `json:"c4typeofstores,omitempty"`

	// SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec
	C5colon *int32 `json:"c5colon,omitempty"`

	// CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft
	C5elevationlsbs *int32 `json:"c5elevationlsbs,omitempty"`

	// CONTINUATION WORD - hae adjustment, measured in 3.125 FT
	C5haeadj *int32 `json:"c5haeadj,omitempty"`

	// CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft
	C5latlsb *int32 `json:"c5latlsb,omitempty"`

	// CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft
	C5lonlsb *int32 `json:"c5lonlsb,omitempty"`

	// CONTINUATION WORD - target bearing
	C5tgtbrng *int32 `json:"c5tgtbrng,omitempty"`

	// CONTINUATION WORD - time window
	C5tw *int32 `json:"c5tw,omitempty"`

	// TARGETING CONTINUATION WORD - designator/ seeker pulse code
	C6dspc *string `json:"c6dspc,omitempty"`

	// TARGETING CONTINUATION WORD - designator/seeker pulse code type
	C6dspct *string `json:"c6dspct,omitempty"`

	// TARGETING CONTINUATION WORD - first pulse/last pulse mode
	C6fplpm *string `json:"c6fplpm,omitempty"`

	// TARGETING CONTINUATION WORD - index number, related, 0=NS
	C6intel *int32 `json:"c6intel,omitempty"`

	// TARGETING CONTINUATION WORD - laser illuminator code
	C6laser *int32 `json:"c6laser,omitempty"`

	// TARGETING CONTINUATION WORD - long pulse mode
	C6longpm *string `json:"c6longpm,omitempty"`

	// TARGETING CONTINUATION WORD - track number, related to 3
	C6tnr3 *int32 `json:"c6tnr3,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - elevation angle, 2
	C7elang2 *float64 `json:"c7elang2,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - index number, third party
	C7in3p *int32 `json:"c7in3p,omitempty"`

	// THIRD PARTY CONTINUATION WORD  - track number, index originator
	C7tnor *string `json:"c7tnor,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode MissionAssignmentIngestDataMode `json:"dataMode"`

	// Environment
	Env *string `json:"env,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Index number
	Index *int32 `json:"index,omitempty"`

	// WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The mission assignment discrete value
	Mad string `json:"mad"`

	// Origin of index number
	Orginx *string `json:"orginx,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Receipt/Compliance, values from TABLE B-9
	Rc *string `json:"rc,omitempty"`

	// Recurrence rate, receipt/compliance
	Rr *int32 `json:"rr,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Strength
	Sz *string `json:"sz,omitempty"`

	// Track number objective
	Tno *string `json:"tno,omitempty"`

	// The track ID that the status is referencing, addressee
	TrkId *string `json:"trkId,omitempty"`

	// the timestamp of the mission data, in ISO 8601 UTC format
	Ts time.Time `json:"ts"`

	// threat warning environment
	Twenv *string `json:"twenv,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type MissionAssignmentIngestDataMode string

// Read-only collection of antennas on this on-orbit object
type OnorbitAntennaFull struct {
	// Model representation of information on on-orbit/spacecraft communication antennas. A spacecraft may have multiple antennas and each antenna can have multiple 'details' records compiled by different sources.
	Antenna *AntennaFull `json:"antenna,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAntennaFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the antenna
	IdAntenna string `json:"idAntenna"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAntennaFullDataMode string

// Read-only collection of batteries on this on-orbit object
type OnorbitBatteryFull struct {
	// Model representation of specific spacecraft battery types
	Battery *BatteryFull `json:"battery,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitBatteryFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the battery
	IdBattery string `json:"idBattery"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of batteries on the spacecraft of the type identified by idBattery
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitBatteryFullDataMode string

// Contains details of the OnOrbit object
type OnorbitDetailsFull struct {
	// Mass of fuel and disposables at launch time in kg
	AdditionalMass *float64 `json:"additionalMass,omitempty"`

	// The radius used for long-term debris environment projection analyses that is not as conservative as COLA Radius, in meters
	AdeptRadius *float64 `json:"adeptRadius,omitempty"`

	// Spacecraft beginning of life fuel mass, in orbit, in kg
	BolFuelMass *float64 `json:"bolFuelMass,omitempty"`

	// Average cross sectional area of the bus in meters squared
	BusCrossSection *float64 `json:"busCrossSection,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Maximum dimension of the box circumscribing the spacecraft (d = sqrt(a*a + b*b + c*c) where a is the tip-to-tip dimension, b and c are perpendicular to that.) in meters
	ColaRadius *float64 `json:"colaRadius,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Average cross sectional area in meters squared
	CrossSection *float64 `json:"crossSection,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitDetailsFullDataMode `json:"dataMode"`

	// GEO drift rate, if applicable in degrees per day
	DriftRate *float64 `json:"driftRate,omitempty"`

	// Spacecraft dry mass (without fuel or disposables) in kg
	DryMass *float64 `json:"dryMass,omitempty"`

	// Estimated maxmimum burn duration for the object
	EstDeltaVDuration *float64 `json:"estDeltaVDuration,omitempty"`

	// Estimated remaining fuel for the object in kg
	FuelRemaining *float64 `json:"fuelRemaining,omitempty"`

	// GEO slot if applicable, in degrees. -180 (West of Prime Meridian) to 180 degrees (East of Prime Meridian). Prime Meridian is 0.
	GeoSlot *float64 `json:"geoSlot,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// UUID of the parent Onorbit record
	IdOnOrbit string `json:"idOnOrbit"`

	// The name of the source who last provided an observation for this idOnOrbit
	LastObSource *string `json:"lastObSource,omitempty"`

	// Time of last reported observation for this object in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Nominal mass of spacecraft and fuel at launch time, in kg
	LaunchMass *float64 `json:"launchMass,omitempty"`

	// Maximum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMax *float64 `json:"launchMassMax,omitempty"`

	// Minimum (estimated) mass of spacecraft and fuel at launch time, in kg
	LaunchMassMin *float64 `json:"launchMassMin,omitempty"`

	// Maximum delta V available for this on-orbit spacecraft
	MaxDeltaV *float64 `json:"maxDeltaV,omitempty"`

	// Maximum dimension across the spacecraft (e.g., tip-to-tip across the solar panel arrays) in meters
	MaxRadius *float64 `json:"maxRadius,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Current/latest radar cross section in meters squared
	Rcs *float64 `json:"rcs,omitempty"`

	// Maximum radar cross section in meters squared
	RcsMax *float64 `json:"rcsMax,omitempty"`

	// Mean radar cross section in meters squared
	RcsMean *float64 `json:"rcsMean,omitempty"`

	// Minimum radar cross section in meters squared
	RcsMin *float64 `json:"rcsMin,omitempty"`

	// Spacecraft deployed area of solar array in sq meters
	SolarArrayArea *float64 `json:"solarArrayArea,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Current/latest visual magnitude in M
	Vismag *float64 `json:"vismag,omitempty"`

	// Maximum visual magnitude in M
	VismagMax *float64 `json:"vismagMax,omitempty"`

	// Mean visual magnitude in M
	VismagMean *float64 `json:"vismagMean,omitempty"`

	// Minimum visual magnitude in M
	VismagMin *float64 `json:"vismagMin,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitDetailsFullDataMode string

// Read-only collection of solar arrays on this on-orbit object
type OnorbitSolarArrayFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitSolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// ID of the SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of solar arrays on the spacecraft of the type identified by idSolarArray
	Quantity *int32 `json:"quantity,omitempty"`

	// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
	SolarArray *SolarArrayFull `json:"solarArray,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitSolarArrayFullDataMode string

// Read-only collection of thrusters (engines) on this on-orbit object
type OnorbitThrusterFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitThrusterFullDataMode `json:"dataMode"`

	// Known launch vehicle engines and their performance characteristics and limits.  A launch vehicle has 1 to many engines per stage.
	Engine *EngineFull `json:"engine,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// ID of the Engine
	IdEngine string `json:"idEngine"`

	// ID of the on-orbit object
	IdOnOrbit string `json:"idOnOrbit"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of engines/thrusters on the spacecraft of the type identified by idEngine
	Quantity *int32 `json:"quantity,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitThrusterFullDataMode string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitAbridged struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitAbridgedCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitAbridgedDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitAbridgedObjectType `json:"objectType,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Source of the data
	Source string `json:"source"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitAbridgedCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitAbridgedDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitAbridgedObjectType string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitFull struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Read-only collection of antennas on this on-orbit object
	Antennas *[]OnorbitAntennaFull `json:"antennas,omitempty"`

	// Read-only collection of batteries on this on-orbit object
	Batteries *[]OnorbitBatteryFull `json:"batteries,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitFullCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitFullDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// Read-only entity details (only returned/used on detail queries).
	EntityCollection *[]EntityFull `json:"entityCollection,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitFullObjectType `json:"objectType,omitempty"`

	// Read-only collection of details for this on-orbit object
	OnorbitDetails *[]OnorbitDetailsFull `json:"onorbitDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Read-only collection of solar arrays on this on-orbit object
	SolarArrays *[]OnorbitSolarArrayFull `json:"solarArrays,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only collection of thrusters (engines) on this on-orbit object
	Thrusters *[]OnorbitThrusterFull `json:"thrusters,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitFullCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitFullDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitFullObjectType string

// Model object representing on-orbit objects or satellites in the system.
type OnorbitIngest struct {
	// Alternate name of the on-orbit object
	AltName *string `json:"altName,omitempty"`

	// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
	Category *OnorbitIngestCategory `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Common name of the on-orbit object.
	CommonName *string `json:"commonName,omitempty"`

	// Constellation to which this satellite belongs
	Constellation *string `json:"constellation,omitempty"`

	// Country code for primary OnOrbit owner, read only
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OnorbitIngestDataMode `json:"dataMode"`

	// Date of decay
	DecayDate *time.Time `json:"decayDate,omitempty"`

	// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit string `json:"idOnOrbit"`

	// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch
	IntlDes *string `json:"intlDes,omitempty"`

	// Date of launch
	LaunchDate *time.Time `json:"launchDate,omitempty"`

	// Id of the associated launchSite entity
	LaunchSiteId *string `json:"launchSiteId,omitempty"`

	// Estimated lifetime of the on-orbit payload, if known
	LifetimeYears *int32 `json:"lifetimeYears,omitempty"`

	// Mission number of the on-orbit object
	MissionNumber *string `json:"missionNumber,omitempty"`

	// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
	ObjectType *OnorbitIngestObjectType `json:"objectType,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Satellite/Catalog number of the target on-orbit object
	SatNo int32 `json:"satNo"`

	// Source of the data
	Source string `json:"source"`
}

// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked)
type OnorbitIngestCategory string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OnorbitIngestDataMode string

// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN
type OnorbitIngestObjectType string

// Model representation of a unit or organization which operates or controls an space-related Entity such as an on-orbit payload, a sensor, etc.  A contact may belong to an organization.
type OperatingunitFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OperatingunitFullDataMode `json:"dataMode"`

	// Description of the operating unit
	Description *string `json:"description,omitempty"`

	// Unique identifier of the contact for this operating unit
	IdContact *string `json:"idContact,omitempty"`

	// Unique identifier of the location record for this operating unit
	IdLocation *string `json:"idLocation,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdOperatingUnit *string `json:"idOperatingUnit,omitempty"`

	// Unique identifier of the organization record for this operating unit
	IdOrganization *string `json:"idOrganization,omitempty"`

	// Model representation of a location, which is a specific fixed point on the earth and is used to denote the locations of fixed sensors, operating units, etc.
	Location *LocationFull `json:"location,omitempty"`

	// Name of the operating unit
	Name string `json:"name"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	Organization *OrganizationFull `json:"organization,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OperatingunitFullDataMode string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite and applicable sensor data aiding in the orbit prediction.
type OrbitTrackAbridged struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Free-form remarks entered for the satellite.
	Amplification *string `json:"amplification,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon at track timestamp, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU).  The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	// BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	// OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	AouData *[]float64 `json:"aouData,omitempty"`

	// The Area of uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouData array and is required if aouData is not null. See the aouData field definition for specific information
	AouType *string `json:"aouType,omitempty"`

	// International radio call sign assigned to the track. This is an 8-character alphanumeric code.
	CallSign *string `json:"callSign,omitempty"`

	// The cross-reference code of the channel on which this track report was received, if the report came over a comms channel.
	ChXRef *string `json:"chXRef,omitempty"`

	// One-line Charlie elements set.
	CharlieLine *string `json:"charlieLine,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Cntnmnt *float64 `json:"cntnmnt,omitempty"`

	// The country code for primary OnOrbit owner.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrbitTrackAbridgedDataMode `json:"dataMode"`

	// Predicted change in Mean Motion (velocity) in radians/herg^2.  herg is a unit of time measure equal to 806.8120769 seconds, and is the orbital period of an imaginary satellite rotating about the Earth at zero altitude.
	Decay *float64 `json:"decay,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Elset associated with this object.
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the target on-orbit object, if correlated.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text aplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *OrbitTrackAbridgedObjIdent `json:"objIdent,omitempty"`

	// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
	ObjectType *OrbitTrackAbridgedObjectType `json:"objectType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by observation source to indicate the target on-orbit object of this track. This may be an internal identifier and not necessarily a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Radio frequency of the track, measured in megahertz (MHz).
	RdfRF *float64 `json:"rdfRF,omitempty"`

	// Flag indicating that this track represents a reduced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Report number received from the reporting source for this track.
	RptNum *string `json:"rptNum,omitempty"`

	// Satellite/catalog number of the target on-orbit object.
	SatNo *int32 `json:"satNo,omitempty"`

	// Status of the satellite.
	SatStatus *string `json:"satStatus,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Track object speed, in km/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// TrackSensor Collection
	TrackSensors *[]TrackSensorAbridged `json:"trackSensors,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// The type of vehicle with which the device is associated.  Based on MIL-STD-2525 symbology definitions.
	VehType *string `json:"vehType,omitempty"`

	// Source cross-reference code for the command that originated the track report.
	Xref *string `json:"xref,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrbitTrackAbridgedDataMode string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type OrbitTrackAbridgedObjIdent string

// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
type OrbitTrackAbridgedObjectType string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite and applicable sensor data aiding in the orbit prediction.
type OrbitTrackFull struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Free-form remarks entered for the satellite.
	Amplification *string `json:"amplification,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon at track timestamp, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU).  The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	// BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	// OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	AouData *[]float64 `json:"aouData,omitempty"`

	// The Area of uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouData array and is required if aouData is not null. See the aouData field definition for specific information
	AouType *string `json:"aouType,omitempty"`

	// International radio call sign assigned to the track. This is an 8-character alphanumeric code.
	CallSign *string `json:"callSign,omitempty"`

	// The cross-reference code of the channel on which this track report was received, if the report came over a comms channel.
	ChXRef *string `json:"chXRef,omitempty"`

	// One-line Charlie elements set.
	CharlieLine *string `json:"charlieLine,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Cntnmnt *float64 `json:"cntnmnt,omitempty"`

	// The country code for primary OnOrbit owner.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrbitTrackFullDataMode `json:"dataMode"`

	// Predicted change in Mean Motion (velocity) in radians/herg^2.  herg is a unit of time measure equal to 806.8120769 seconds, and is the orbital period of an imaginary satellite rotating about the Earth at zero altitude.
	Decay *float64 `json:"decay,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Elset associated with this object.
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the target on-orbit object, if correlated.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text aplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *OrbitTrackFullObjIdent `json:"objIdent,omitempty"`

	// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
	ObjectType *OrbitTrackFullObjectType `json:"objectType,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by observation source to indicate the target on-orbit object of this track. This may be an internal identifier and not necessarily a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Radio frequency of the track, measured in megahertz (MHz).
	RdfRF *float64 `json:"rdfRF,omitempty"`

	// Flag indicating that this track represents a reduced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Report number received from the reporting source for this track.
	RptNum *string `json:"rptNum,omitempty"`

	// Satellite/catalog number of the target on-orbit object.
	SatNo *int32 `json:"satNo,omitempty"`

	// Status of the satellite.
	SatStatus *string `json:"satStatus,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Track object speed, in km/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// TrackSensor Collection
	TrackSensors *[]TrackSensorFull `json:"trackSensors,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// The type of vehicle with which the device is associated.  Based on MIL-STD-2525 symbology definitions.
	VehType *string `json:"vehType,omitempty"`

	// Source cross-reference code for the command that originated the track report.
	Xref *string `json:"xref,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrbitTrackFullDataMode string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type OrbitTrackFullObjIdent string

// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
type OrbitTrackFullObjectType string

// Keplerian orbital elements describing an orbit for a particular on-orbit satellite and applicable sensor data aiding in the orbit prediction.
type OrbitTrackIngest struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Free-form remarks entered for the satellite.
	Amplification *string `json:"amplification,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon at track timestamp, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU).  The array element definitions and units are type specific depending on the aouType specified in this record:
	//
	//
	//
	// ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	// BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	// OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	AouData *[]float64 `json:"aouData,omitempty"`

	// The Area of uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouData array and is required if aouData is not null. See the aouData field definition for specific information
	AouType *string `json:"aouType,omitempty"`

	// International radio call sign assigned to the track. This is an 8-character alphanumeric code.
	CallSign *string `json:"callSign,omitempty"`

	// The cross-reference code of the channel on which this track report was received, if the report came over a comms channel.
	ChXRef *string `json:"chXRef,omitempty"`

	// One-line Charlie elements set.
	CharlieLine *string `json:"charlieLine,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Cntnmnt *float64 `json:"cntnmnt,omitempty"`

	// The country code for primary OnOrbit owner.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrbitTrackIngestDataMode `json:"dataMode"`

	// Predicted change in Mean Motion (velocity) in radians/herg^2.  herg is a unit of time measure equal to 806.8120769 seconds, and is the orbital period of an imaginary satellite rotating about the Earth at zero altitude.
	Decay *float64 `json:"decay,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// Unique identifier of the record, auto-generated by the system if not provided on create operations.
	Id *string `json:"id,omitempty"`

	// Unique identifier of the Elset associated with this object.
	IdElset *string `json:"idElset,omitempty"`

	// Unique identifier of the target on-orbit object, if correlated.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text aplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *OrbitTrackIngestObjIdent `json:"objIdent,omitempty"`

	// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
	ObjectType *OrbitTrackIngestObjectType `json:"objectType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by observation source to indicate the target on-orbit object of this track. This may be an internal identifier and not necessarily a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Radio frequency of the track, measured in megahertz (MHz).
	RdfRF *float64 `json:"rdfRF,omitempty"`

	// Flag indicating that this track represents a reduced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Report number received from the reporting source for this track.
	RptNum *string `json:"rptNum,omitempty"`

	// Satellite/catalog number of the target on-orbit object.
	SatNo *int32 `json:"satNo,omitempty"`

	// Status of the satellite.
	SatStatus *string `json:"satStatus,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// Track object speed, in km/sec.
	Spd *float64 `json:"spd,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// TrackSensor Collection
	TrackSensors *[]TrackSensorIngest `json:"trackSensors,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision.
	Ts time.Time `json:"ts"`

	// The type of vehicle with which the device is associated.  Based on MIL-STD-2525 symbology definitions.
	VehType *string `json:"vehType,omitempty"`

	// Source cross-reference code for the command that originated the track report.
	Xref *string `json:"xref,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrbitTrackIngestDataMode string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type OrbitTrackIngestObjIdent string

// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
type OrbitTrackIngestObjectType string

// Model representation of additional detailed organization data as collected by a particular source.
type OrganizationDetailsFull struct {
	// Designated broker for this organization.
	Broker *string `json:"broker,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Executive Officer.
	Ceo *string `json:"ceo,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Financial Officer.
	Cfo *string `json:"cfo,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// For organizations of type CORPORATION, the name of the Chief Technology Officer.
	Cto *string `json:"cto,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationDetailsFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// For organizations of type CORPORATION, the company EBITDA value as of financialYearEndDate in US Dollars.
	Ebitda *float64 `json:"ebitda,omitempty"`

	// For organizations of type CORPORATION, notes on company financials.
	FinancialNotes *string `json:"financialNotes,omitempty"`

	// For organizations of type CORPORATION, the effective financial year end date for revenue, EBITDA, and profit values.
	FinancialYearEndDate *time.Time `json:"financialYearEndDate,omitempty"`

	// Satellite fleet planning notes for this organization.
	FleetPlanNotes *string `json:"fleetPlanNotes,omitempty"`

	// Former organization ID (if this organization previously existed as another organization)
	FormerOrgId *string `json:"formerOrgId,omitempty"`

	// Total number of FTEs in this organization.
	Ftes *int32 `json:"ftes,omitempty"`

	// Unique identifier of the parent organization.
	IdOrganization string `json:"idOrganization"`

	// Mass ranking for this organization.
	MassRanking *int32 `json:"massRanking,omitempty"`

	// Organization details name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Parent organization ID of this organization if it is a child organization
	ParentOrgId *string `json:"parentOrgId,omitempty"`

	// For organizations of type CORPORATION, total annual profit as of financialYearEndDate in US Dollars.
	Profit *float64 `json:"profit,omitempty"`

	// For organizations of type CORPORATION, total annual revenue as of financialYearEndDate in US Dollars.
	Revenue *float64 `json:"revenue,omitempty"`

	// Revenue ranking for this organization.
	RevenueRanking *int32 `json:"revenueRanking,omitempty"`

	// The name of the risk manager for the organization.
	RiskManager *string `json:"riskManager,omitempty"`

	// Notes on the services provided by the organization.
	ServicesNotes *string `json:"servicesNotes,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationDetailsFullDataMode string

// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
type OrganizationFull struct {
	// Boolean indicating if this organization is currently active.
	Active *bool `json:"active,omitempty"`

	// Subtype or category of the organization (e.g. Private company, stock market quoted company, subsidiary, goverment department/agency, etc).
	Category *string `json:"category,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Country code of this organization's headquarters.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode OrganizationFullDataMode `json:"dataMode"`

	// Organization description
	Description *string `json:"description,omitempty"`

	// Optional externally provided identifier for this row
	ExternalId *string `json:"externalId,omitempty"`

	// Organization name
	Name string `json:"name"`

	// Read-only collection of additional OrganizationDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/organizationdetails operations.
	OrganizationDetails *[]OrganizationDetailsFull `json:"organizationDetails,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Type of organization (e.g. GOVERNMENT, CORPORATION, CONSORTIUM, ACADEMIC)
	Type string `json:"type"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type OrganizationFullDataMode string

// A Point of Interest is loosely based on the MITRE CoT (Cursor on Target) schema (https://www.mitre.org/publications/technical-papers/cursorontarget-message-router-users-guide) and provides a simple way to specify a point on the earth for a variety of purposes (tasking, targeting, etc).
type POIAbridged struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Id/name of the platform or entity providing the POI data
	Asset *string `json:"asset,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// Target object pointing azimuth angle, in degrees (for target with sensing or emitting capability)
	Az *float64 `json:"az,omitempty"`

	// The Basic Encyclopedia Number associated with the POI, if applicable
	BeNumber *string `json:"beNumber,omitempty"`

	// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error)
	Ce *float64 `json:"ce,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// POI confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence
	Conf *float64 `json:"conf,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode POIAbridgedDataMode `json:"dataMode"`

	// Description of the POI target Object
	Desc *string `json:"desc,omitempty"`

	// Target object pointing elevation angle, in degrees (for target with sensing or emitting capability)
	El *float64 `json:"el,omitempty"`

	// Elliptical area about the lat/lon point, specified as [semi-major axis (m), semi-minor axis (m), orientation (deg) off true North at POI]
	Elle *[]float64 `json:"elle,omitempty"`

	// POI environment type (e.g., LAND, SURFACE, SUBSURFACE, UNKNOWN, etc.)
	Env *string `json:"env,omitempty"`

	// Optional array of groups used when a POI msg originates from a TAK server. Each group must be no longer than 256 characters. Groups identify a set of users targeted by the cot/poi msg.
	Groups *[]string `json:"groups,omitempty"`

	// How the event point was generated, in CoT object heirarchy notation (optional, CoT)
	How *string `json:"how,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of one or more unique identifiers of weather records associated with this POI. Each elements in array must be 36 characters or less in length.
	IdWeatherReport *[]string `json:"idWeatherReport,omitempty"`

	// Estimated identity of the point/object (e.g., FRIEND, HOSTILE, SUSPECT, ASSUMED_FRIEND, UNKNOWN, etc.)
	Ident *string `json:"ident,omitempty"`

	// WGS-84 latitude of the POI, in degrees (+N, -S), -90 to 90
	Lat *float64 `json:"lat,omitempty"`

	// Height above lat/lon point, in meters (1-sigma, if representing linear error)
	Le *float64 `json:"le,omitempty"`

	// WGS-84 longitude of the POI, in degrees (+E, -W), -180 to 180
	Lon *float64 `json:"lon,omitempty"`

	// Optional mission ID related to the POI
	Msnid *string `json:"msnid,omitempty"`

	// Name of the POI target Object
	Name string `json:"name"`

	// The orientation of a vehicle, platform or other entity described by the POI. The orientation is defined as the pointing direction of the front/nose of the object in degrees clockwise from true North at the object point.
	Orientation *float64 `json:"orientation,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// POI/object platform type (e.g., 14/GROUND, COMBAT_VEHICLE, etc.)
	Plat *string `json:"plat,omitempty"`

	// Identifier of the actual point of interest or target object, which should remain the same on subsequent POI records of the same point of interest
	Poiid string `json:"poiid"`

	// POI purpose (e.g., BDA, PPLI, TGT, TSK, etc.)
	Pps *string `json:"pps,omitempty"`

	// Priority of the  POI target Object
	Pri *int32 `json:"pri,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Specific point/object type (e.g., 82/GROUND, LIGHT_TANK, etc.)
	Spec *string `json:"spec,omitempty"`

	// Stale timestamp (optional), in ISO8601 UTC format
	Stale *time.Time `json:"stale,omitempty"`

	// Start time of event validity (optional), in ISO8601 UTC format
	Start *time.Time `json:"start,omitempty"`

	// Optional Id of an associated track related to the POI object, if applicable. This track ID should correlated the Point of Interest to a Track from the Track service.
	Trkid *string `json:"trkid,omitempty"`

	// Activity/POI timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Event type, in CoT object heirarchy notation (optional, CoT)
	Type *string `json:"type,omitempty"`

	// List of URLs to before/after images of this point of interest entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type POIAbridgedDataMode string

// A Point of Interest is loosely based on the MITRE CoT (Cursor on Target) schema (https://www.mitre.org/publications/technical-papers/cursorontarget-message-router-users-guide) and provides a simple way to specify a point on the earth for a variety of purposes (tasking, targeting, etc).
type POIFull struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Id/name of the platform or entity providing the POI data
	Asset *string `json:"asset,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// Target object pointing azimuth angle, in degrees (for target with sensing or emitting capability)
	Az *float64 `json:"az,omitempty"`

	// The Basic Encyclopedia Number associated with the POI, if applicable
	BeNumber *string `json:"beNumber,omitempty"`

	// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error)
	Ce *float64 `json:"ce,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// POI confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence
	Conf *float64 `json:"conf,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode POIFullDataMode `json:"dataMode"`

	// Description of the POI target Object
	Desc *string `json:"desc,omitempty"`

	// Target object pointing elevation angle, in degrees (for target with sensing or emitting capability)
	El *float64 `json:"el,omitempty"`

	// Elliptical area about the lat/lon point, specified as [semi-major axis (m), semi-minor axis (m), orientation (deg) off true North at POI]
	Elle *[]float64 `json:"elle,omitempty"`

	// POI environment type (e.g., LAND, SURFACE, SUBSURFACE, UNKNOWN, etc.)
	Env *string `json:"env,omitempty"`

	// Optional array of groups used when a POI msg originates from a TAK server. Each group must be no longer than 256 characters. Groups identify a set of users targeted by the cot/poi msg.
	Groups *[]string `json:"groups,omitempty"`

	// How the event point was generated, in CoT object heirarchy notation (optional, CoT)
	How *string `json:"how,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of one or more unique identifiers of weather records associated with this POI. Each elements in array must be 36 characters or less in length.
	IdWeatherReport *[]string `json:"idWeatherReport,omitempty"`

	// Estimated identity of the point/object (e.g., FRIEND, HOSTILE, SUSPECT, ASSUMED_FRIEND, UNKNOWN, etc.)
	Ident *string `json:"ident,omitempty"`

	// WGS-84 latitude of the POI, in degrees (+N, -S), -90 to 90
	Lat *float64 `json:"lat,omitempty"`

	// Height above lat/lon point, in meters (1-sigma, if representing linear error)
	Le *float64 `json:"le,omitempty"`

	// WGS-84 longitude of the POI, in degrees (+E, -W), -180 to 180
	Lon *float64 `json:"lon,omitempty"`

	// Optional mission ID related to the POI
	Msnid *string `json:"msnid,omitempty"`

	// Name of the POI target Object
	Name string `json:"name"`

	// The orientation of a vehicle, platform or other entity described by the POI. The orientation is defined as the pointing direction of the front/nose of the object in degrees clockwise from true North at the object point.
	Orientation *float64 `json:"orientation,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// POI/object platform type (e.g., 14/GROUND, COMBAT_VEHICLE, etc.)
	Plat *string `json:"plat,omitempty"`

	// Identifier of the actual point of interest or target object, which should remain the same on subsequent POI records of the same point of interest
	Poiid string `json:"poiid"`

	// POI purpose (e.g., BDA, PPLI, TGT, TSK, etc.)
	Pps *string `json:"pps,omitempty"`

	// Priority of the  POI target Object
	Pri *int32 `json:"pri,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Specific point/object type (e.g., 82/GROUND, LIGHT_TANK, etc.)
	Spec *string `json:"spec,omitempty"`

	// Array of UUIDs of the UDL data records that are related to the determination of this Point of Interest. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size.  See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/rfobservation/{uuid}).
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (GROUNDIMAGE, RFOBS) that are related to the determination of this Point of Interest. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// Stale timestamp (optional), in ISO8601 UTC format
	Stale *time.Time `json:"stale,omitempty"`

	// Start time of event validity (optional), in ISO8601 UTC format
	Start *time.Time `json:"start,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional Id of an associated track related to the POI object, if applicable. This track ID should correlated the Point of Interest to a Track from the Track service.
	Trkid *string `json:"trkid,omitempty"`

	// Activity/POI timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Event type, in CoT object heirarchy notation (optional, CoT)
	Type *string `json:"type,omitempty"`

	// List of URLs to before/after images of this point of interest entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type POIFullDataMode string

// A Point of Interest is loosely based on the MITRE CoT (Cursor on Target) schema (https://www.mitre.org/publications/technical-papers/cursorontarget-message-router-users-guide) and provides a simple way to specify a point on the earth for a variety of purposes (tasking, targeting, etc).
type POIIngest struct {
	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Id/name of the platform or entity providing the POI data
	Asset *string `json:"asset,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// Target object pointing azimuth angle, in degrees (for target with sensing or emitting capability)
	Az *float64 `json:"az,omitempty"`

	// The Basic Encyclopedia Number associated with the POI, if applicable
	BeNumber *string `json:"beNumber,omitempty"`

	// Radius of circular area about lat/lon point, in meters (1-sigma, if representing error)
	Ce *float64 `json:"ce,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// POI confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence
	Conf *float64 `json:"conf,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode POIIngestDataMode `json:"dataMode"`

	// Description of the POI target Object
	Desc *string `json:"desc,omitempty"`

	// Target object pointing elevation angle, in degrees (for target with sensing or emitting capability)
	El *float64 `json:"el,omitempty"`

	// Elliptical area about the lat/lon point, specified as [semi-major axis (m), semi-minor axis (m), orientation (deg) off true North at POI]
	Elle *[]float64 `json:"elle,omitempty"`

	// POI environment type (e.g., LAND, SURFACE, SUBSURFACE, UNKNOWN, etc.)
	Env *string `json:"env,omitempty"`

	// Optional array of groups used when a POI msg originates from a TAK server. Each group must be no longer than 256 characters. Groups identify a set of users targeted by the cot/poi msg.
	Groups *[]string `json:"groups,omitempty"`

	// How the event point was generated, in CoT object heirarchy notation (optional, CoT)
	How *string `json:"how,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Array of one or more unique identifiers of weather records associated with this POI. Each elements in array must be 36 characters or less in length.
	IdWeatherReport *[]string `json:"idWeatherReport,omitempty"`

	// Estimated identity of the point/object (e.g., FRIEND, HOSTILE, SUSPECT, ASSUMED_FRIEND, UNKNOWN, etc.)
	Ident *string `json:"ident,omitempty"`

	// WGS-84 latitude of the POI, in degrees (+N, -S), -90 to 90
	Lat *float64 `json:"lat,omitempty"`

	// Height above lat/lon point, in meters (1-sigma, if representing linear error)
	Le *float64 `json:"le,omitempty"`

	// WGS-84 longitude of the POI, in degrees (+E, -W), -180 to 180
	Lon *float64 `json:"lon,omitempty"`

	// Optional mission ID related to the POI
	Msnid *string `json:"msnid,omitempty"`

	// Name of the POI target Object
	Name string `json:"name"`

	// The orientation of a vehicle, platform or other entity described by the POI. The orientation is defined as the pointing direction of the front/nose of the object in degrees clockwise from true North at the object point.
	Orientation *float64 `json:"orientation,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// POI/object platform type (e.g., 14/GROUND, COMBAT_VEHICLE, etc.)
	Plat *string `json:"plat,omitempty"`

	// Identifier of the actual point of interest or target object, which should remain the same on subsequent POI records of the same point of interest
	Poiid string `json:"poiid"`

	// POI purpose (e.g., BDA, PPLI, TGT, TSK, etc.)
	Pps *string `json:"pps,omitempty"`

	// Priority of the  POI target Object
	Pri *int32 `json:"pri,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Specific point/object type (e.g., 82/GROUND, LIGHT_TANK, etc.)
	Spec *string `json:"spec,omitempty"`

	// Array of UUIDs of the UDL data records that are related to the determination of this Point of Interest. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size.  See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/rfobservation/{uuid}).
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (GROUNDIMAGE, RFOBS) that are related to the determination of this Point of Interest. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// Stale timestamp (optional), in ISO8601 UTC format
	Stale *time.Time `json:"stale,omitempty"`

	// Start time of event validity (optional), in ISO8601 UTC format
	Start *time.Time `json:"start,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Optional Id of an associated track related to the POI object, if applicable. This track ID should correlated the Point of Interest to a Track from the Track service.
	Trkid *string `json:"trkid,omitempty"`

	// Activity/POI timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`

	// Event type, in CoT object heirarchy notation (optional, CoT)
	Type *string `json:"type,omitempty"`

	// List of URLs to before/after images of this point of interest entity
	Urls *[]string `json:"urls,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type POIIngestDataMode string

// Details on a particular Radio Frequency (RF) band, also known as a carrier, which may be in use by any type of Entity for communications or operations.
type RFBandFull struct {
	// Name of the band of this RF range (e.g. X,K,Ku,Ka,L,S,C,UHF,VHF,EHF,SHF,UNK,VLF,HF,E,Q,V,W). See RFBandType for more details and descriptions of each band name.
	Band *string `json:"band,omitempty"`

	// RF Band frequency range bandwidth in Mhz
	Bandwidth *float64 `json:"bandwidth,omitempty"`

	// Angle between the half-power (-3 dB) points of the main lobe of the antenna, in degrees
	Beamwidth *float64 `json:"beamwidth,omitempty"`

	// Center frequency of RF frequency range, if applicable, in Mhz
	CenterFreq *float64 `json:"centerFreq,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode RFBandFullDataMode `json:"dataMode"`

	// RF Range edge gain, in dBi
	EdgeGain *float64 `json:"edgeGain,omitempty"`

	// ERP is defined as the RMS power input in decibel watts required to a lossless half-wave dipole antenna to give the same maximum power density far from the antenna as the actual transmitter. It is equal to the power input to the transmitter''s antenna multiplied by the antenna gain relative to a half-wave dipole. Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Eirp *float64 `json:"eirp,omitempty"`

	// Effective Radiated Power (ERP) is the total power in decibel watts radiated by an actual antenna relative to a half-wave dipole rather than a theoretical isotropic antenna. A half-wave dipole has a gain of 2.15 dB compared to an isotropic antenna.  EIRP(dB) = ERP (dB)+2.15 Db or EIRP (W) = 1.64*ERP(W). Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
	Erp *float64 `json:"erp,omitempty"`

	// End/maximum of transmit RF frequency range, if applicable, in Mhz
	FreqMax *float64 `json:"freqMax,omitempty"`

	// Start/minimum of transmit RF frequency range, if applicable, in Mhz
	FreqMin *float64 `json:"freqMin,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent Entity which uses this band
	IdEntity string `json:"idEntity"`

	// RF Band mode (e.g. TX, RX)
	Mode *RFBandFullMode `json:"mode,omitempty"`

	// Optional RF Band name
	Name string `json:"name"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// RF Range maximum gain, in dBi
	PeakGain *float64 `json:"peakGain,omitempty"`

	// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
	Polarization *RFBandFullPolarization `json:"polarization,omitempty"`

	// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
	Purpose *RFBandFullPurpose `json:"purpose,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type RFBandFullDataMode string

// RF Band mode (e.g. TX, RX)
type RFBandFullMode string

// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface
type RFBandFullPolarization string

// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other)
type RFBandFullPurpose string

// Related document ids
type RelatedDocumentAbridged struct {
	// List of data sources related to this document
	DataSourceRefs *[]SofDataSourceRefAbridged `json:"dataSourceRefs,omitempty"`

	// The document id of the related document
	DocumentId *string `json:"documentId,omitempty"`
}

// Related document ids
type RelatedDocumentFull struct {
	// List of data sources related to this document
	DataSourceRefs *[]SofDataSourceRefFull `json:"dataSourceRefs,omitempty"`

	// The document id of the related document
	DocumentId *string `json:"documentId,omitempty"`
}

// Related document ids
type RelatedDocumentIngest struct {
	// List of data sources related to this document
	DataSourceRefs *[]SofDataSourceRefIngest `json:"dataSourceRefs,omitempty"`

	// The document id of the related document
	DocumentId *string `json:"documentId,omitempty"`
}

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsAbridgedDataMode string

// SensorStats contain statistics on sensors related to observation production such as last reported observation time.
type SensorStatsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorStatsFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique ID of the parent sensor
	IdSensor string `json:"idSensor"`

	// Time of last reported observation in ISO 8601 UTC with microsecond precision
	LastObTime *time.Time `json:"lastObTime,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Read-only time the row was updated in the database, set automatically by the system on update
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorStatsFullDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorAbridged struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorAbridgedDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityAbridged `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeAbridged `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsAbridged `json:"sensorStats,omitempty"`
	SensorType  *SensortypeAbridged    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsAbridged `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsAbridged `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorAbridgedDataMode string

// Model representation of observation data for electro-optical based sensor phenomenologies.
type SensorFull struct {
	// Optional flag indicating if the sensor is active
	Active *bool `json:"active,omitempty"`

	// Optional US Air Force identifier for the sensor/ASR site, typically for air surveillance radar (ASR) sensors
	AfId *string `json:"afId,omitempty"`

	// The sensor type at the site. Optional field, intended primarily for ASRs
	AsrType *string `json:"asrType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Optional dissemination control required for accessing data (e.g observations) produced by this sensor. This is typically a proprietary data owner control for commercial sensors.
	DataControl *string `json:"dataControl,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorFullDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityFull `json:"entity,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensor string `json:"idSensor"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Unique name of this sensor
	SensorName string `json:"sensorName"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`

	// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
	SensorObservationType *SensorobservationtypeFull `json:"sensorObservationType,omitempty"`

	// Collection of SensorStats which contain statistics of a sensor.
	SensorStats *[]SensorStatsFull `json:"sensorStats,omitempty"`
	SensorType  *SensortypeFull    `json:"sensorType,omitempty"`

	// Collection of Sensorcharacteristics which define characteristics and capabilities of a sensor.
	Sensorcharacteristics *[]SensorcharacteristicsFull `json:"sensorcharacteristics,omitempty"`

	// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
	SensorlimitsCollection *[]SensorlimitsFull `json:"sensorlimitsCollection,omitempty"`

	// Optional short name for the sensor
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorFullDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsAbridged struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsAbridgedDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsAbridgedDataMode string

// Model representation of characteristics and capabilities of a sensor.
type SensorcharacteristicsFull struct {
	// Optical sensor camera aperture
	Aperture *float64 `json:"aperture,omitempty"`

	// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute
	AsrScanRate *float64 `json:"asrScanRate,omitempty"`

	// Azimuth rate acquisition limit (rad/min)
	AzimuthRate *float64 `json:"azimuthRate,omitempty"`

	// Sensor band
	Band *string `json:"band,omitempty"`

	// The angle of the center of a phased array sensor.
	Boresight *float64 `json:"boresight,omitempty"`

	// The number of degrees off of the boresight for the sensor (degrees).
	BoresightOffAngle *float64 `json:"boresightOffAngle,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorcharacteristicsFullDataMode `json:"dataMode"`

	// Elevation rate acquisition limit (rad/min)
	ElevationRateGeolm *float64 `json:"elevationRateGeolm,omitempty"`

	// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
	FanBeamWidth *float64 `json:"fanBeamWidth,omitempty"`

	// For radar based sensors, the focal point elevation of the radar at the site, in meters
	FocalPoint *float64 `json:"focalPoint,omitempty"`

	// Horizontal field of view
	HFOV *float64 `json:"hFOV,omitempty"`

	// Horizontal pixel resolution
	HResPixels *int32 `json:"hResPixels,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent sensor
	IdSensor string `json:"idSensor"`

	// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2)
	K *float64 `json:"k,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
	LeftClockAngle *float64 `json:"leftClockAngle,omitempty"`

	// Leftmost GEO belt longitude limit for this sensor (if applicable)
	LeftGeoBeltLimit *float64 `json:"leftGeoBeltLimit,omitempty"`

	// Angle between magnetic north and true north at the sensor site, in degrees
	MagDec *float64 `json:"magDec,omitempty"`

	// Absolute magnitude acquisition limit for optical sensors
	MagnitudeLimit *float64 `json:"magnitudeLimit,omitempty"`

	// Max deviation angle of the sensor in degrees
	MaxDeviationAngle *float64 `json:"maxDeviationAngle,omitempty"`

	// Maximum observable sensor range (km).
	MaxObservableRange *float64 `json:"maxObservableRange,omitempty"`

	// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
	MaxRangeLimit *float64 `json:"maxRangeLimit,omitempty"`

	// Minimum range measurement capability of the sensor (km).
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
	MinSignalNoiseRatio *float64 `json:"minSignalNoiseRatio,omitempty"`

	// Negative Range-rate/relative velocity limit (km/sec).
	NegativeRangeRateLimit *float64 `json:"negativeRangeRateLimit,omitempty"`

	// For radar based sensors, number of integrated pulses in a transmit cycle
	NumIntegratedPulses *int32 `json:"numIntegratedPulses,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Positive Range-rate/relative velocity limit (km/sec).
	PositiveRangeRateLimit *float64 `json:"positiveRangeRateLimit,omitempty"`

	// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second
	Prf *float64 `json:"prf,omitempty"`

	// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference
	ProbFalseAlarm *float64 `json:"probFalseAlarm,omitempty"`

	// Radar frequency of the sensor (if a radar sensor)
	RadarFrequency *float64 `json:"radarFrequency,omitempty"`

	// For radar based sensors, radar maximum unambiguous range, in km
	RadarMUR *float64 `json:"radarMUR,omitempty"`

	// Message data format transmitted by the sensor digitizer
	RadarMessageFormat *string `json:"radarMessageFormat,omitempty"`

	// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse
	RadarPulseWidth *float64 `json:"radarPulseWidth,omitempty"`

	// Radio frequency (if sensor is RF)
	RadioFrequency *float64 `json:"radioFrequency,omitempty"`

	// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
	RightClockAngle *float64 `json:"rightClockAngle,omitempty"`

	// Rightmost GEO belt longitude limit for this sensor (if applicable)
	RightGeoBeltLimit *float64 `json:"rightGeoBeltLimit,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin
	SystemNoiseTemperature *float64 `json:"systemNoiseTemperature,omitempty"`

	// Maximum taskable range of the sensor (km).
	TaskableRange *float64 `json:"taskableRange,omitempty"`

	// For tower sensors, the physical height of the sensor tower, in meters
	TowerHeight *float64 `json:"towerHeight,omitempty"`

	// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
	TrackAngle *float64 `json:"trackAngle,omitempty"`

	// Radar transmit power in Watts
	TransmitPower *float64 `json:"transmitPower,omitempty"`

	// True North correction for the sensor, in ACP (Azimunth Change Pulse) count
	TrueNorthCorrector *int32 `json:"trueNorthCorrector,omitempty"`

	// Antenna true tilt, in degrees
	TrueTilt *float64 `json:"trueTilt,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Vertical field of view
	VFOV *float64 `json:"vFOV,omitempty"`

	// Vertical pixel resolution
	VResPixels *int32 `json:"vResPixels,omitempty"`

	// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MaxRange *float64 `json:"z1MaxRange,omitempty"`

	// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z1MinRange *float64 `json:"z1MinRange,omitempty"`

	// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MaxRange *float64 `json:"z2MaxRange,omitempty"`

	// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars
	Z2MinRange *float64 `json:"z2MinRange,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorcharacteristicsFullDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsAbridgedDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsAbridgedDataMode string

// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
type SensorlimitsFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorlimitsFullDataMode `json:"dataMode"`

	// Unique identifier of the target sensor object
	IdSensor *string `json:"idSensor,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdSensorLimits *string `json:"idSensorLimits,omitempty"`

	// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees)
	LowerLeftAzimuthLimit *float64 `json:"lowerLeftAzimuthLimit,omitempty"`

	// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees)
	LowerLeftElevationLimit *float64 `json:"lowerLeftElevationLimit,omitempty"`

	// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	LowerRightAzimuthLimit *float64 `json:"lowerRightAzimuthLimit,omitempty"`

	// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees)
	LowerRightElevationLimit *float64 `json:"lowerRightElevationLimit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees)
	UpperLeftAzimuthLimit *float64 `json:"upperLeftAzimuthLimit,omitempty"`

	// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees)
	UpperLeftElevationLimit *float64 `json:"upperLeftElevationLimit,omitempty"`

	// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees)
	UpperRightAzimuthLimit *float64 `json:"upperRightAzimuthLimit,omitempty"`

	// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees)
	UpperRightElevationLimit *float64 `json:"upperRightElevationLimit,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorlimitsFullDataMode string

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// Type of observations produced by this sensor. See the /udl/sensorobservationtype service for a complete list of all available sensor types.
type SensorobservationtypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensorobservationtypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensorobservationtypeFullDataMode string

// SensortypeAbridged defines model for Sensortype_Abridged.
type SensortypeAbridged struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32            `json:"id,omitempty"`
	SensorCollection *[]SensorAbridged `json:"sensorCollection,omitempty"`

	// example_type
	Type *string `json:"type,omitempty"`
}

// SensortypeFull defines model for Sensortype_Full.
type SensortypeFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SensortypeFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id               *int32        `json:"id,omitempty"`
	SensorCollection *[]SensorFull `json:"sensorCollection,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// example_type
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SensortypeFullDataMode string

// Provides information on the dates, actors, locations, fatalities, and types of all reported political violence and protest events across the world.
type SigActAbridged struct {
	// Estimate of the accuracy that this event occurred as described/reported.
	Accuracy *int32 `json:"accuracy,omitempty"`

	// A list of one or more actors involved in the event.
	Actors *[]string `json:"actors,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// This is the average tone of all documents containing one or more mentions of this event during the 15 minute update in which it was first seen. The score ranges from -100 (extremely negative) to +100 (extremely positive). Common values range between -10 and +10, with 0 indicating neutral.
	AvgTone *float64 `json:"avgTone,omitempty"`

	// CAMEO event codes are defined in a three-level taxonomy. For events at level three in the taxonomy, this yields its level two leaf root node. For example, code 0251 (Appeal for easing of administrative sanctions) would yield an EventBaseCode of 025 (Appeal to yield). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoBaseCode *string `json:"cameoBaseCode,omitempty"`

	// This is the raw CAMEO action code describing the action that Actor1 performed upon Actor2.  Additional information about Cameo Codes can be obtained from the GDELT project documentation here: https://www.gdeltproject.org/data.html#documentation
	CameoCode *string `json:"cameoCode,omitempty"`

	// Similar to EventBaseCode, this defines the root-level category the event code falls under. For example, code 0251 (Appeal for easing of administrative sanctions) has a root code of 02 (Appeal). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoRootCode *string `json:"cameoRootCode,omitempty"`

	// The city in or near which this event occurred.
	City *string `json:"city,omitempty"`

	// Number of civilians abducted in the activity.
	CivAbd *int32 `json:"civAbd,omitempty"`

	// Number of civilians detained in the activity.
	CivDet *int32 `json:"civDet,omitempty"`

	// Number of civilians killed in the activity.
	CivKIA *int32 `json:"civKIA,omitempty"`

	// Number of civilians wounded in the activity.
	CivWound *int32 `json:"civWound,omitempty"`

	// 1 (high) for events where the reporting allows the coder to identify the event in full. That is, events where the individual happening is described by the original source in a sufficiently detailed way as to identify individual incidents, i.e. separate activities of fighting in a single location:
	//
	// 2 (lower) for events where an aggregation of information was already made by the source material that is impossible to undo in the coding process. Such events are described by the original source only as aggregates (totals) of multiple separate activities of fighting spanning over a longer period than a single, clearly defined day.
	Clarity *int32 `json:"clarity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Number of coalition members abducted in the activity.
	CoalAbd *int32 `json:"coalAbd,omitempty"`

	// Number of coalition members detained in the activity.
	CoalDet *int32 `json:"coalDet,omitempty"`

	// Number of coalition members killed in the activity.
	CoalKIA *int32 `json:"coalKIA,omitempty"`

	// Number of coalition members wounded in the activity.
	CoalWound *int32 `json:"coalWound,omitempty"`

	// Flag indicating that this attack was of a complex or coordinated nature.
	ComplexAttack *bool `json:"complexAttack,omitempty"`

	// Estimate of the confidence that this event occurred.
	Confidence *int32 `json:"confidence,omitempty"`

	// The country code for the location.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SigActAbridgedDataMode `json:"dataMode"`

	// The district in which this event occurred.
	District *string `json:"district,omitempty"`

	// The filename of the document or report.
	DocumentFilename *string `json:"documentFilename,omitempty"`

	// The source of the document or report.
	DocumentSource *string `json:"documentSource,omitempty"`

	// Number of enemy combatants abducted in the activity.
	EnemyAbd *int32 `json:"enemyAbd,omitempty"`

	// Number of enemy combatants detained in the activity.
	EnemyDet *int32 `json:"enemyDet,omitempty"`

	// Number of enemy combatants killed in the activity.
	EnemyKIA *int32 `json:"enemyKIA,omitempty"`

	// A description of the event.
	EventDescription *string `json:"eventDescription,omitempty"`

	// The approximate end time of the event, in ISO 8601 UTC format.
	EventEnd *time.Time `json:"eventEnd,omitempty"`

	// The approximate start time of the event, in ISO 8601 UTC format.
	EventStart *time.Time `json:"eventStart,omitempty"`

	// The type of event (e.g.  Military, Natural, Political, Social, etc.).
	EventType *string `json:"eventType,omitempty"`

	// Number of friendlies abducted in the activity.
	FriendlyAbd *int32 `json:"friendlyAbd,omitempty"`

	// Number of friendlies in the activity.
	FriendlyDet *int32 `json:"friendlyDet,omitempty"`

	// Number of friendlies killed in the activity.
	FriendlyKIA *int32 `json:"friendlyKIA,omitempty"`

	// Number of friendlies wounded in the activity.
	FriendlyWound *int32 `json:"friendlyWound,omitempty"`

	// Each CAMEO event code is assigned a numeric score from -10 to +10, capturing the theoretical potential impact that type of event will have on the stability of a country. This is known as the Goldstein Scale. NOTE: this score is based on the type of event, not the specifics of the actual event record being recorded  thus two riots, one with 10 people and one with 10,000, will both receive the same Goldstein score. This can be aggregated to various levels of time resolution to yield an approximation of the stability of a location over time.
	Goldstein *float64 `json:"goldstein,omitempty"`

	// Number of Host Nation members abducted in the activity.
	HostNatAbd *int32 `json:"hostNatAbd,omitempty"`

	// Number of Host Nation members detained in the activity.
	HostNatDet *int32 `json:"hostNatDet,omitempty"`

	// Number of Host Nation members killed in the activity.
	HostNatKIA *int32 `json:"hostNatKIA,omitempty"`

	// Number of Host Nation members wounded in the activity.
	HostNatWound *int32 `json:"hostNatWound,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier assigned to each event record that uniquely identifies it in the master dataset.  This ID is provided for convenience of mapping to external systems.
	IdNumber *string `json:"idNumber,omitempty"`

	// WGS-84 centroid latitude of the event location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS-84 centroid longitude of the event location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
	//
	// &nbsp;&nbsp;4Q (grid zone designator, GZD)
	//
	// &nbsp;&nbsp;FJ (the 100,000-meter square identifier)
	//
	// &nbsp;&nbsp;12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution)
	Milgrid *string `json:"milgrid,omitempty"`

	// Notes related to the documents or event.
	Notes *string `json:"notes,omitempty"`

	// This is the total number of source documents containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumArticles *int32 `json:"numArticles,omitempty"`

	// This is the total number of mentions of this event across all source documents during the 15 minute update in which it was first seen. Multiple references to an event within a single document also contribute to this count. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumMentions *int32 `json:"numMentions,omitempty"`

	// This is the total number of information sources containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumSources *int32 `json:"numSources,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The province in which this event occurred.
	Province *string `json:"province,omitempty"`

	// Related document ids
	RelatedDocs *[]RelatedDocumentAbridged `json:"relatedDocs,omitempty"`

	// The reporting unit.
	RepUnit *string `json:"repUnit,omitempty"`

	// The activity the unit was engaged in.
	RepUnitActivity *string `json:"repUnitActivity,omitempty"`

	// The reporting unit type.
	RepUnitType *string `json:"repUnitType,omitempty"`

	// Date of the report or filing.
	ReportDate time.Time `json:"reportDate"`

	// Number of side A members abducted in the activity.
	SideAAbd *int32 `json:"sideAAbd,omitempty"`

	// Number of side A members detained in the activity.
	SideADet *int32 `json:"sideADet,omitempty"`

	// Number of side A members killed in the activity.
	SideAKIA *int32 `json:"sideAKIA,omitempty"`

	// Number of side A members wounded in the activity.
	SideAWound *int32 `json:"sideAWound,omitempty"`

	// Number of side B members abducted in the activity.
	SideBAbd *int32 `json:"sideBAbd,omitempty"`

	// Number of side B members detained in the activity.
	SideBDet *int32 `json:"sideBDet,omitempty"`

	// Number of side B members killed in the activity.
	SideBKIA *int32 `json:"sideBKIA,omitempty"`

	// Number of side B members wounded in the activity.
	SideBWound *int32 `json:"sideBWound,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This field records the URL or citation of the first news report it found this event in. In most cases this is the first report it saw the article in, but due to the timing and flow of news reports through the processing pipeline, this may not always be the very first report, but is at least in the first few reports.
	SourceUrl *string `json:"sourceUrl,omitempty"`

	// A summary of the event.
	Summary *string `json:"summary,omitempty"`

	// The name of the target.  The target may be an individual, an entity, or a country/region.
	Target *string `json:"target,omitempty"`

	// Area in which important military events occur or are progressing.  A theater can include the entirety of the airspace, land and sea area that is or that may potentially become involved in war operations.
	Theater *string `json:"theater,omitempty"`

	// The mode of this attack or event (e.g. Direct Fire, IED Explosion, etc.).
	TypeOfAttack *string `json:"typeOfAttack,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SigActAbridgedDataMode string

// Provides information on the dates, actors, locations, fatalities, and types of all reported political violence and protest events across the world.
type SigActFull struct {
	// Estimate of the accuracy that this event occurred as described/reported.
	Accuracy *int32 `json:"accuracy,omitempty"`

	// A list of one or more actors involved in the event.
	Actors *[]string `json:"actors,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// This is the average tone of all documents containing one or more mentions of this event during the 15 minute update in which it was first seen. The score ranges from -100 (extremely negative) to +100 (extremely positive). Common values range between -10 and +10, with 0 indicating neutral.
	AvgTone *float64 `json:"avgTone,omitempty"`

	// CAMEO event codes are defined in a three-level taxonomy. For events at level three in the taxonomy, this yields its level two leaf root node. For example, code 0251 (Appeal for easing of administrative sanctions) would yield an EventBaseCode of 025 (Appeal to yield). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoBaseCode *string `json:"cameoBaseCode,omitempty"`

	// This is the raw CAMEO action code describing the action that Actor1 performed upon Actor2.  Additional information about Cameo Codes can be obtained from the GDELT project documentation here: https://www.gdeltproject.org/data.html#documentation
	CameoCode *string `json:"cameoCode,omitempty"`

	// Similar to EventBaseCode, this defines the root-level category the event code falls under. For example, code 0251 (Appeal for easing of administrative sanctions) has a root code of 02 (Appeal). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoRootCode *string `json:"cameoRootCode,omitempty"`

	// The city in or near which this event occurred.
	City *string `json:"city,omitempty"`

	// Number of civilians abducted in the activity.
	CivAbd *int32 `json:"civAbd,omitempty"`

	// Number of civilians detained in the activity.
	CivDet *int32 `json:"civDet,omitempty"`

	// Number of civilians killed in the activity.
	CivKIA *int32 `json:"civKIA,omitempty"`

	// Number of civilians wounded in the activity.
	CivWound *int32 `json:"civWound,omitempty"`

	// 1 (high) for events where the reporting allows the coder to identify the event in full. That is, events where the individual happening is described by the original source in a sufficiently detailed way as to identify individual incidents, i.e. separate activities of fighting in a single location:
	//
	// 2 (lower) for events where an aggregation of information was already made by the source material that is impossible to undo in the coding process. Such events are described by the original source only as aggregates (totals) of multiple separate activities of fighting spanning over a longer period than a single, clearly defined day.
	Clarity *int32 `json:"clarity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Number of coalition members abducted in the activity.
	CoalAbd *int32 `json:"coalAbd,omitempty"`

	// Number of coalition members detained in the activity.
	CoalDet *int32 `json:"coalDet,omitempty"`

	// Number of coalition members killed in the activity.
	CoalKIA *int32 `json:"coalKIA,omitempty"`

	// Number of coalition members wounded in the activity.
	CoalWound *int32 `json:"coalWound,omitempty"`

	// Flag indicating that this attack was of a complex or coordinated nature.
	ComplexAttack *bool `json:"complexAttack,omitempty"`

	// Estimate of the confidence that this event occurred.
	Confidence *int32 `json:"confidence,omitempty"`

	// The country code for the location.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SigActFullDataMode `json:"dataMode"`

	// The district in which this event occurred.
	District *string `json:"district,omitempty"`

	// The filename of the document or report.
	DocumentFilename *string `json:"documentFilename,omitempty"`

	// The source of the document or report.
	DocumentSource *string `json:"documentSource,omitempty"`

	// Number of enemy combatants abducted in the activity.
	EnemyAbd *int32 `json:"enemyAbd,omitempty"`

	// Number of enemy combatants detained in the activity.
	EnemyDet *int32 `json:"enemyDet,omitempty"`

	// Number of enemy combatants killed in the activity.
	EnemyKIA *int32 `json:"enemyKIA,omitempty"`

	// A description of the event.
	EventDescription *string `json:"eventDescription,omitempty"`

	// The approximate end time of the event, in ISO 8601 UTC format.
	EventEnd *time.Time `json:"eventEnd,omitempty"`

	// The approximate start time of the event, in ISO 8601 UTC format.
	EventStart *time.Time `json:"eventStart,omitempty"`

	// The type of event (e.g.  Military, Natural, Political, Social, etc.).
	EventType *string `json:"eventType,omitempty"`

	// Number of friendlies abducted in the activity.
	FriendlyAbd *int32 `json:"friendlyAbd,omitempty"`

	// Number of friendlies in the activity.
	FriendlyDet *int32 `json:"friendlyDet,omitempty"`

	// Number of friendlies killed in the activity.
	FriendlyKIA *int32 `json:"friendlyKIA,omitempty"`

	// Number of friendlies wounded in the activity.
	FriendlyWound *int32 `json:"friendlyWound,omitempty"`

	// Each CAMEO event code is assigned a numeric score from -10 to +10, capturing the theoretical potential impact that type of event will have on the stability of a country. This is known as the Goldstein Scale. NOTE: this score is based on the type of event, not the specifics of the actual event record being recorded  thus two riots, one with 10 people and one with 10,000, will both receive the same Goldstein score. This can be aggregated to various levels of time resolution to yield an approximation of the stability of a location over time.
	Goldstein *float64 `json:"goldstein,omitempty"`

	// Number of Host Nation members abducted in the activity.
	HostNatAbd *int32 `json:"hostNatAbd,omitempty"`

	// Number of Host Nation members detained in the activity.
	HostNatDet *int32 `json:"hostNatDet,omitempty"`

	// Number of Host Nation members killed in the activity.
	HostNatKIA *int32 `json:"hostNatKIA,omitempty"`

	// Number of Host Nation members wounded in the activity.
	HostNatWound *int32 `json:"hostNatWound,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier assigned to each event record that uniquely identifies it in the master dataset.  This ID is provided for convenience of mapping to external systems.
	IdNumber *string `json:"idNumber,omitempty"`

	// WGS-84 centroid latitude of the event location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS-84 centroid longitude of the event location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
	//
	// &nbsp;&nbsp;4Q (grid zone designator, GZD)
	//
	// &nbsp;&nbsp;FJ (the 100,000-meter square identifier)
	//
	// &nbsp;&nbsp;12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution)
	Milgrid *string `json:"milgrid,omitempty"`

	// Notes related to the documents or event.
	Notes *string `json:"notes,omitempty"`

	// This is the total number of source documents containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumArticles *int32 `json:"numArticles,omitempty"`

	// This is the total number of mentions of this event across all source documents during the 15 minute update in which it was first seen. Multiple references to an event within a single document also contribute to this count. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumMentions *int32 `json:"numMentions,omitempty"`

	// This is the total number of information sources containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumSources *int32 `json:"numSources,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The province in which this event occurred.
	Province *string `json:"province,omitempty"`

	// Related document ids
	RelatedDocs *[]RelatedDocumentFull `json:"relatedDocs,omitempty"`

	// The reporting unit.
	RepUnit *string `json:"repUnit,omitempty"`

	// The activity the unit was engaged in.
	RepUnitActivity *string `json:"repUnitActivity,omitempty"`

	// The reporting unit type.
	RepUnitType *string `json:"repUnitType,omitempty"`

	// Date of the report or filing.
	ReportDate time.Time `json:"reportDate"`

	// Number of side A members abducted in the activity.
	SideAAbd *int32 `json:"sideAAbd,omitempty"`

	// Number of side A members detained in the activity.
	SideADet *int32 `json:"sideADet,omitempty"`

	// Number of side A members killed in the activity.
	SideAKIA *int32 `json:"sideAKIA,omitempty"`

	// Number of side A members wounded in the activity.
	SideAWound *int32 `json:"sideAWound,omitempty"`

	// Number of side B members abducted in the activity.
	SideBAbd *int32 `json:"sideBAbd,omitempty"`

	// Number of side B members detained in the activity.
	SideBDet *int32 `json:"sideBDet,omitempty"`

	// Number of side B members killed in the activity.
	SideBKIA *int32 `json:"sideBKIA,omitempty"`

	// Number of side B members wounded in the activity.
	SideBWound *int32 `json:"sideBWound,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This field records the URL or citation of the first news report it found this event in. In most cases this is the first report it saw the article in, but due to the timing and flow of news reports through the processing pipeline, this may not always be the very first report, but is at least in the first few reports.
	SourceUrl *string `json:"sourceUrl,omitempty"`

	// A summary of the event.
	Summary *string `json:"summary,omitempty"`

	// The name of the target.  The target may be an individual, an entity, or a country/region.
	Target *string `json:"target,omitempty"`

	// Area in which important military events occur or are progressing.  A theater can include the entirety of the airspace, land and sea area that is or that may potentially become involved in war operations.
	Theater *string `json:"theater,omitempty"`

	// The mode of this attack or event (e.g. Direct Fire, IED Explosion, etc.).
	TypeOfAttack *string `json:"typeOfAttack,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SigActFullDataMode string

// Provides information on the dates, actors, locations, fatalities, and types of all reported political violence and protest events across the world.
type SigActIngest struct {
	// Estimate of the accuracy that this event occurred as described/reported.
	Accuracy *int32 `json:"accuracy,omitempty"`

	// A list of one or more actors involved in the event.
	Actors *[]string `json:"actors,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// This is the average tone of all documents containing one or more mentions of this event during the 15 minute update in which it was first seen. The score ranges from -100 (extremely negative) to +100 (extremely positive). Common values range between -10 and +10, with 0 indicating neutral.
	AvgTone *float64 `json:"avgTone,omitempty"`

	// CAMEO event codes are defined in a three-level taxonomy. For events at level three in the taxonomy, this yields its level two leaf root node. For example, code 0251 (Appeal for easing of administrative sanctions) would yield an EventBaseCode of 025 (Appeal to yield). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoBaseCode *string `json:"cameoBaseCode,omitempty"`

	// This is the raw CAMEO action code describing the action that Actor1 performed upon Actor2.  Additional information about Cameo Codes can be obtained from the GDELT project documentation here: https://www.gdeltproject.org/data.html#documentation
	CameoCode *string `json:"cameoCode,omitempty"`

	// Similar to EventBaseCode, this defines the root-level category the event code falls under. For example, code 0251 (Appeal for easing of administrative sanctions) has a root code of 02 (Appeal). This makes it possible to aggregate events at various resolutions of specificity. For events at levels two or one, this field will be set to EventCode.
	CameoRootCode *string `json:"cameoRootCode,omitempty"`

	// The city in or near which this event occurred.
	City *string `json:"city,omitempty"`

	// Number of civilians abducted in the activity.
	CivAbd *int32 `json:"civAbd,omitempty"`

	// Number of civilians detained in the activity.
	CivDet *int32 `json:"civDet,omitempty"`

	// Number of civilians killed in the activity.
	CivKIA *int32 `json:"civKIA,omitempty"`

	// Number of civilians wounded in the activity.
	CivWound *int32 `json:"civWound,omitempty"`

	// 1 (high) for events where the reporting allows the coder to identify the event in full. That is, events where the individual happening is described by the original source in a sufficiently detailed way as to identify individual incidents, i.e. separate activities of fighting in a single location:
	//
	// 2 (lower) for events where an aggregation of information was already made by the source material that is impossible to undo in the coding process. Such events are described by the original source only as aggregates (totals) of multiple separate activities of fighting spanning over a longer period than a single, clearly defined day.
	Clarity *int32 `json:"clarity,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	ClassificationMarking string `json:"classificationMarking"`

	// Number of coalition members abducted in the activity.
	CoalAbd *int32 `json:"coalAbd,omitempty"`

	// Number of coalition members detained in the activity.
	CoalDet *int32 `json:"coalDet,omitempty"`

	// Number of coalition members killed in the activity.
	CoalKIA *int32 `json:"coalKIA,omitempty"`

	// Number of coalition members wounded in the activity.
	CoalWound *int32 `json:"coalWound,omitempty"`

	// Flag indicating that this attack was of a complex or coordinated nature.
	ComplexAttack *bool `json:"complexAttack,omitempty"`

	// Estimate of the confidence that this event occurred.
	Confidence *int32 `json:"confidence,omitempty"`

	// The country code for the location.
	CountryCode *string `json:"countryCode,omitempty"`

	// Time the row was created in the database, auto-populated by the system, example = 2018-01-01T16:00:00.123Z
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SigActIngestDataMode `json:"dataMode"`

	// The district in which this event occurred.
	District *string `json:"district,omitempty"`

	// The filename of the document or report.
	DocumentFilename *string `json:"documentFilename,omitempty"`

	// The source of the document or report.
	DocumentSource *string `json:"documentSource,omitempty"`

	// Number of enemy combatants abducted in the activity.
	EnemyAbd *int32 `json:"enemyAbd,omitempty"`

	// Number of enemy combatants detained in the activity.
	EnemyDet *int32 `json:"enemyDet,omitempty"`

	// Number of enemy combatants killed in the activity.
	EnemyKIA *int32 `json:"enemyKIA,omitempty"`

	// A description of the event.
	EventDescription *string `json:"eventDescription,omitempty"`

	// The approximate end time of the event, in ISO 8601 UTC format.
	EventEnd *time.Time `json:"eventEnd,omitempty"`

	// The approximate start time of the event, in ISO 8601 UTC format.
	EventStart *time.Time `json:"eventStart,omitempty"`

	// The type of event (e.g.  Military, Natural, Political, Social, etc.).
	EventType *string `json:"eventType,omitempty"`

	// Number of friendlies abducted in the activity.
	FriendlyAbd *int32 `json:"friendlyAbd,omitempty"`

	// Number of friendlies in the activity.
	FriendlyDet *int32 `json:"friendlyDet,omitempty"`

	// Number of friendlies killed in the activity.
	FriendlyKIA *int32 `json:"friendlyKIA,omitempty"`

	// Number of friendlies wounded in the activity.
	FriendlyWound *int32 `json:"friendlyWound,omitempty"`

	// Each CAMEO event code is assigned a numeric score from -10 to +10, capturing the theoretical potential impact that type of event will have on the stability of a country. This is known as the Goldstein Scale. NOTE: this score is based on the type of event, not the specifics of the actual event record being recorded  thus two riots, one with 10 people and one with 10,000, will both receive the same Goldstein score. This can be aggregated to various levels of time resolution to yield an approximation of the stability of a location over time.
	Goldstein *float64 `json:"goldstein,omitempty"`

	// Number of Host Nation members abducted in the activity.
	HostNatAbd *int32 `json:"hostNatAbd,omitempty"`

	// Number of Host Nation members detained in the activity.
	HostNatDet *int32 `json:"hostNatDet,omitempty"`

	// Number of Host Nation members killed in the activity.
	HostNatKIA *int32 `json:"hostNatKIA,omitempty"`

	// Number of Host Nation members wounded in the activity.
	HostNatWound *int32 `json:"hostNatWound,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier assigned to each event record that uniquely identifies it in the master dataset.  This ID is provided for convenience of mapping to external systems.
	IdNumber *string `json:"idNumber,omitempty"`

	// WGS-84 centroid latitude of the event location, in degrees. -90 to 90 degrees (negative values south of equator)
	Lat *float64 `json:"lat,omitempty"`

	// WGS-84 centroid longitude of the event location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian)
	Lon *float64 `json:"lon,omitempty"`

	// The Military Grid Reference System is the geocoordinate standard used by NATO militaries for locating points on Earth. The MGRS is derived from the Universal Transverse Mercator (UTM) grid system and the Universal Polar Stereographic (UPS) grid system, but uses a different labeling convention. The MGRS is used as geocode for the entire Earth. Example of an milgrid coordinate, or grid reference, would be 4QFJ12345678, which consists of three parts:
	//
	// &nbsp;&nbsp;4Q (grid zone designator, GZD)
	//
	// &nbsp;&nbsp;FJ (the 100,000-meter square identifier)
	//
	// &nbsp;&nbsp;12345678 (numerical location; easting is 1234 and northing is 5678, in this case specifying a location with 10 m resolution)
	Milgrid *string `json:"milgrid,omitempty"`

	// Notes related to the documents or event.
	Notes *string `json:"notes,omitempty"`

	// This is the total number of source documents containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumArticles *int32 `json:"numArticles,omitempty"`

	// This is the total number of mentions of this event across all source documents during the 15 minute update in which it was first seen. Multiple references to an event within a single document also contribute to this count. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumMentions *int32 `json:"numMentions,omitempty"`

	// This is the total number of information sources containing one or more mentions of this event during the 15 minute update in which it was first seen. This can be used as a method of assessing the importance of an event: the more discussion of that event, the more likely it is to be significant.
	NumSources *int32 `json:"numSources,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The province in which this event occurred.
	Province *string `json:"province,omitempty"`

	// Related document ids
	RelatedDocs *[]RelatedDocumentIngest `json:"relatedDocs,omitempty"`

	// The reporting unit.
	RepUnit *string `json:"repUnit,omitempty"`

	// The activity the unit was engaged in.
	RepUnitActivity *string `json:"repUnitActivity,omitempty"`

	// The reporting unit type.
	RepUnitType *string `json:"repUnitType,omitempty"`

	// Date of the report or filing.
	ReportDate time.Time `json:"reportDate"`

	// Number of side A members abducted in the activity.
	SideAAbd *int32 `json:"sideAAbd,omitempty"`

	// Number of side A members detained in the activity.
	SideADet *int32 `json:"sideADet,omitempty"`

	// Number of side A members killed in the activity.
	SideAKIA *int32 `json:"sideAKIA,omitempty"`

	// Number of side A members wounded in the activity.
	SideAWound *int32 `json:"sideAWound,omitempty"`

	// Number of side B members abducted in the activity.
	SideBAbd *int32 `json:"sideBAbd,omitempty"`

	// Number of side B members detained in the activity.
	SideBDet *int32 `json:"sideBDet,omitempty"`

	// Number of side B members killed in the activity.
	SideBKIA *int32 `json:"sideBKIA,omitempty"`

	// Number of side B members wounded in the activity.
	SideBWound *int32 `json:"sideBWound,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// This field records the URL or citation of the first news report it found this event in. In most cases this is the first report it saw the article in, but due to the timing and flow of news reports through the processing pipeline, this may not always be the very first report, but is at least in the first few reports.
	SourceUrl *string `json:"sourceUrl,omitempty"`

	// A summary of the event.
	Summary *string `json:"summary,omitempty"`

	// The name of the target.  The target may be an individual, an entity, or a country/region.
	Target *string `json:"target,omitempty"`

	// Area in which important military events occur or are progressing.  A theater can include the entirety of the airspace, land and sea area that is or that may potentially become involved in war operations.
	Theater *string `json:"theater,omitempty"`

	// The mode of this attack or event (e.g. Direct Fire, IED Explosion, etc.).
	TypeOfAttack *string `json:"typeOfAttack,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SigActIngestDataMode string

// SiteStatusAbridged defines model for SiteStatus_Abridged.
type SiteStatusAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Estimated number of cold missiles of all types remaining in weapons system inventory
	ColdInventory *int32 `json:"coldInventory,omitempty"`

	// The communications component causing the platform or system to be less than fully operational
	CommImpairment *string `json:"commImpairment,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteStatusAbridgedDataMode `json:"dataMode"`

	// Estimated number of hot missiles of all types remaining in weapons system inventory
	HotInventory *int32 `json:"hotInventory,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site, if this status is associated with a fixed site or platform
	IdSite *string `json:"idSite,omitempty"`

	// Array of Link item(s) for which status is available and reported (ATDL, IJMS,  LINK-1, LINK-11, LINK-11B, LINK-16).  This array must be the same length as the linkStatus array.
	Link *[]string `json:"link,omitempty"`

	// Array of the status (AVAILABLE, DEGRADED, NOT AVAILABLE, etc.) for each links in the link array. This array must be the same length as the link array, and the status must correspond to the appropriate position index in the link array.
	LinkStatus *[]string `json:"linkStatus,omitempty"`

	// Array of specific missile types for which an estimated inventory count is available (e.g. GMD TYPE A, HARPOON, TOMAHAWK, etc.).  This array must be the same length as the missileInventory array.
	Missile *[]string `json:"missile,omitempty"`

	// Array of the quantity of each of the missile items.  This array must be the same length as the missile array, and the values must correspond to appropriate position index in the missile array.
	MissileInventory *[]int32 `json:"missileInventory,omitempty"`

	// Alternate Identifier for a mobile or transportable platform provided by source
	MobileAltId *string `json:"mobileAltId,omitempty"`

	// The operational status of the platform (e.g. Fully Operational, Partially Operational, Not Operational, etc.)
	OpsCapability *string `json:"opsCapability,omitempty"`

	// The primary component degrading the operational capability of the platform or system
	OpsImpairment *string `json:"opsImpairment,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Position Engagement Status flag, Indicating whether this platform is initiating multiple simultaneous engagements.  A value of 1/True indicates the platform is initiating multiple simultaneous engagements.
	Pes *bool `json:"pes,omitempty"`

	// The POI (point of interest) ID related to this platform, if available
	Poiid *string `json:"poiid,omitempty"`

	// Array of the status (NON-OPERATIONAL, OPERATIONAL, OFF) for each radar system in the radarSystem array. This array must be the same length as the radarSystem array, and the status must correspond to the appropriate position index in the radarSystem array.
	RadarStatus *[]string `json:"radarStatus,omitempty"`

	// Array of radar system(s) for which status is available and reported (ACQUISITION, IFFSIF, ILLUMINATING, MODE-4, PRIMARY SURVEILLANCE, SECONDARY SURVEILLANCE, TERTIARY SURVEILLANCE). This array must be the same length as the radarStatus array
	RadarSystem *[]string `json:"radarSystem,omitempty"`

	// SAM sensor radar surveillance mode (Active, Passive, Off)
	RadiateMode *string `json:"radiateMode,omitempty"`

	// Time of report, in ISO8601 UTC format
	ReportTime *time.Time `json:"reportTime,omitempty"`

	// The state of a SAM unit (e.g. Initialization, Standby, Reorientation, etc.)
	SamMode *string `json:"samMode,omitempty"`

	// Optional site type or further detail of type.  Intended for, but not limited to, Link-16 site type specifications (e.g. ADOC, GACC, SOC, TACC, etc.)
	SiteType *string `json:"siteType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Description of the time function associated with the reportTime (e.g. Activation, Deactivation, Arrival, Departure, etc.), if applicable
	TimeFunction *string `json:"timeFunction,omitempty"`

	// The track ID related to this platform (if mobile or transportable), if available
	TrackId *string `json:"trackId,omitempty"`

	// Link-16 specific reference track number
	TrackRefL16 *string `json:"trackRefL16,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteStatusAbridgedDataMode string

// SiteStatusFull defines model for SiteStatus_Full.
type SiteStatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Estimated number of cold missiles of all types remaining in weapons system inventory
	ColdInventory *int32 `json:"coldInventory,omitempty"`

	// The communications component causing the platform or system to be less than fully operational
	CommImpairment *string `json:"commImpairment,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteStatusFullDataMode `json:"dataMode"`

	// Estimated number of hot missiles of all types remaining in weapons system inventory
	HotInventory *int32 `json:"hotInventory,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site, if this status is associated with a fixed site or platform
	IdSite *string `json:"idSite,omitempty"`

	// Array of Link item(s) for which status is available and reported (ATDL, IJMS,  LINK-1, LINK-11, LINK-11B, LINK-16).  This array must be the same length as the linkStatus array.
	Link *[]string `json:"link,omitempty"`

	// Array of the status (AVAILABLE, DEGRADED, NOT AVAILABLE, etc.) for each links in the link array. This array must be the same length as the link array, and the status must correspond to the appropriate position index in the link array.
	LinkStatus *[]string `json:"linkStatus,omitempty"`

	// Array of specific missile types for which an estimated inventory count is available (e.g. GMD TYPE A, HARPOON, TOMAHAWK, etc.).  This array must be the same length as the missileInventory array.
	Missile *[]string `json:"missile,omitempty"`

	// Array of the quantity of each of the missile items.  This array must be the same length as the missile array, and the values must correspond to appropriate position index in the missile array.
	MissileInventory *[]int32 `json:"missileInventory,omitempty"`

	// Alternate Identifier for a mobile or transportable platform provided by source
	MobileAltId *string `json:"mobileAltId,omitempty"`

	// The operational status of the platform (e.g. Fully Operational, Partially Operational, Not Operational, etc.)
	OpsCapability *string `json:"opsCapability,omitempty"`

	// The primary component degrading the operational capability of the platform or system
	OpsImpairment *string `json:"opsImpairment,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Position Engagement Status flag, Indicating whether this platform is initiating multiple simultaneous engagements.  A value of 1/True indicates the platform is initiating multiple simultaneous engagements.
	Pes *bool `json:"pes,omitempty"`

	// The POI (point of interest) ID related to this platform, if available
	Poiid *string `json:"poiid,omitempty"`

	// Array of the status (NON-OPERATIONAL, OPERATIONAL, OFF) for each radar system in the radarSystem array. This array must be the same length as the radarSystem array, and the status must correspond to the appropriate position index in the radarSystem array.
	RadarStatus *[]string `json:"radarStatus,omitempty"`

	// Array of radar system(s) for which status is available and reported (ACQUISITION, IFFSIF, ILLUMINATING, MODE-4, PRIMARY SURVEILLANCE, SECONDARY SURVEILLANCE, TERTIARY SURVEILLANCE). This array must be the same length as the radarStatus array
	RadarSystem *[]string `json:"radarSystem,omitempty"`

	// SAM sensor radar surveillance mode (Active, Passive, Off)
	RadiateMode *string `json:"radiateMode,omitempty"`

	// Time of report, in ISO8601 UTC format
	ReportTime *time.Time `json:"reportTime,omitempty"`

	// The state of a SAM unit (e.g. Initialization, Standby, Reorientation, etc.)
	SamMode *string `json:"samMode,omitempty"`

	// Optional site type or further detail of type.  Intended for, but not limited to, Link-16 site type specifications (e.g. ADOC, GACC, SOC, TACC, etc.)
	SiteType *string `json:"siteType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Description of the time function associated with the reportTime (e.g. Activation, Deactivation, Arrival, Departure, etc.), if applicable
	TimeFunction *string `json:"timeFunction,omitempty"`

	// The track ID related to this platform (if mobile or transportable), if available
	TrackId *string `json:"trackId,omitempty"`

	// Link-16 specific reference track number
	TrackRefL16 *string `json:"trackRefL16,omitempty"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteStatusFullDataMode string

// SiteStatusIngest defines model for SiteStatus_Ingest.
type SiteStatusIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Estimated number of cold missiles of all types remaining in weapons system inventory
	ColdInventory *int32 `json:"coldInventory,omitempty"`

	// The communications component causing the platform or system to be less than fully operational
	CommImpairment *string `json:"commImpairment,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteStatusIngestDataMode `json:"dataMode"`

	// Estimated number of hot missiles of all types remaining in weapons system inventory
	HotInventory *int32 `json:"hotInventory,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// The ID of the site, if this status is associated with a fixed site or platform
	IdSite *string `json:"idSite,omitempty"`

	// Array of Link item(s) for which status is available and reported (ATDL, IJMS,  LINK-1, LINK-11, LINK-11B, LINK-16).  This array must be the same length as the linkStatus array.
	Link *[]string `json:"link,omitempty"`

	// Array of the status (AVAILABLE, DEGRADED, NOT AVAILABLE, etc.) for each links in the link array. This array must be the same length as the link array, and the status must correspond to the appropriate position index in the link array.
	LinkStatus *[]string `json:"linkStatus,omitempty"`

	// Array of specific missile types for which an estimated inventory count is available (e.g. GMD TYPE A, HARPOON, TOMAHAWK, etc.).  This array must be the same length as the missileInventory array.
	Missile *[]string `json:"missile,omitempty"`

	// Array of the quantity of each of the missile items.  This array must be the same length as the missile array, and the values must correspond to appropriate position index in the missile array.
	MissileInventory *[]int32 `json:"missileInventory,omitempty"`

	// Alternate Identifier for a mobile or transportable platform provided by source
	MobileAltId *string `json:"mobileAltId,omitempty"`

	// The operational status of the platform (e.g. Fully Operational, Partially Operational, Not Operational, etc.)
	OpsCapability *string `json:"opsCapability,omitempty"`

	// The primary component degrading the operational capability of the platform or system
	OpsImpairment *string `json:"opsImpairment,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Position Engagement Status flag, Indicating whether this platform is initiating multiple simultaneous engagements.  A value of 1/True indicates the platform is initiating multiple simultaneous engagements.
	Pes *bool `json:"pes,omitempty"`

	// The POI (point of interest) ID related to this platform, if available
	Poiid *string `json:"poiid,omitempty"`

	// Array of the status (NON-OPERATIONAL, OPERATIONAL, OFF) for each radar system in the radarSystem array. This array must be the same length as the radarSystem array, and the status must correspond to the appropriate position index in the radarSystem array.
	RadarStatus *[]string `json:"radarStatus,omitempty"`

	// Array of radar system(s) for which status is available and reported (ACQUISITION, IFFSIF, ILLUMINATING, MODE-4, PRIMARY SURVEILLANCE, SECONDARY SURVEILLANCE, TERTIARY SURVEILLANCE). This array must be the same length as the radarStatus array
	RadarSystem *[]string `json:"radarSystem,omitempty"`

	// SAM sensor radar surveillance mode (Active, Passive, Off)
	RadiateMode *string `json:"radiateMode,omitempty"`

	// Time of report, in ISO8601 UTC format
	ReportTime *time.Time `json:"reportTime,omitempty"`

	// The state of a SAM unit (e.g. Initialization, Standby, Reorientation, etc.)
	SamMode *string `json:"samMode,omitempty"`

	// Optional site type or further detail of type.  Intended for, but not limited to, Link-16 site type specifications (e.g. ADOC, GACC, SOC, TACC, etc.)
	SiteType *string `json:"siteType,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Description of the time function associated with the reportTime (e.g. Activation, Deactivation, Arrival, Departure, etc.), if applicable
	TimeFunction *string `json:"timeFunction,omitempty"`

	// The track ID related to this platform (if mobile or transportable), if available
	TrackId *string `json:"trackId,omitempty"`

	// Link-16 specific reference track number
	TrackRefL16 *string `json:"trackRefL16,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteStatusIngestDataMode string

// Properties and characteristics of a site entity, such as an airbase, airfield, naval station, etc.
type SiteAbridged struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteAbridgedDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity EntityAbridged `json:"entity"`

	// The Federal Aviation Administration (FAA) Location ID of this site, if applicable
	Faa *string `json:"faa,omitempty"`

	// The International Air Transport Association (IATA) code of this site, if applicable
	Iata *string `json:"iata,omitempty"`

	// The International Civil Aviation Organization (ICAO) code of this site, if applicable
	Icao *string `json:"icao,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// The length of the longest runway at this site, if applicable, in meters
	MaxRunwayLength *int32 `json:"maxRunwayLength,omitempty"`

	// The name of this site
	Name string `json:"name"`

	// Optional notes/comments for the site
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of runways at the site, if applicable
	Runways *int32 `json:"runways,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of this site (AIRBASE, AIRFIELD, AIRPORT, NAVAL STATION, etc.)
	Type *string `json:"type,omitempty"`

	// The use authorization type of this site (e.g MILITARY, CIVIL, JOINT-USE, etc.)
	Usage *string `json:"usage,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteAbridgedDataMode string

// Properties and characteristics of a site entity, such as an airbase, airfield, naval station, etc.
type SiteFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteFullDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity *EntityFull `json:"entity,omitempty"`

	// The Federal Aviation Administration (FAA) Location ID of this site, if applicable
	Faa *string `json:"faa,omitempty"`

	// The International Air Transport Association (IATA) code of this site, if applicable
	Iata *string `json:"iata,omitempty"`

	// The International Civil Aviation Organization (ICAO) code of this site, if applicable
	Icao *string `json:"icao,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// The length of the longest runway at this site, if applicable, in meters
	MaxRunwayLength *int32 `json:"maxRunwayLength,omitempty"`

	// The name of this site
	Name string `json:"name"`

	// Optional notes/comments for the site
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of runways at the site, if applicable
	Runways *int32 `json:"runways,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of this site (AIRBASE, AIRFIELD, AIRPORT, NAVAL STATION, etc.)
	Type *string `json:"type,omitempty"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// The use authorization type of this site (e.g MILITARY, CIVIL, JOINT-USE, etc.)
	Usage *string `json:"usage,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteFullDataMode string

// Properties and characteristics of a site entity, such as an airbase, airfield, naval station, etc.
type SiteIngest struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SiteIngestDataMode `json:"dataMode"`

	// An entity is a generic representation of any object within a space/SSA system such as sensors, on-orbit objects, RF Emitters, space craft buses, etc. An entity can have an operating unit, a location (if terrestrial), and statuses.
	Entity EntityIngest `json:"entity"`

	// The Federal Aviation Administration (FAA) Location ID of this site, if applicable
	Faa *string `json:"faa,omitempty"`

	// The International Air Transport Association (IATA) code of this site, if applicable
	Iata *string `json:"iata,omitempty"`

	// The International Civil Aviation Organization (ICAO) code of this site, if applicable
	Icao *string `json:"icao,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// The length of the longest runway at this site, if applicable, in meters
	MaxRunwayLength *int32 `json:"maxRunwayLength,omitempty"`

	// The name of this site
	Name string `json:"name"`

	// Optional notes/comments for the site
	Notes *string `json:"notes,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The number of runways at the site, if applicable
	Runways *int32 `json:"runways,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// The type of this site (AIRBASE, AIRFIELD, AIRPORT, NAVAL STATION, etc.)
	Type *string `json:"type,omitempty"`

	// The use authorization type of this site (e.g MILITARY, CIVIL, JOINT-USE, etc.)
	Usage *string `json:"usage,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SiteIngestDataMode string

// List of data sources related to this document
type SofDataSourceRefAbridged struct {
	// Data source id
	DataSourceId *string `json:"dataSourceId,omitempty"`

	// end position
	EndPosition *string `json:"endPosition,omitempty"`

	// paragraph number
	ParagraphNumber *string `json:"paragraphNumber,omitempty"`

	// sentence number
	SentenceNumber *string `json:"sentenceNumber,omitempty"`

	// start position
	StartPosition *string `json:"startPosition,omitempty"`
}

// List of data sources related to this document
type SofDataSourceRefFull struct {
	// Data source id
	DataSourceId *string `json:"dataSourceId,omitempty"`

	// end position
	EndPosition *string `json:"endPosition,omitempty"`

	// paragraph number
	ParagraphNumber *string `json:"paragraphNumber,omitempty"`

	// sentence number
	SentenceNumber *string `json:"sentenceNumber,omitempty"`

	// start position
	StartPosition *string `json:"startPosition,omitempty"`
}

// List of data sources related to this document
type SofDataSourceRefIngest struct {
	// Data source id
	DataSourceId *string `json:"dataSourceId,omitempty"`

	// end position
	EndPosition *string `json:"endPosition,omitempty"`

	// paragraph number
	ParagraphNumber *string `json:"paragraphNumber,omitempty"`

	// sentence number
	SentenceNumber *string `json:"sentenceNumber,omitempty"`

	// start position
	StartPosition *string `json:"startPosition,omitempty"`
}

// Model representation of Information on spacecraft SolarArrayDetails. A SolarArray may have multiple details records compiled by various sources.
type SolarArrayDetailsFull struct {
	// Solar Array area in square meters
	Area *float64 `json:"area,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayDetailsFullDataMode `json:"dataMode"`

	// Solar array description/notes
	Description *string `json:"description,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Unique identifier of the parent SolarArray
	IdSolarArray string `json:"idSolarArray"`

	// Solar array junction technology (e.g. Triple)
	JunctionTechnology *string `json:"junctionTechnology,omitempty"`

	// An organization such as a corporation, manufacturer, consortium, government, etc. An organization may have parent and child organizations as well as link to a former organization if this orgpreviously existed as another organization.
	ManufacturerOrg *OrganizationFull `json:"manufacturerOrg,omitempty"`

	// ID of the organization that manufactures the solar array
	ManufacturerOrgId *string `json:"manufacturerOrgId,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Solar Array span in meters
	Span *float64 `json:"span,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// Solar array technology (e.g. Ga-As)
	Technology *string `json:"technology,omitempty"`

	// Type of solar array (e.g. U Shaped)
	Type *string `json:"type,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayDetailsFullDataMode string

// Model representation of information on on-orbit/spacecraft solar arrays. A spacecraft may have multiple solar arrays and each solar array can have multiple 'details' records compiled by different sources.
type SolarArrayFull struct {
	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SolarArrayFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id string `json:"id"`

	// Solar Array name
	Name string `json:"name"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Read-only collection of additional SolarArrayDetails by various sources for this organization, ignored on create/update. These details must be created separately via the /udl/solararraydetails operations.
	SolarArrayDetails *[]SolarArrayDetailsFull `json:"solarArrayDetails,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SolarArrayFullDataMode string

// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Provider Discovery' tab in the storefront to confirm coordinate frames by data provider.
type StateVectorFull struct {
	// Optional algorithm used to produce this record
	Algorithm *string `json:"algorithm,omitempty"`

	// First derivative of drag/ballistic coefficient (m2/kg-s).
	BDot *float64 `json:"bDot,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Model parameter value for center of mass offset (m).
	CmOffset *float64 `json:"cmOffset,omitempty"`

	// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
	// The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	Cov *[]float64 `json:"cov,omitempty"`

	// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
	CovReferenceFrame *StateVectorFullCovReferenceFrame `json:"covReferenceFrame,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StateVectorFullDataMode `json:"dataMode"`

	// Optional source-provided and searchable metadata or descriptor of the data.
	Descriptor *string `json:"descriptor,omitempty"`

	// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
	DragCoeff *float64 `json:"dragCoeff,omitempty"`

	// Drag model used for this vector (e.g. HARRIS-PRIESTER, JAC70, MSIS90, NONE, etc.)
	DragModel *string `json:"dragModel,omitempty"`

	// Model parameter value for energy dissipation rate (EDR) (w/kg).
	Edr *float64 `json:"edr,omitempty"`

	// Start time at which this state vector was the 'current' state vector for its satellite.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// End time at which this state vector was no longer the 'current' state vector for its satellite.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`

	// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision
	Epoch time.Time `json:"epoch"`

	// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
	//
	// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
	//
	// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
	//
	//
	//
	//
	// The ordering of values is as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
	//
	// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
	//
	// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
	//
	// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
	//
	// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
	//
	// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
	//
	// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
	//
	// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
	//
	// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
	//
	// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
	//
	// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
	//
	// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
	//
	// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
	//
	// :
	//
	// :
	//
	// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
	EqCov *[]float64 `json:"eqCov,omitempty"`

	// Integrator error control.
	ErrorControl *float64 `json:"errorControl,omitempty"`

	// Boolean indicating use of fixed step size for this vector.
	FixedStep *bool `json:"fixedStep,omitempty"`

	// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
	GeopotentialModel *string `json:"geopotentialModel,omitempty"`

	// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
	Iau1980Terms *int32 `json:"iau1980Terms,omitempty"`

	// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
	IdOnOrbit *string `json:"idOnOrbit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	IdStateVector *string `json:"idStateVector,omitempty"`

	// Boolean indicating use of in-track thrust perturbations for this vector.
	InTrackThrust *bool `json:"inTrackThrust,omitempty"`

	// Integrator Mode
	IntegratorMode *string `json:"integratorMode,omitempty"`

	// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
	LeapSecondTime *time.Time `json:"leapSecondTime,omitempty"`

	// Boolean indicating use of lunar/solar perturbations for this vector.
	LunarSolar *bool `json:"lunarSolar,omitempty"`

	// Model object representing on-orbit objects or satellites in the system.
	OnOrbit *OnorbitFull `json:"onOrbit,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number
	OrigObjectId *string `json:"origObjectId,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
	Partials *string `json:"partials,omitempty"`

	// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN)
	Pedigree *string `json:"pedigree,omitempty"`

	// Polar Wander Motion X (arc seconds).
	PolarMotionX *float64 `json:"polarMotionX,omitempty"`

	// Polar Wander Motion Y (arc seconds).
	PolarMotionY *float64 `json:"polarMotionY,omitempty"`

	// Approximate position uncertainty (kilometers)
	PosUnc *float64 `json:"posUnc,omitempty"`

	// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/sfm/rest/downloadFile to this value.
	RawFileURI *string `json:"rawFileURI,omitempty"`

	// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
	ReferenceFrame *StateVectorFullReferenceFrame `json:"referenceFrame,omitempty"`

	// Epoch revolution number.
	RevNo *int32 `json:"revNo,omitempty"`

	// Weighted Root Mean Squared (RMS) of last differential correction on the target object.
	Rms *float64 `json:"rms,omitempty"`

	// Satellite/Catalog number of the target OnOrbit object
	SatNo *int32 `json:"satNo,omitempty"`

	// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
	SigmaPosUVW *[]float64 `json:"sigmaPosUVW,omitempty"`

	// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
	SigmaVelUVW *[]float64 `json:"sigmaVelUVW,omitempty"`

	// Average solar flux geomagnetic index.
	SolarFluxAPAvg *float64 `json:"solarFluxAPAvg,omitempty"`

	// F10 (10.7 cm) solar flux value.
	SolarFluxF10 *float64 `json:"solarFluxF10,omitempty"`

	// F10 (10.7 cm) solar flux 81-day average value.
	SolarFluxF10Avg *float64 `json:"solarFluxF10Avg,omitempty"`

	// Boolean indicating use of solar radiation pressure perturbations for this vector.
	SolarRadPress *bool `json:"solarRadPress,omitempty"`

	// Area-to-mass ratio coefficient for solar radiation pressure
	SolarRadPressCoeff *float64 `json:"solarRadPressCoeff,omitempty"`

	// Boolean indicating use of solid earth tide perturbations for this vector.
	SolidEarthTides *bool `json:"solidEarthTides,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
	SourcedData *[]string `json:"sourcedData,omitempty"`

	// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
	SourcedDataTypes *StateVectorFullSourcedDataTypes `json:"sourcedDataTypes,omitempty"`

	// Integrator step mode (AUTO, TIME, or S).
	StepMode *string `json:"stepMode,omitempty"`

	// Initial integration step size (seconds).
	StepSize *float64 `json:"stepSize,omitempty"`

	// Initial step size selection (AUTO or MANUAL).
	StepSizeSelection *string `json:"stepSizeSelection,omitempty"`

	// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *[]string `json:"tags,omitempty"`

	// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
	TaiUtc *float64 `json:"taiUtc,omitempty"`

	// Model parameter value for thrust acceleration (m/s2).
	ThrustAccel *float64 `json:"thrustAccel,omitempty"`

	// Optional identifier to track a commercial or marketplace transaction executed to produce this data
	TransactionId *string `json:"transactionId,omitempty"`

	// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
	Uct *bool `json:"uct,omitempty"`

	// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
	Ut1Rate *float64 `json:"ut1Rate,omitempty"`

	// Universal Time-1 (UT1) minus UTC offset, in seconds.
	Ut1Utc *float64 `json:"ut1Utc,omitempty"`

	// Approximate velocity uncertainty
	VelUnc *float64 `json:"velUnc,omitempty"`

	// Cartesian X position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xpos *float64 `json:"xpos,omitempty"`

	// Cartesian X velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Xvel *float64 `json:"xvel,omitempty"`

	// Cartesian Y position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Ypos *float64 `json:"ypos,omitempty"`

	// Cartesian Y velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Yvel *float64 `json:"yvel,omitempty"`

	// Cartesian Z position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zpos *float64 `json:"zpos,omitempty"`

	// Cartesian Z velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
	Zvel *float64 `json:"zvel,omitempty"`
}

// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000
type StateVectorFullCovReferenceFrame string

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StateVectorFullDataMode string

// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000
type StateVectorFullReferenceFrame string

// StateVectorFullSourcedDataTypes defines model for StateVectorFull.SourcedDataTypes.
type StateVectorFullSourcedDataTypes string

// Status for a particular Entity. An entity may have multiple status records collected by various sources.
type StatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode StatusFullDataMode `json:"dataMode"`

	// The declassification date of this data, in ISO 8601 UTC format.
	DeclassificationDate *time.Time `json:"declassificationDate,omitempty"`

	// Declassification string of this data.
	DeclassificationString *string `json:"declassificationString,omitempty"`

	// The sources or SCG references from which the classification of this data is derived.
	DerivedFrom *string `json:"derivedFrom,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Unique identifier of the parent entity
	IdEntity string `json:"idEntity"`

	// Comments describing the status creation and or updates to an entity
	Notes *string `json:"notes,omitempty"`

	// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	OpsCap *StatusFullOpsCap `json:"opsCap,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
	State               *StatusFullState `json:"state,omitempty"`
	SubStatusCollection *[]SubStatusFull `json:"subStatusCollection,omitempty"`

	// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
	SysCap *StatusFullSysCap `json:"sysCap,omitempty"`

	// Time the row was last updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type StatusFullDataMode string

// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullOpsCap string

// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY)
type StatusFullState string

// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK)
type StatusFullSysCap string

// Additional sub-system or capability status for the parent entity.
type SubStatusFull struct {
	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode SubStatusFullDataMode `json:"dataMode"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Descriptions and/or comments associated with the sub-status
	Notes string `json:"notes"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
	Status SubStatusFullStatus `json:"status"`

	// Id of the parent status
	StatusId string `json:"statusId"`

	// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
	Type SubStatusFullType `json:"type"`

	// Time the row was updated in the database, auto-populated by the system
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Application user who updated the row in the database, auto-populated by the system
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type SubStatusFullDataMode string

// Status of the sub-system/capability, e.g. FMC, NMC, PMC, UNK
type SubStatusFullStatus string

// Parent entity's sub-system or capability status: mwCap, mdCap, ssCap, etc.
type SubStatusFullType string

// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
type TrackDetailsAbridged struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
	//
	// SRBM - Short-Range Ballistic Missile
	//
	// MRBM - Medium-Range Ballistic Missile
	//
	// IRBM - Intermediate-Range Ballistic Missile
	//
	// LRBM - Long-Range Ballistic Missile
	//
	// ICBM - Intercontinental Ballistic Missile
	//
	// SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	AddInfo *string `json:"addInfo,omitempty"`

	// A track may be designated as an alert track with the following designations:
	//
	// HIT - High Interest Track
	//
	// TGT - Target
	//
	// SUS - Suspect Carrier
	//
	// NSP - Cleared Suspect
	//
	// If alert is null, the track is assumed to be of non-alert status.
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Appearance group code.
	//
	// GP1 - Superstructure exceeds 1/3 of ship length.
	//
	// GP2 - Superstructure less than 1/3 of ship length.
	//
	// GP3 - Stack aft.
	AppGrp *string `json:"appGrp,omitempty"`

	// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	ArrCargo *string `json:"arrCargo,omitempty"`

	// The flag of the arrival port.
	ArrFlag *string `json:"arrFlag,omitempty"`

	// The Arrival Port of the vessel according to the AIS transmission.
	ArrPort *string `json:"arrPort,omitempty"`

	// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with millisecond precision.
	ArrTime *time.Time `json:"arrTime,omitempty"`

	// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	Aton *string `json:"aton,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
	AvgSpd *float64 `json:"avgSpd,omitempty"`

	// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
	AzCorrArcWidth *float64 `json:"azCorrArcWidth,omitempty"`

	// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
	AzCorrCenterLine *float64 `json:"azCorrCenterLine,omitempty"`

	// The Basic Encyclopedia (BE) number associated with this installation or area.
	BeNumber *string `json:"beNumber,omitempty"`

	// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// Correlation Index; reference code for the site that originally reported the track.
	CI *string `json:"cI,omitempty"`

	// The call sign currently assigned to this track object.
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Containment *float64 `json:"containment,omitempty"`

	// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
	//
	// 0 - COOPERATIVE_LOCATOR_NONE
	//
	// 1 - SINGLE_PLATFORM
	//
	// 2 - FRAGMENT
	//
	// 3 - COOPERATIVE
	//
	CoopLocInd *string `json:"coopLocInd,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// The distance, in meters, of the closest point of approach between this track to the master reference track.
	Cpa *float64 `json:"cpa,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackDetailsAbridgedDataMode `json:"dataMode"`

	// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DepCargo *string `json:"depCargo,omitempty"`

	// The flag of the departure port.
	DepFlag *string `json:"depFlag,omitempty"`

	// The Departure Port of the vessel according to the AIS transmission.
	DepPort *string `json:"depPort,omitempty"`

	// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DesCargo *string `json:"desCargo,omitempty"`

	// The flag of the destination port.
	DesFlag *string `json:"desFlag,omitempty"`

	// The destination of the vessel according to the AIS transmission.
	Destination *string `json:"destination,omitempty"`

	// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
	DisId *string `json:"disId,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission.
	Draught *float64 `json:"draught,omitempty"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot1 *string `json:"elnot1,omitempty"`

	// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot2 *string `json:"elnot2,omitempty"`

	// Flag indicating that the track object has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
	EmitterName *string `json:"emitterName,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *TrackDetailsAbridgedEnv `json:"env,omitempty"`

	// The error in the Area Orientation.  Area orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
	ErrAreaOrient *float64 `json:"errAreaOrient,omitempty"`

	// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
	//
	// 0 - SWITCH_TYPE_UNKNOWN
	//
	// 1 - SQUARE_RECTANGLE
	//
	// 2 - CIRCLE_ELLIPSE
	//
	ErrGeoAreaSwitch *string `json:"errGeoAreaSwitch,omitempty"`

	// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
	ErrSemiIntAxis *float64 `json:"errSemiIntAxis,omitempty"`

	// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
	ErrSemiMajElev *float64 `json:"errSemiMajElev,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with millisecond precision.
	Eta *time.Time `json:"eta,omitempty"`

	// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with millisecond precision.
	Etd *time.Time `json:"etd,omitempty"`

	// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
	//
	//  Reliability Ratings:
	//
	//   A-completely reliable
	//
	//   B-usually reliable
	//
	//   C-fairly reliable
	//
	//   D-not usually reliable
	//
	//   E-unreliable
	//
	//   F-reliability cannot be judged
	//
	//  Credibility Ratings:
	//
	//   1-confirmed by other sources
	//
	//   2-probably true
	//
	//   3-possibly true
	//
	//   4-doubtfully true
	//
	//   5-improbable
	//
	//   6-truth cannot be judged
	//
	EvalRating *string `json:"evalRating,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Frequency, in hertz, for the signature report.
	Freq *float64 `json:"freq,omitempty"`

	// An ftn used to associate information and directives with the track.
	Ftn *string `json:"ftn,omitempty"`

	// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
	FtnCmd *string `json:"ftnCmd,omitempty"`

	// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with millisecond precision.
	FtnMsgTs *time.Time `json:"ftnMsgTs,omitempty"`

	// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS)
	Harmonics *string `json:"harmonics,omitempty"`

	// Track object heading, in degrees clockwise from true north.
	Hdng *float64 `json:"hdng,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
	HullNum *string `json:"hullNum,omitempty"`

	// Hull profile code. Based on GCCS-J hull profiles.
	//
	// FLUSH           No breaks in Hull Profile.
	//
	// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
	//
	// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
	//
	// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
	//
	// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
	//
	// RAISED 1-2      Raised area at bow and midships with break between.
	//
	// RAISED 1-3      Raised area at bow and stern with break between.
	//
	// RAISED 12       Continuous raised area encompassing both bow and midships.
	//
	// RAISED 23       Continuous raised area encompassing midships and stern.
	//
	// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
	//
	// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
	//
	// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
	HullProf *string `json:"hullProf,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
	Imon *int32 `json:"imon,omitempty"`

	// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Flag Indicating whether the missile is considered lost, if reporting a missile track.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// The manuevering indicator specifying the missile boost phase.
	//
	// 0 - POST_BOOST_NONE
	//
	// 1 - POST_BOOST_MANUEVER
	//
	// 2 - POST_BOOST_COMPLETE_MANUEVER
	//
	ManeuverInd *string `json:"maneuverInd,omitempty"`

	// Maximum frequency, in hertz, reported for this acoustic track.
	MaxFreq *float64 `json:"maxFreq,omitempty"`

	// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
	MidbCat *string `json:"midbCat,omitempty"`

	// The MIL-STD-2525B symbology code that applies to the subject of this track.
	Mil2525Bstr *string `json:"mil2525Bstr,omitempty"`

	// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
	Mmsi *int32 `json:"mmsi,omitempty"`

	// Optional message type designation.
	MsgType *string `json:"msgType,omitempty"`

	// The status of the missile track in this record, if reporting a missile track:
	//
	//  AT LAUNCH
	//
	//  AT OBSERVATION
	//
	//  FLYING
	//
	//  IMPACTED
	//
	//  LOST
	//
	//  STALE
	//
	//  DEBRIS
	//
	MslStatus *TrackDetailsAbridgedMslStatus `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The Naval Tactical Data System (NTDS) track number assigned to this track.
	Ntds *string `json:"ntds,omitempty"`

	// The number of blades per shaft of the track object.  Applicable for maritime vessels.
	NumBlades *int32 `json:"numBlades,omitempty"`

	// The number of shafts on the track object.  Applicable for maritime vessels.
	NumShafts *int32 `json:"numShafts,omitempty"`

	// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
	OSuffix *string `json:"oSuffix,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *TrackDetailsAbridgedObjIdent `json:"objIdent,omitempty"`

	// Nationality of the tracked object.
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type is Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
	ObjPlat *string `json:"objPlat,omitempty"`

	// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
	OffPosInd *string `json:"offPosInd,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Original source cross-reference code for the Command that originated the report.
	OrigXref *string `json:"origXref,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
	Pif *string `json:"pif,omitempty"`

	// This value represents the site number of a specific electronic site or its associated equipment.
	Pin *string `json:"pin,omitempty"`

	// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
	Prf *float64 `json:"prf,omitempty"`

	// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
	Pri *float64 `json:"pri,omitempty"`

	// The number of propeller revolutions per minute for a submarine or ship.
	PropRPM *float64 `json:"propRPM,omitempty"`

	// The type of propulsion employed by the track object (Diesel, Nuclear).
	PropType *string `json:"propType,omitempty"`

	// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
	Pw *float64 `json:"pw,omitempty"`

	// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Flag indicating whether this track is archived.
	RptArchived *bool `json:"rptArchived,omitempty"`

	// Source cross-reference code for the Command that originated the track report.
	RptChxref *string `json:"rptChxref,omitempty"`

	// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	Rtn *[]string `json:"rtn,omitempty"`

	// The name of the Command reporting the received track number (RTN).
	RtnCmd *string `json:"rtnCmd,omitempty"`

	// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with milliseconds precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	RtnMsgTs *[]time.Time `json:"rtnMsgTs,omitempty"`

	// Value representing the state of the Received Track.
	RtnTrkState *string `json:"rtnTrkState,omitempty"`

	// Scan rate of the emitter, measured in seconds per rotation (SPR).
	ScanRate *float64 `json:"scanRate,omitempty"`

	// Type of radar scan.
	ScanType *string `json:"scanType,omitempty"`

	// The Sequential Contact Number (SCN) for this track.
	Scn *int32 `json:"scn,omitempty"`

	// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
	Sconum *string `json:"sconum,omitempty"`

	// Flag indicating that this track is self reported.
	SelfReport *bool `json:"selfReport,omitempty"`

	// Id/name of sensor providing the track data.
	Sen *string `json:"sen,omitempty"`

	// The common name for a group of ships with similar design, usually named for the first vessel of the class.
	ShipClass *string `json:"shipClass,omitempty"`

	// Abbreviated track name.
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The unique identifier of the source node.
	SourceUid *string `json:"sourceUid,omitempty"`

	// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	StaffCmts *string `json:"staffCmts,omitempty"`

	// The stern type code (Counter, Cruiser) associated with the track object.
	SternType *string `json:"sternType,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
	Tcpa *time.Time `json:"tcpa,omitempty"`

	// Threat Event System Track ID.
	TesEventId *string `json:"tesEventId,omitempty"`

	// Motion model Time On Leg in hours.
	Tol *float64 `json:"tol,omitempty"`

	// The number of turns of the vessel propellers per knot of forward motion.
	Tpk *float64 `json:"tpk,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
	TrkNum *string `json:"trkNum,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Value Indicating the scope of this track:
	// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
	// 2 - LOCAL  (Local) - available only on workstations in the local area network
	// 3 - OTH  (Over the Horizon) - available to everyone.
	TrkScope *string `json:"trkScope,omitempty"`

	// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
	TrnspdrId *string `json:"trnspdrId,omitempty"`

	// Transponder type for the track.
	TrnspdrType *string `json:"trnspdrType,omitempty"`

	// Track timestamp in ISO8601 UTC format with microsecond precision.
	Ts time.Time `json:"ts"`

	// The weight, in tons, of the vessel associated with this track.
	VslWt *float64 `json:"vslWt,omitempty"`

	// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackDetailsAbridgedDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type TrackDetailsAbridgedEnv string

// The status of the missile track in this record, if reporting a missile track:
//
//	AT LAUNCH
//
//	AT OBSERVATION
//
//	FLYING
//
//	IMPACTED
//
//	LOST
//
//	STALE
//
//	DEBRIS
type TrackDetailsAbridgedMslStatus string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type TrackDetailsAbridgedObjIdent string

// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
type TrackDetailsFull struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
	//
	// SRBM - Short-Range Ballistic Missile
	//
	// MRBM - Medium-Range Ballistic Missile
	//
	// IRBM - Intermediate-Range Ballistic Missile
	//
	// LRBM - Long-Range Ballistic Missile
	//
	// ICBM - Intercontinental Ballistic Missile
	//
	// SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	AddInfo *string `json:"addInfo,omitempty"`

	// A track may be designated as an alert track with the following designations:
	//
	// HIT - High Interest Track
	//
	// TGT - Target
	//
	// SUS - Suspect Carrier
	//
	// NSP - Cleared Suspect
	//
	// If alert is null, the track is assumed to be of non-alert status.
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Appearance group code.
	//
	// GP1 - Superstructure exceeds 1/3 of ship length.
	//
	// GP2 - Superstructure less than 1/3 of ship length.
	//
	// GP3 - Stack aft.
	AppGrp *string `json:"appGrp,omitempty"`

	// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	ArrCargo *string `json:"arrCargo,omitempty"`

	// The flag of the arrival port.
	ArrFlag *string `json:"arrFlag,omitempty"`

	// The Arrival Port of the vessel according to the AIS transmission.
	ArrPort *string `json:"arrPort,omitempty"`

	// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with millisecond precision.
	ArrTime *time.Time `json:"arrTime,omitempty"`

	// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	Aton *string `json:"aton,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
	AvgSpd *float64 `json:"avgSpd,omitempty"`

	// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
	AzCorrArcWidth *float64 `json:"azCorrArcWidth,omitempty"`

	// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
	AzCorrCenterLine *float64 `json:"azCorrCenterLine,omitempty"`

	// The Basic Encyclopedia (BE) number associated with this installation or area.
	BeNumber *string `json:"beNumber,omitempty"`

	// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// Correlation Index; reference code for the site that originally reported the track.
	CI *string `json:"cI,omitempty"`

	// The call sign currently assigned to this track object.
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Containment *float64 `json:"containment,omitempty"`

	// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
	//
	// 0 - COOPERATIVE_LOCATOR_NONE
	//
	// 1 - SINGLE_PLATFORM
	//
	// 2 - FRAGMENT
	//
	// 3 - COOPERATIVE
	//
	CoopLocInd *string `json:"coopLocInd,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// The distance, in meters, of the closest point of approach between this track to the master reference track.
	Cpa *float64 `json:"cpa,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackDetailsFullDataMode `json:"dataMode"`

	// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DepCargo *string `json:"depCargo,omitempty"`

	// The flag of the departure port.
	DepFlag *string `json:"depFlag,omitempty"`

	// The Departure Port of the vessel according to the AIS transmission.
	DepPort *string `json:"depPort,omitempty"`

	// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DesCargo *string `json:"desCargo,omitempty"`

	// The flag of the destination port.
	DesFlag *string `json:"desFlag,omitempty"`

	// The destination of the vessel according to the AIS transmission.
	Destination *string `json:"destination,omitempty"`

	// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
	DisId *string `json:"disId,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission.
	Draught *float64 `json:"draught,omitempty"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot1 *string `json:"elnot1,omitempty"`

	// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot2 *string `json:"elnot2,omitempty"`

	// Flag indicating that the track object has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
	EmitterName *string `json:"emitterName,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *TrackDetailsFullEnv `json:"env,omitempty"`

	// The error in the Area Orientation.  Area orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
	ErrAreaOrient *float64 `json:"errAreaOrient,omitempty"`

	// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
	//
	// 0 - SWITCH_TYPE_UNKNOWN
	//
	// 1 - SQUARE_RECTANGLE
	//
	// 2 - CIRCLE_ELLIPSE
	//
	ErrGeoAreaSwitch *string `json:"errGeoAreaSwitch,omitempty"`

	// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
	ErrSemiIntAxis *float64 `json:"errSemiIntAxis,omitempty"`

	// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
	ErrSemiMajElev *float64 `json:"errSemiMajElev,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with millisecond precision.
	Eta *time.Time `json:"eta,omitempty"`

	// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with millisecond precision.
	Etd *time.Time `json:"etd,omitempty"`

	// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
	//
	//  Reliability Ratings:
	//
	//   A-completely reliable
	//
	//   B-usually reliable
	//
	//   C-fairly reliable
	//
	//   D-not usually reliable
	//
	//   E-unreliable
	//
	//   F-reliability cannot be judged
	//
	//  Credibility Ratings:
	//
	//   1-confirmed by other sources
	//
	//   2-probably true
	//
	//   3-possibly true
	//
	//   4-doubtfully true
	//
	//   5-improbable
	//
	//   6-truth cannot be judged
	//
	EvalRating *string `json:"evalRating,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Frequency, in hertz, for the signature report.
	Freq *float64 `json:"freq,omitempty"`

	// An ftn used to associate information and directives with the track.
	Ftn *string `json:"ftn,omitempty"`

	// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
	FtnCmd *string `json:"ftnCmd,omitempty"`

	// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with millisecond precision.
	FtnMsgTs *time.Time `json:"ftnMsgTs,omitempty"`

	// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS)
	Harmonics *string `json:"harmonics,omitempty"`

	// Track object heading, in degrees clockwise from true north.
	Hdng *float64 `json:"hdng,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
	HullNum *string `json:"hullNum,omitempty"`

	// Hull profile code. Based on GCCS-J hull profiles.
	//
	// FLUSH           No breaks in Hull Profile.
	//
	// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
	//
	// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
	//
	// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
	//
	// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
	//
	// RAISED 1-2      Raised area at bow and midships with break between.
	//
	// RAISED 1-3      Raised area at bow and stern with break between.
	//
	// RAISED 12       Continuous raised area encompassing both bow and midships.
	//
	// RAISED 23       Continuous raised area encompassing midships and stern.
	//
	// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
	//
	// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
	//
	// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
	HullProf *string `json:"hullProf,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
	Imon *int32 `json:"imon,omitempty"`

	// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Flag Indicating whether the missile is considered lost, if reporting a missile track.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// The manuevering indicator specifying the missile boost phase.
	//
	// 0 - POST_BOOST_NONE
	//
	// 1 - POST_BOOST_MANUEVER
	//
	// 2 - POST_BOOST_COMPLETE_MANUEVER
	//
	ManeuverInd *string `json:"maneuverInd,omitempty"`

	// Maximum frequency, in hertz, reported for this acoustic track.
	MaxFreq *float64 `json:"maxFreq,omitempty"`

	// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
	MidbCat *string `json:"midbCat,omitempty"`

	// The MIL-STD-2525B symbology code that applies to the subject of this track.
	Mil2525Bstr *string `json:"mil2525Bstr,omitempty"`

	// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
	Mmsi *int32 `json:"mmsi,omitempty"`

	// Optional message type designation.
	MsgType *string `json:"msgType,omitempty"`

	// The status of the missile track in this record, if reporting a missile track:
	//
	//  AT LAUNCH
	//
	//  AT OBSERVATION
	//
	//  FLYING
	//
	//  IMPACTED
	//
	//  LOST
	//
	//  STALE
	//
	//  DEBRIS
	//
	MslStatus *TrackDetailsFullMslStatus `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The Naval Tactical Data System (NTDS) track number assigned to this track.
	Ntds *string `json:"ntds,omitempty"`

	// The number of blades per shaft of the track object.  Applicable for maritime vessels.
	NumBlades *int32 `json:"numBlades,omitempty"`

	// The number of shafts on the track object.  Applicable for maritime vessels.
	NumShafts *int32 `json:"numShafts,omitempty"`

	// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
	OSuffix *string `json:"oSuffix,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *TrackDetailsFullObjIdent `json:"objIdent,omitempty"`

	// Nationality of the tracked object.
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type is Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
	ObjPlat *string `json:"objPlat,omitempty"`

	// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
	OffPosInd *string `json:"offPosInd,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Original source cross-reference code for the Command that originated the report.
	OrigXref *string `json:"origXref,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
	Pif *string `json:"pif,omitempty"`

	// This value represents the site number of a specific electronic site or its associated equipment.
	Pin *string `json:"pin,omitempty"`

	// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
	Prf *float64 `json:"prf,omitempty"`

	// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
	Pri *float64 `json:"pri,omitempty"`

	// The number of propeller revolutions per minute for a submarine or ship.
	PropRPM *float64 `json:"propRPM,omitempty"`

	// The type of propulsion employed by the track object (Diesel, Nuclear).
	PropType *string `json:"propType,omitempty"`

	// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
	Pw *float64 `json:"pw,omitempty"`

	// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Flag indicating whether this track is archived.
	RptArchived *bool `json:"rptArchived,omitempty"`

	// Source cross-reference code for the Command that originated the track report.
	RptChxref *string `json:"rptChxref,omitempty"`

	// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	Rtn *[]string `json:"rtn,omitempty"`

	// The name of the Command reporting the received track number (RTN).
	RtnCmd *string `json:"rtnCmd,omitempty"`

	// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with milliseconds precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	RtnMsgTs *[]time.Time `json:"rtnMsgTs,omitempty"`

	// Value representing the state of the Received Track.
	RtnTrkState *string `json:"rtnTrkState,omitempty"`

	// Scan rate of the emitter, measured in seconds per rotation (SPR).
	ScanRate *float64 `json:"scanRate,omitempty"`

	// Type of radar scan.
	ScanType *string `json:"scanType,omitempty"`

	// The Sequential Contact Number (SCN) for this track.
	Scn *int32 `json:"scn,omitempty"`

	// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
	Sconum *string `json:"sconum,omitempty"`

	// Flag indicating that this track is self reported.
	SelfReport *bool `json:"selfReport,omitempty"`

	// Id/name of sensor providing the track data.
	Sen *string `json:"sen,omitempty"`

	// The common name for a group of ships with similar design, usually named for the first vessel of the class.
	ShipClass *string `json:"shipClass,omitempty"`

	// Abbreviated track name.
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The unique identifier of the source node.
	SourceUid *string `json:"sourceUid,omitempty"`

	// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	StaffCmts *string `json:"staffCmts,omitempty"`

	// The stern type code (Counter, Cruiser) associated with the track object.
	SternType *string `json:"sternType,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
	Tcpa *time.Time `json:"tcpa,omitempty"`

	// Threat Event System Track ID.
	TesEventId *string `json:"tesEventId,omitempty"`

	// Motion model Time On Leg in hours.
	Tol *float64 `json:"tol,omitempty"`

	// The number of turns of the vessel propellers per knot of forward motion.
	Tpk *float64 `json:"tpk,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
	TrkNum *string `json:"trkNum,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Value Indicating the scope of this track:
	// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
	// 2 - LOCAL  (Local) - available only on workstations in the local area network
	// 3 - OTH  (Over the Horizon) - available to everyone.
	TrkScope *string `json:"trkScope,omitempty"`

	// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
	TrnspdrId *string `json:"trnspdrId,omitempty"`

	// Transponder type for the track.
	TrnspdrType *string `json:"trnspdrType,omitempty"`

	// Track timestamp in ISO8601 UTC format with microsecond precision.
	Ts time.Time `json:"ts"`

	// The weight, in tons, of the vessel associated with this track.
	VslWt *float64 `json:"vslWt,omitempty"`

	// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackDetailsFullDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type TrackDetailsFullEnv string

// The status of the missile track in this record, if reporting a missile track:
//
//	AT LAUNCH
//
//	AT OBSERVATION
//
//	FLYING
//
//	IMPACTED
//
//	LOST
//
//	STALE
//
//	DEBRIS
type TrackDetailsFullMslStatus string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type TrackDetailsFullObjIdent string

// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
type TrackDetailsIngest struct {
	// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
	//
	// SRBM - Short-Range Ballistic Missile
	//
	// MRBM - Medium-Range Ballistic Missile
	//
	// IRBM - Intermediate-Range Ballistic Missile
	//
	// LRBM - Long-Range Ballistic Missile
	//
	// ICBM - Intercontinental Ballistic Missile
	//
	// SLBM - Submarine-Launched Ballistic Missile
	//
	AcftSubType *string `json:"acftSubType,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	AddInfo *string `json:"addInfo,omitempty"`

	// A track may be designated as an alert track with the following designations:
	//
	// HIT - High Interest Track
	//
	// TGT - Target
	//
	// SUS - Suspect Carrier
	//
	// NSP - Cleared Suspect
	//
	// If alert is null, the track is assumed to be of non-alert status.
	//
	Alert *string `json:"alert,omitempty"`

	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
	AngElev *float64 `json:"angElev,omitempty"`

	// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
	AntennaRefDimensions *[]float64 `json:"antennaRefDimensions,omitempty"`

	// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	AouRptData *[]float64 `json:"aouRptData,omitempty"`

	// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
	AouRptType *string `json:"aouRptType,omitempty"`

	// Appearance group code.
	//
	// GP1 - Superstructure exceeds 1/3 of ship length.
	//
	// GP2 - Superstructure less than 1/3 of ship length.
	//
	// GP3 - Stack aft.
	AppGrp *string `json:"appGrp,omitempty"`

	// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	ArrCargo *string `json:"arrCargo,omitempty"`

	// The flag of the arrival port.
	ArrFlag *string `json:"arrFlag,omitempty"`

	// The Arrival Port of the vessel according to the AIS transmission.
	ArrPort *string `json:"arrPort,omitempty"`

	// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with millisecond precision.
	ArrTime *time.Time `json:"arrTime,omitempty"`

	// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	Aton *string `json:"aton,omitempty"`

	// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
	AvgSpd *float64 `json:"avgSpd,omitempty"`

	// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
	AzCorrArcWidth *float64 `json:"azCorrArcWidth,omitempty"`

	// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
	AzCorrCenterLine *float64 `json:"azCorrCenterLine,omitempty"`

	// The Basic Encyclopedia (BE) number associated with this installation or area.
	BeNumber *string `json:"beNumber,omitempty"`

	// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
	Boosting *bool `json:"boosting,omitempty"`

	// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
	BurnoutAlt *float64 `json:"burnoutAlt,omitempty"`

	// Correlation Index; reference code for the site that originally reported the track.
	CI *string `json:"cI,omitempty"`

	// The call sign currently assigned to this track object.
	CallSign *string `json:"callSign,omitempty"`

	// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	CargoType *string `json:"cargoType,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
	Containment *float64 `json:"containment,omitempty"`

	// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
	//
	// 0 - COOPERATIVE_LOCATOR_NONE
	//
	// 1 - SINGLE_PLATFORM
	//
	// 2 - FRAGMENT
	//
	// 3 - COOPERATIVE
	//
	CoopLocInd *string `json:"coopLocInd,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// The distance, in meters, of the closest point of approach between this track to the master reference track.
	Cpa *float64 `json:"cpa,omitempty"`

	// Time the row was created in the database.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackDetailsIngestDataMode `json:"dataMode"`

	// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DepCargo *string `json:"depCargo,omitempty"`

	// The flag of the departure port.
	DepFlag *string `json:"depFlag,omitempty"`

	// The Departure Port of the vessel according to the AIS transmission.
	DepPort *string `json:"depPort,omitempty"`

	// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	DesCargo *string `json:"desCargo,omitempty"`

	// The flag of the destination port.
	DesFlag *string `json:"desFlag,omitempty"`

	// The destination of the vessel according to the AIS transmission.
	Destination *string `json:"destination,omitempty"`

	// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
	DisId *string `json:"disId,omitempty"`

	// The maximum static draught, in meters, of the vessel according to the AIS transmission.
	Draught *float64 `json:"draught,omitempty"`

	// The drop-point indicator setting.
	DropPtInd *bool `json:"dropPtInd,omitempty"`

	// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Dummy *bool `json:"dummy,omitempty"`

	// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot1 *string `json:"elnot1,omitempty"`

	// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
	Elnot2 *string `json:"elnot2,omitempty"`

	// Flag indicating that the track object has an emergency.
	EmgInd *bool `json:"emgInd,omitempty"`

	// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
	EmitterName *string `json:"emitterName,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	//  AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  LAND: On the surface of dry land.
	//
	//  SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	//  SURFACE: On the surface of a body of water.
	//
	//  SUBSURFACE: Below the surface of a body of water.
	//
	//  UNKNOWN: Environment is not known.
	//
	Env *TrackDetailsIngestEnv `json:"env,omitempty"`

	// The error in the Area Orientation.  Area orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
	ErrAreaOrient *float64 `json:"errAreaOrient,omitempty"`

	// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
	//
	// 0 - SWITCH_TYPE_UNKNOWN
	//
	// 1 - SQUARE_RECTANGLE
	//
	// 2 - CIRCLE_ELLIPSE
	//
	ErrGeoAreaSwitch *string `json:"errGeoAreaSwitch,omitempty"`

	// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
	ErrSemiIntAxis *float64 `json:"errSemiIntAxis,omitempty"`

	// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
	ErrSemiMajElev *float64 `json:"errSemiMajElev,omitempty"`

	// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with millisecond precision.
	Eta *time.Time `json:"eta,omitempty"`

	// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with millisecond precision.
	Etd *time.Time `json:"etd,omitempty"`

	// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
	//
	//  Reliability Ratings:
	//
	//   A-completely reliable
	//
	//   B-usually reliable
	//
	//   C-fairly reliable
	//
	//   D-not usually reliable
	//
	//   E-unreliable
	//
	//   F-reliability cannot be judged
	//
	//  Credibility Ratings:
	//
	//   1-confirmed by other sources
	//
	//   2-probably true
	//
	//   3-possibly true
	//
	//   4-doubtfully true
	//
	//   5-improbable
	//
	//   6-truth cannot be judged
	//
	EvalRating *string `json:"evalRating,omitempty"`

	// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
	Feint *bool `json:"feint,omitempty"`

	// Frequency, in hertz, for the signature report.
	Freq *float64 `json:"freq,omitempty"`

	// An ftn used to associate information and directives with the track.
	Ftn *string `json:"ftn,omitempty"`

	// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
	FtnCmd *string `json:"ftnCmd,omitempty"`

	// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with millisecond precision.
	FtnMsgTs *time.Time `json:"ftnMsgTs,omitempty"`

	// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS)
	Harmonics *string `json:"harmonics,omitempty"`

	// Track object heading, in degrees clockwise from true north.
	Hdng *float64 `json:"hdng,omitempty"`

	// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
	Hq *bool `json:"hq,omitempty"`

	// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
	HullNum *string `json:"hullNum,omitempty"`

	// Hull profile code. Based on GCCS-J hull profiles.
	//
	// FLUSH           No breaks in Hull Profile.
	//
	// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
	//
	// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
	//
	// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
	//
	// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
	//
	// RAISED 1-2      Raised area at bow and midships with break between.
	//
	// RAISED 1-3      Raised area at bow and stern with break between.
	//
	// RAISED 12       Continuous raised area encompassing both bow and midships.
	//
	// RAISED 23       Continuous raised area encompassing midships and stern.
	//
	// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
	//
	// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
	//
	// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
	HullProf *string `json:"hullProf,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	//  FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	//  JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	//  KILO: Friendly high-value object.
	//
	//  TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	//  ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
	Iff *string `json:"iff,omitempty"`

	// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
	Imon *int32 `json:"imon,omitempty"`

	// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	ImpactAouData *[]float64 `json:"impactAouData,omitempty"`

	// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
	ImpactAouType *string `json:"impactAouType,omitempty"`

	// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
	ImpactLat *float64 `json:"impactLat,omitempty"`

	// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	ImpactLon *float64 `json:"impactLon,omitempty"`

	// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
	ImpactTime *time.Time `json:"impactTime,omitempty"`

	// Source code for source of information used to detect track.
	InfoSource *string `json:"infoSource,omitempty"`

	// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
	Installation *bool `json:"installation,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
	//
	//  ELLIPSE:
	//
	//    brg - orientation in degrees of the ellipse
	//
	//    a1 - semi-major axis in meters
	//
	//    a2 - semi-minor axis in meters
	//
	//  BEARING (BEARING BOX or MTST BEARING BOX):
	//
	//    brg - orientation in degrees of the bearing box
	//
	//    a1 - length of bearing box in meters
	//
	//    a2 - half-width of bearing box in meters
	//
	//  OTHER (All other type values):
	//
	//    brg - line of bearing in degrees true
	//
	//    a1 - bearing error in degrees
	//
	//    a2 - estimated range in meters
	//
	LaunchAouData *[]float64 `json:"launchAouData,omitempty"`

	// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
	LaunchAouType *string `json:"launchAouType,omitempty"`

	// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
	LaunchLat *float64 `json:"launchLat,omitempty"`

	// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	LaunchLon *float64 `json:"launchLon,omitempty"`

	// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
	LaunchTime *time.Time `json:"launchTime,omitempty"`

	// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
	Length *float64 `json:"length,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Flag Indicating whether the missile is considered lost, if reporting a missile track.
	LostTrkInd *bool `json:"lostTrkInd,omitempty"`

	// The manuevering indicator specifying the missile boost phase.
	//
	// 0 - POST_BOOST_NONE
	//
	// 1 - POST_BOOST_MANUEVER
	//
	// 2 - POST_BOOST_COMPLETE_MANUEVER
	//
	ManeuverInd *string `json:"maneuverInd,omitempty"`

	// Maximum frequency, in hertz, reported for this acoustic track.
	MaxFreq *float64 `json:"maxFreq,omitempty"`

	// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
	MidbCat *string `json:"midbCat,omitempty"`

	// The MIL-STD-2525B symbology code that applies to the subject of this track.
	Mil2525Bstr *string `json:"mil2525Bstr,omitempty"`

	// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
	Mmsi *int32 `json:"mmsi,omitempty"`

	// Optional message type designation.
	MsgType *string `json:"msgType,omitempty"`

	// The status of the missile track in this record, if reporting a missile track:
	//
	//  AT LAUNCH
	//
	//  AT OBSERVATION
	//
	//  FLYING
	//
	//  IMPACTED
	//
	//  LOST
	//
	//  STALE
	//
	//  DEBRIS
	//
	MslStatus *TrackDetailsIngestMslStatus `json:"mslStatus,omitempty"`

	// Source of the missile-unique identifier (MUID).
	MuidSrc *string `json:"muidSrc,omitempty"`

	// Track ID for the source of the missile-unique identifier.
	MuidSrcTrk *string `json:"muidSrcTrk,omitempty"`

	// Track name.
	Name *string `json:"name,omitempty"`

	// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	NavStatus *string `json:"navStatus,omitempty"`

	// The Naval Tactical Data System (NTDS) track number assigned to this track.
	Ntds *string `json:"ntds,omitempty"`

	// The number of blades per shaft of the track object.  Applicable for maritime vessels.
	NumBlades *int32 `json:"numBlades,omitempty"`

	// The number of shafts on the track object.  Applicable for maritime vessels.
	NumShafts *int32 `json:"numShafts,omitempty"`

	// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
	OSuffix *string `json:"oSuffix,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
	ObjAct *string `json:"objAct,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	//  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	//  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	//  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	//  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	//  PENDING: Track object which has not been evaluated.
	//
	//  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	//  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *TrackDetailsIngestObjIdent `json:"objIdent,omitempty"`

	// Nationality of the tracked object.
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type is Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
	ObjPlat *string `json:"objPlat,omitempty"`

	// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
	OffPosInd *string `json:"offPosInd,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Original source cross-reference code for the Command that originated the report.
	OrigXref *string `json:"origXref,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
	Pif *string `json:"pif,omitempty"`

	// This value represents the site number of a specific electronic site or its associated equipment.
	Pin *string `json:"pin,omitempty"`

	// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
	PolarSingLocLat *float64 `json:"polarSingLocLat,omitempty"`

	// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	PolarSingLocLon *float64 `json:"polarSingLocLon,omitempty"`

	// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
	PosDeviceType *string `json:"posDeviceType,omitempty"`

	// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
	Prf *float64 `json:"prf,omitempty"`

	// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
	Pri *float64 `json:"pri,omitempty"`

	// The number of propeller revolutions per minute for a submarine or ship.
	PropRPM *float64 `json:"propRPM,omitempty"`

	// The type of propulsion employed by the track object (Diesel, Nuclear).
	PropType *string `json:"propType,omitempty"`

	// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
	Pw *float64 `json:"pw,omitempty"`

	// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
	Reduced *bool `json:"reduced,omitempty"`

	// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
	Reinforced *bool `json:"reinforced,omitempty"`

	// Flag indicating whether this track is archived.
	RptArchived *bool `json:"rptArchived,omitempty"`

	// Source cross-reference code for the Command that originated the track report.
	RptChxref *string `json:"rptChxref,omitempty"`

	// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	Rtn *[]string `json:"rtn,omitempty"`

	// The name of the Command reporting the received track number (RTN).
	RtnCmd *string `json:"rtnCmd,omitempty"`

	// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with milliseconds precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
	RtnMsgTs *[]time.Time `json:"rtnMsgTs,omitempty"`

	// Value representing the state of the Received Track.
	RtnTrkState *string `json:"rtnTrkState,omitempty"`

	// Scan rate of the emitter, measured in seconds per rotation (SPR).
	ScanRate *float64 `json:"scanRate,omitempty"`

	// Type of radar scan.
	ScanType *string `json:"scanType,omitempty"`

	// The Sequential Contact Number (SCN) for this track.
	Scn *int32 `json:"scn,omitempty"`

	// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
	Sconum *string `json:"sconum,omitempty"`

	// Flag indicating that this track is self reported.
	SelfReport *bool `json:"selfReport,omitempty"`

	// Id/name of sensor providing the track data.
	Sen *string `json:"sen,omitempty"`

	// The common name for a group of ships with similar design, usually named for the first vessel of the class.
	ShipClass *string `json:"shipClass,omitempty"`

	// Abbreviated track name.
	ShortName *string `json:"shortName,omitempty"`

	// Source of the data.
	Source string `json:"source"`

	// The unique identifier of the source node.
	SourceUid *string `json:"sourceUid,omitempty"`

	// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
	SpaceAmp *string `json:"spaceAmp,omitempty"`

	// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
	SpaceAmpConf *int32 `json:"spaceAmpConf,omitempty"`

	// Specific type of point or track with an environment of space.
	SpaceSpecType *string `json:"spaceSpecType,omitempty"`

	// Track object speed, in meters/sec.
	Spd *float64 `json:"spd,omitempty"`

	// A text amplifier for units, equipment and installations; content is implementation specific.
	StaffCmts *string `json:"staffCmts,omitempty"`

	// The stern type code (Counter, Cruiser) associated with the track object.
	SternType *string `json:"sternType,omitempty"`

	// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
	TaskForce *bool `json:"taskForce,omitempty"`

	// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
	Tcpa *time.Time `json:"tcpa,omitempty"`

	// Threat Event System Track ID.
	TesEventId *string `json:"tesEventId,omitempty"`

	// Motion model Time On Leg in hours.
	Tol *float64 `json:"tol,omitempty"`

	// The number of turns of the vessel propellers per knot of forward motion.
	Tpk *float64 `json:"tpk,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
	TrkId *string `json:"trkId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
	TrkNum *string `json:"trkNum,omitempty"`

	// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Value Indicating the scope of this track:
	// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
	// 2 - LOCAL  (Local) - available only on workstations in the local area network
	// 3 - OTH  (Over the Horizon) - available to everyone.
	TrkScope *string `json:"trkScope,omitempty"`

	// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
	TrnspdrId *string `json:"trnspdrId,omitempty"`

	// Transponder type for the track.
	TrnspdrType *string `json:"trnspdrType,omitempty"`

	// Track timestamp in ISO8601 UTC format with microsecond precision.
	Ts time.Time `json:"ts"`

	// The weight, in tons, of the vessel associated with this track.
	VslWt *float64 `json:"vslWt,omitempty"`

	// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
	Width *float64 `json:"width,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackDetailsIngestDataMode string

// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
//
//	AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	LAND: On the surface of dry land.
//
//	SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
//
//	SURFACE: On the surface of a body of water.
//
//	SUBSURFACE: Below the surface of a body of water.
//
//	UNKNOWN: Environment is not known.
type TrackDetailsIngestEnv string

// The status of the missile track in this record, if reporting a missile track:
//
//	AT LAUNCH
//
//	AT OBSERVATION
//
//	FLYING
//
//	IMPACTED
//
//	LOST
//
//	STALE
//
//	DEBRIS
type TrackDetailsIngestMslStatus string

// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
//
//	ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
//
//	FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
//
//	HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
//
//	NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
//
//	PENDING: Track object which has not been evaluated.
//
//	SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
//
//	UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
type TrackDetailsIngestObjIdent string

// Schema for Track Sensor data
type TrackSensorAbridged struct {
	// The observing sensor azimuth angle, in degrees and topocentric frame.
	Az *float64 `json:"az,omitempty"`

	// Minimum range measurement capability of the sensor, in kilometers.
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// The mission number which produced this track observation.
	MissionNumber *string `json:"missionNumber,omitempty"`

	// The track object range from the observing sensor, in kilometers.
	Range *float64 `json:"range,omitempty"`

	// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
	SensorFOVType *TrackSensorAbridgedSensorFOVType `json:"sensorFOVType,omitempty"`

	// Unique name of this sensor.
	SensorName *string `json:"sensorName,omitempty"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`
}

// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
type TrackSensorAbridgedSensorFOVType string

// Schema for Track Sensor data
type TrackSensorFull struct {
	// The observing sensor azimuth angle, in degrees and topocentric frame.
	Az *float64 `json:"az,omitempty"`

	// Minimum range measurement capability of the sensor, in kilometers.
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// The mission number which produced this track observation.
	MissionNumber *string `json:"missionNumber,omitempty"`

	// The track object range from the observing sensor, in kilometers.
	Range *float64 `json:"range,omitempty"`

	// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
	SensorFOVType *TrackSensorFullSensorFOVType `json:"sensorFOVType,omitempty"`

	// Unique name of this sensor.
	SensorName *string `json:"sensorName,omitempty"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`
}

// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
type TrackSensorFullSensorFOVType string

// Schema for Track Sensor data
type TrackSensorIngest struct {
	// The observing sensor azimuth angle, in degrees and topocentric frame.
	Az *float64 `json:"az,omitempty"`

	// Minimum range measurement capability of the sensor, in kilometers.
	MinRangeLimit *float64 `json:"minRangeLimit,omitempty"`

	// The mission number which produced this track observation.
	MissionNumber *string `json:"missionNumber,omitempty"`

	// The track object range from the observing sensor, in kilometers.
	Range *float64 `json:"range,omitempty"`

	// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
	SensorFOVType *TrackSensorIngestSensorFOVType `json:"sensorFOVType,omitempty"`

	// Unique name of this sensor.
	SensorName *string `json:"sensorName,omitempty"`

	// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
	SensorNumber *int32 `json:"sensorNumber,omitempty"`
}

// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
type TrackSensorIngestSensorFOVType string

// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
type TrackAbridged struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar)
	Asset *string `json:"asset,omitempty"`

	// Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
	AssetNat *string `json:"assetNat,omitempty"`

	// The call sign currently assigned to this track object
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// Covariance matrix, in meter and second based units, for the defined cartesian system.
	//
	// The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackAbridgedDataMode `json:"dataMode"`

	// East, North, Up position components, in meters.  When provided, array must always contain 3 values.
	ENUPos *[]float64 `json:"eNUPos,omitempty"`

	// East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
	ENUVel *[]float64 `json:"eNUVel,omitempty"`

	// Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
	EcefAcc *[]float64 `json:"ecefAcc,omitempty"`

	// Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	// AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// LAND: On the surface of dry land.
	//
	// SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// SURFACE: On the surface of a body of water.
	//
	// SUBSURFACE: Below the surface of a body of water.
	//
	// UNKNOWN: Environment is not known.
	//
	Env *string `json:"env,omitempty"`

	// Track environment confidence estimate (not standardized)
	EnvConf *float64 `json:"envConf,omitempty"`

	// Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)]
	ErrEllp *[]float64 `json:"errEllp,omitempty"`

	// The track object heading, in degrees clockwise from true North at the object location.
	Hdng *float64 `json:"hdng,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	// FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	// JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	// KILO: Friendly high-value object.
	//
	// TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	// ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// Track object identity credibility
	IdentCred *int32 `json:"identCred,omitempty"`

	// Track object identity reliability
	IdentRel *int32 `json:"identRel,omitempty"`

	// The J-series message type, if this track is derived from a J-series message.
	JSeries *string `json:"jSeries,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat *float64 `json:"lat,omitempty"`

	// Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
	LcAcc *[]float64 `json:"lcAcc,omitempty"`

	// Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
	LcPos *[]float64 `json:"lcPos,omitempty"`

	// Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
	LcVel *[]float64 `json:"lcVel,omitempty"`

	// Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
	Lco *[]float64 `json:"lco,omitempty"`

	// x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
	Lcs *[]float64 `json:"lcs,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon *float64 `json:"lon,omitempty"`

	// Mode-1 interrogation response (mission code), indicating mission or aircraft type.
	M1 *int32 `json:"m1,omitempty"`

	// Mode-1 validity status.
	M1v *int32 `json:"m1v,omitempty"`

	// Mode-2 interrogation response (military identification code).
	M2 *int32 `json:"m2,omitempty"`

	// Mode-2 validity status.
	M2v *int32 `json:"m2v,omitempty"`

	// Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
	M3a *int32 `json:"m3a,omitempty"`

	// Mode-3/A validity status.
	M3av *int32 `json:"m3av,omitempty"`

	// The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
	//
	// AIS: Derived from an automated identification system source.
	//
	// BFT: Derived from a blue force tracking source.
	//
	// BIOMETRICS: Derived from a biometrics source.
	//
	// COMINT: Derived from a communications intelligence source.
	//
	// DOPPLER: Derived from a radar doppler source.
	//
	// ELINT: Derived from an electronics intelligence source.
	//
	// HRR: Derived from a radar high range resolution source.
	//
	// HUMINT: Derived from a human intelligence source.
	//
	// IMAGE: Derived from a still or motion imagery source.
	//
	// MASINT: Derived from a measurement and signals intelligence source.
	//
	// MIXED: Derived from a combination of two or more sources.
	//
	// OSINT: Derived from an open source intelligence source.
	//
	// OTHER: Derived from other types of unspecified sources.
	//
	ModType *string `json:"modType,omitempty"`

	// Message Timestamp
	MsgTs *time.Time `json:"msgTs,omitempty"`

	// Mission ID related to the track)
	MsnId *string `json:"msnId,omitempty"`

	// Flag indicating that this track is fused from multiple sensor sources
	MultiSource *bool `json:"multiSource,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
	ObjAct *string `json:"objAct,omitempty"`

	// The UID or designation of the tracked object
	ObjId *string `json:"objId,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	// ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	// FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	// HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	// NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	// PENDING: Track object which has not been evaluated.
	//
	// SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	// UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *string `json:"objIdent,omitempty"`

	// Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
	ObjSpec *string `json:"objSpec,omitempty"`

	// The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Id/name of sensor providing the track data
	Sen *string `json:"sen,omitempty"`

	// Sensor quality
	SenQual *string `json:"senQual,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Track object spd, in meters/sec
	Spd *float64 `json:"spd,omitempty"`

	// Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
	Strength *int32 `json:"strength,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object
	TrkId *string `json:"trkId,omitempty"`

	// UUID of the track item object, applies to STANAG-4676 messages
	TrkItmId *string `json:"trkItmId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions
	TrkNum *string `json:"trkNum,omitempty"`

	// Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.)
	TrkPtType *string `json:"trkPtType,omitempty"`

	// Value indicating track quality (not standardized)
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.)
	TrkStat *string `json:"trkStat,omitempty"`

	// Track timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackAbridgedDataMode string

// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
type TrackFull struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar)
	Asset *string `json:"asset,omitempty"`

	// Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
	AssetNat *string `json:"assetNat,omitempty"`

	// The call sign currently assigned to this track object
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// Covariance matrix, in meter and second based units, for the defined cartesian system.
	//
	// The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackFullDataMode `json:"dataMode"`

	// East, North, Up position components, in meters.  When provided, array must always contain 3 values.
	ENUPos *[]float64 `json:"eNUPos,omitempty"`

	// East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
	ENUVel *[]float64 `json:"eNUVel,omitempty"`

	// Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
	EcefAcc *[]float64 `json:"ecefAcc,omitempty"`

	// Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	// AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// LAND: On the surface of dry land.
	//
	// SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// SURFACE: On the surface of a body of water.
	//
	// SUBSURFACE: Below the surface of a body of water.
	//
	// UNKNOWN: Environment is not known.
	//
	Env *string `json:"env,omitempty"`

	// Track environment confidence estimate (not standardized)
	EnvConf *float64 `json:"envConf,omitempty"`

	// Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)]
	ErrEllp *[]float64 `json:"errEllp,omitempty"`

	// The track object heading, in degrees clockwise from true North at the object location.
	Hdng *float64 `json:"hdng,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	// FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	// JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	// KILO: Friendly high-value object.
	//
	// TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	// ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// Track object identity credibility
	IdentCred *int32 `json:"identCred,omitempty"`

	// Track object identity reliability
	IdentRel *int32 `json:"identRel,omitempty"`

	// The J-series message type, if this track is derived from a J-series message.
	JSeries *string `json:"jSeries,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat *float64 `json:"lat,omitempty"`

	// Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
	LcAcc *[]float64 `json:"lcAcc,omitempty"`

	// Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
	LcPos *[]float64 `json:"lcPos,omitempty"`

	// Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
	LcVel *[]float64 `json:"lcVel,omitempty"`

	// Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
	Lco *[]float64 `json:"lco,omitempty"`

	// x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
	Lcs *[]float64 `json:"lcs,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon *float64 `json:"lon,omitempty"`

	// Mode-1 interrogation response (mission code), indicating mission or aircraft type.
	M1 *int32 `json:"m1,omitempty"`

	// Mode-1 validity status.
	M1v *int32 `json:"m1v,omitempty"`

	// Mode-2 interrogation response (military identification code).
	M2 *int32 `json:"m2,omitempty"`

	// Mode-2 validity status.
	M2v *int32 `json:"m2v,omitempty"`

	// Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
	M3a *int32 `json:"m3a,omitempty"`

	// Mode-3/A validity status.
	M3av *int32 `json:"m3av,omitempty"`

	// The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
	//
	// AIS: Derived from an automated identification system source.
	//
	// BFT: Derived from a blue force tracking source.
	//
	// BIOMETRICS: Derived from a biometrics source.
	//
	// COMINT: Derived from a communications intelligence source.
	//
	// DOPPLER: Derived from a radar doppler source.
	//
	// ELINT: Derived from an electronics intelligence source.
	//
	// HRR: Derived from a radar high range resolution source.
	//
	// HUMINT: Derived from a human intelligence source.
	//
	// IMAGE: Derived from a still or motion imagery source.
	//
	// MASINT: Derived from a measurement and signals intelligence source.
	//
	// MIXED: Derived from a combination of two or more sources.
	//
	// OSINT: Derived from an open source intelligence source.
	//
	// OTHER: Derived from other types of unspecified sources.
	//
	ModType *string `json:"modType,omitempty"`

	// Message Timestamp
	MsgTs *time.Time `json:"msgTs,omitempty"`

	// Mission ID related to the track)
	MsnId *string `json:"msnId,omitempty"`

	// Flag indicating that this track is fused from multiple sensor sources
	MultiSource *bool `json:"multiSource,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
	ObjAct *string `json:"objAct,omitempty"`

	// The UID or designation of the tracked object
	ObjId *string `json:"objId,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	// ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	// FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	// HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	// NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	// PENDING: Track object which has not been evaluated.
	//
	// SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	// UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *string `json:"objIdent,omitempty"`

	// Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
	ObjSpec *string `json:"objSpec,omitempty"`

	// The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Id/name of sensor providing the track data
	Sen *string `json:"sen,omitempty"`

	// Sensor quality
	SenQual *string `json:"senQual,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Track object spd, in meters/sec
	Spd *float64 `json:"spd,omitempty"`

	// Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
	Strength *int32 `json:"strength,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object
	TrkId *string `json:"trkId,omitempty"`

	// UUID of the track item object, applies to STANAG-4676 messages
	TrkItmId *string `json:"trkItmId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions
	TrkNum *string `json:"trkNum,omitempty"`

	// Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.)
	TrkPtType *string `json:"trkPtType,omitempty"`

	// Value indicating track quality (not standardized)
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.)
	TrkStat *string `json:"trkStat,omitempty"`

	// Track timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackFullDataMode string

// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
type TrackIngest struct {
	// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
	Alt *float64 `json:"alt,omitempty"`

	// Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar)
	Asset *string `json:"asset,omitempty"`

	// Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
	AssetNat *string `json:"assetNat,omitempty"`

	// The call sign currently assigned to this track object
	CallSign *string `json:"callSign,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
	Cntct *string `json:"cntct,omitempty"`

	// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
	Course *float64 `json:"course,omitempty"`

	// Covariance matrix, in meter and second based units, for the defined cartesian system.
	//
	// The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	// z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
	//
	// x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
	//
	// y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
	//
	// z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
	//
	//
	//
	//
	//
	// The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	Cov *[]float64 `json:"cov,omitempty"`

	// Time the row was created in the database, auto-populated by the system
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database, auto-populated by the system
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode TrackIngestDataMode `json:"dataMode"`

	// East, North, Up position components, in meters.  When provided, array must always contain 3 values.
	ENUPos *[]float64 `json:"eNUPos,omitempty"`

	// East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
	ENUVel *[]float64 `json:"eNUVel,omitempty"`

	// Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
	EcefAcc *[]float64 `json:"ecefAcc,omitempty"`

	// Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
	EcefPos *[]float64 `json:"ecefPos,omitempty"`

	// Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
	EcefVel *[]float64 `json:"ecefVel,omitempty"`

	// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
	//
	// AIR: Between sea level and the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// LAND: On the surface of dry land.
	//
	// SPACE: Above the Krmn line, which has an altitude of 100 kilometers (62 miles).
	//
	// SURFACE: On the surface of a body of water.
	//
	// SUBSURFACE: Below the surface of a body of water.
	//
	// UNKNOWN: Environment is not known.
	//
	Env *string `json:"env,omitempty"`

	// Track environment confidence estimate (not standardized)
	EnvConf *float64 `json:"envConf,omitempty"`

	// Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)]
	ErrEllp *[]float64 `json:"errEllp,omitempty"`

	// The track object heading, in degrees clockwise from true North at the object location.
	Hdng *float64 `json:"hdng,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
	//
	// FAKER: Friendly track, object, or entity acting as an exercise hostile.
	//
	// JOKER: Friendly track, object, or entity acting as an exercise suspect.
	//
	// KILO: Friendly high-value object.
	//
	// TRAVELLER: Suspect land or surface track following a recognized traffic route.
	//
	// ZOMBIE: Suspect track, object, or entity of special interest.
	//
	IdentAmp *string `json:"identAmp,omitempty"`

	// Track object identity credibility
	IdentCred *int32 `json:"identCred,omitempty"`

	// Track object identity reliability
	IdentRel *int32 `json:"identRel,omitempty"`

	// The J-series message type, if this track is derived from a J-series message.
	JSeries *string `json:"jSeries,omitempty"`

	// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat *float64 `json:"lat,omitempty"`

	// Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
	LcAcc *[]float64 `json:"lcAcc,omitempty"`

	// Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
	LcPos *[]float64 `json:"lcPos,omitempty"`

	// Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
	LcVel *[]float64 `json:"lcVel,omitempty"`

	// Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
	Lco *[]float64 `json:"lco,omitempty"`

	// x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
	Lcs *[]float64 `json:"lcs,omitempty"`

	// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon *float64 `json:"lon,omitempty"`

	// Mode-1 interrogation response (mission code), indicating mission or aircraft type.
	M1 *int32 `json:"m1,omitempty"`

	// Mode-1 validity status.
	M1v *int32 `json:"m1v,omitempty"`

	// Mode-2 interrogation response (military identification code).
	M2 *int32 `json:"m2,omitempty"`

	// Mode-2 validity status.
	M2v *int32 `json:"m2v,omitempty"`

	// Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
	M3a *int32 `json:"m3a,omitempty"`

	// Mode-3/A validity status.
	M3av *int32 `json:"m3av,omitempty"`

	// The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
	//
	// AIS: Derived from an automated identification system source.
	//
	// BFT: Derived from a blue force tracking source.
	//
	// BIOMETRICS: Derived from a biometrics source.
	//
	// COMINT: Derived from a communications intelligence source.
	//
	// DOPPLER: Derived from a radar doppler source.
	//
	// ELINT: Derived from an electronics intelligence source.
	//
	// HRR: Derived from a radar high range resolution source.
	//
	// HUMINT: Derived from a human intelligence source.
	//
	// IMAGE: Derived from a still or motion imagery source.
	//
	// MASINT: Derived from a measurement and signals intelligence source.
	//
	// MIXED: Derived from a combination of two or more sources.
	//
	// OSINT: Derived from an open source intelligence source.
	//
	// OTHER: Derived from other types of unspecified sources.
	//
	ModType *string `json:"modType,omitempty"`

	// Message Timestamp
	MsgTs *time.Time `json:"msgTs,omitempty"`

	// Mission ID related to the track)
	MsnId *string `json:"msnId,omitempty"`

	// Flag indicating that this track is fused from multiple sensor sources
	MultiSource *bool `json:"multiSource,omitempty"`

	// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
	ObjAct *string `json:"objAct,omitempty"`

	// The UID or designation of the tracked object
	ObjId *string `json:"objId,omitempty"`

	// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
	//
	// ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
	//
	// FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
	//
	// HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
	//
	// NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
	//
	// PENDING: Track object which has not been evaluated.
	//
	// SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
	//
	// UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
	//
	ObjIdent *string `json:"objIdent,omitempty"`

	// Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
	ObjNat *string `json:"objNat,omitempty"`

	// The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
	ObjPlat *string `json:"objPlat,omitempty"`

	// The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
	ObjSpec *string `json:"objSpec,omitempty"`

	// The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
	ObjType *string `json:"objType,omitempty"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// Id/name of sensor providing the track data
	Sen *string `json:"sen,omitempty"`

	// Sensor quality
	SenQual *string `json:"senQual,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Track object spd, in meters/sec
	Spd *float64 `json:"spd,omitempty"`

	// Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
	SrcIds *[]string `json:"srcIds,omitempty"`

	// Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
	SrcTyps *[]string `json:"srcTyps,omitempty"`

	// The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
	Strength *int32 `json:"strength,omitempty"`

	// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence)
	TrkConf *float64 `json:"trkConf,omitempty"`

	// UUID identifying the track, which should remain the same on subsequent tracks of the same object
	TrkId *string `json:"trkId,omitempty"`

	// UUID of the track item object, applies to STANAG-4676 messages
	TrkItmId *string `json:"trkItmId,omitempty"`

	// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions
	TrkNum *string `json:"trkNum,omitempty"`

	// Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.)
	TrkPtType *string `json:"trkPtType,omitempty"`

	// Value indicating track quality (not standardized)
	TrkQual *int32 `json:"trkQual,omitempty"`

	// Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.)
	TrkStat *string `json:"trkStat,omitempty"`

	// Track timestamp in ISO8601 UTC format
	Ts time.Time `json:"ts"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type TrackIngestDataMode string

// These services provide for posting and querying Weather Over Target information. The information contained within describe the current weather conditions over a target area or region to include navigational considerations such as altimeter settings, visibility, cloud heights etc.
type WeatherReportAbridged struct {
	// Describes the actual weather at position. Intended as, but not constrained to, MIL-STD-6016 actual weather (e.g. NO STATEMENT, NO SIGNIFICANT WEATHER, DRIZZLE, RAIN, SNOW, SNOW GRAINS, DIAMOND DUST, ICE PELLETS, HAIL, SMALL HAIL, MIST, FOG, SMOKE, VOLCANIC ASH, WIDESPREAD DUST, SAND, HAZE, WELL DEVELOPED DUST, SQUALLS, FUNNEL CLOUDS, SANDSTORM, DUSTSTORM, LOW CLOUDS, CLOUDY, GROUND FOG, DUST, HEAVY RAIN, THUNDERSTORMS AWT, HEAVY THUNDERSTORMS, HURRICANE TYPHOON CYCLONE, TROPICAL STORM, TORNADO, HIGH WINDS, LIGHTNING, FREEZING DRIZZLE, FREEZING RAIN, HEAVY SNOW, ICING, SNOW OR RAIN AND SNOW MIXED, SHOWERS, CLEAR).
	ActWeather *string `json:"actWeather,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The measurement of air pressure in the atmosphere in kilopascals.
	BarPress *float64 `json:"barPress,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Array of cloud cover descriptions - each element can be maximum of 16 characters long. Intended as, but not constrained to, MIL-STD-6016 cloud cover designations (e.g. SKY CLEAR, SCATTERED, BROKEN, OVERCAST, SKY OBSCURED). Each element of the array correspond to the elements in the cloudHght array specified respectively.
	CloudCover *[]string `json:"cloudCover,omitempty"`

	// Array of cloud base heights in meters described by the cloudHght array. Each element of the array correspond to the elements in the cloudCover array specified respectively.
	CloudHght *[]float64 `json:"cloudHght,omitempty"`

	// Reports the lowest altitude at which contrails are occurring, in meters.
	ContrailHghtLower *float64 `json:"contrailHghtLower,omitempty"`

	// Reports the highest altitude at which contrails are occurring, in meters.
	ContrailHghtUpper *float64 `json:"contrailHghtUpper,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode WeatherReportAbridgedDataMode `json:"dataMode"`

	// Describes the flight conditions in route to the target  (NO STATEMENT, MAINLY IFR, MAINLY VFR, THUNDERSTORMS).
	//
	// MAINLY IFR:&nbsp;&nbsp;Predominantly Instrument Flight Rules.
	//
	// MAINLY VFR:&nbsp;&nbsp;Predominantly Visual Flight Rules.
	//
	// Thunderstorms:&nbsp;&nbsp;Thunderstorms expected in route.
	//
	EnRouteWeather *string `json:"enRouteWeather,omitempty"`

	// Reports the lowest altitude at which icing or freezing rain is occurring, in meters.
	IcingLowerLimit *float64 `json:"icingLowerLimit,omitempty"`

	// Reports the highest altitude at which icing or freezing rain is occurring, in meters.
	IcingUpperLimit *float64 `json:"icingUpperLimit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the ground imagery associated for this weather over target report.
	IdGroundImagery *string `json:"idGroundImagery,omitempty"`

	// WGS-84 latitude of the weather report, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the weather report, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Datetime of the weather observation in ISO 8601 UTC datetime format.
	ObTime time.Time `json:"obTime"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The speed at which water is being applied to a specific area in millimeters per hour.
	PrecipRate *float64 `json:"precipRate,omitempty"`

	// Altimeter set to read zero at mean sea level in kilopascals.
	Qnh *float64 `json:"qnh,omitempty"`

	// The percentage of water vapor in the atmosphere.
	RelHumidity *float64 `json:"relHumidity,omitempty"`

	// Sensor altitude at obTime in km. This includes pilot reports or other means of weather observation.
	Senalt *float64 `json:"senalt,omitempty"`

	// Sensor WGS84 latitude at obTime in degrees. -90 to 90 degrees (negative values south of equator). This includes pilot reports or other means of weather observation.
	Senlat *float64 `json:"senlat,omitempty"`

	// Sensor WGS84 longitude at obTime in degrees. -180 to 180 degrees (negative values west of Prime Meridian). This includes pilot reports or other means of weather observation.
	Senlon *float64 `json:"senlon,omitempty"`

	// The power per unit area received from the Sun in the form of electromagnetic radiation as measured in the wavelength range of the measuring instrument. The solar irradiance is measured in watt per square meter (W/m2).
	SolarRad *float64 `json:"solarRad,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Describes in which direction (if any) that better weather conditions exist. Intended as, but not constrained to, MIL-STD-6016 surrounding weather designations (e.g. NO STATEMENT, BETTER TO NORTH, BETTER TO EAST, BETTER TO SOUTH, BETTER TO WEST).
	SurroundingWeather *string `json:"surroundingWeather,omitempty"`

	// The measurement of air temperature in degrees C.
	Temperature *float64 `json:"temperature,omitempty"`

	// Visual distance in meters.
	Visibility *float64 `json:"visibility,omitempty"`

	// Amplifies the actual weather being reported. Intended as, but not constrained to, MIL-STD-6016 weather amplification designations (e.g. NO STATEMENT, NO SCATTERED BROKEN MEDIUM CLOUD, SCATTERED BROKEN MEDIUM CLOUDS, GUSTY WINDS AT SERVICE, FOG IN VALLEYS, HIGHER TERRAIN OBSCURED, SURFACE CONDITIONS VARIABLE, SURFACE WIND NE, SURFACE WIND SE, SURFACE WIND SW, SURFACE WIND NW, PRESENCE OF CUMULONIMBUS).
	WeatherAmp *string `json:"weatherAmp,omitempty"`

	// Used in conjunction with actWeather and weatherInt. Intended as, but not constrained to, MIL-STD-6016 actual weather descriptor (e.g. NO STATEMENT, SHALLOW ,PATCHES, LOW DRIFTING, BLOWING, SHOWERS, THUNDERSTORMS, SUPERCOOLED).
	WeatherDesc *string `json:"weatherDesc,omitempty"`

	// Identifier of the weather over target, which should remain the same on subsequent Weather Over Target records.
	WeatherId *string `json:"weatherId,omitempty"`

	// Weather Intensity. Used in conjunction with actWeather and weatherDesc. Intended as, but not constrained to, MIL-STD-6016 weather intensity (e.g. NO STATEMENT, LIGHT, MODERATE, HEAVY, IN VICINITY).
	WeatherInt *string `json:"weatherInt,omitempty"`

	// Covariance matrix, in knots and second based units.  The array values represent the lower triangular half of the covariance matrix. The size of the covariance matrix is 2x2.  The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	WindCov *[]float64 `json:"windCov,omitempty"`

	// Direction the wind is blowing, in degrees clockwise from true north.
	WindDir *float64 `json:"windDir,omitempty"`

	// Expresses the max gust speed of the wind, in meters/second.
	WindGust *float64 `json:"windGust,omitempty"`

	// Expresses the speed of the wind in meters/second.
	WindSpd *float64 `json:"windSpd,omitempty"`

	// Boolean describing whether or not the wind direction and/or speed is variable.
	WindVar *bool `json:"windVar,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type WeatherReportAbridgedDataMode string

// These services provide for posting and querying Weather Over Target information. The information contained within describe the current weather conditions over a target area or region to include navigational considerations such as altimeter settings, visibility, cloud heights etc.
type WeatherReportFull struct {
	// Describes the actual weather at position. Intended as, but not constrained to, MIL-STD-6016 actual weather (e.g. NO STATEMENT, NO SIGNIFICANT WEATHER, DRIZZLE, RAIN, SNOW, SNOW GRAINS, DIAMOND DUST, ICE PELLETS, HAIL, SMALL HAIL, MIST, FOG, SMOKE, VOLCANIC ASH, WIDESPREAD DUST, SAND, HAZE, WELL DEVELOPED DUST, SQUALLS, FUNNEL CLOUDS, SANDSTORM, DUSTSTORM, LOW CLOUDS, CLOUDY, GROUND FOG, DUST, HEAVY RAIN, THUNDERSTORMS AWT, HEAVY THUNDERSTORMS, HURRICANE TYPHOON CYCLONE, TROPICAL STORM, TORNADO, HIGH WINDS, LIGHTNING, FREEZING DRIZZLE, FREEZING RAIN, HEAVY SNOW, ICING, SNOW OR RAIN AND SNOW MIXED, SHOWERS, CLEAR).
	ActWeather *string `json:"actWeather,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The measurement of air pressure in the atmosphere in kilopascals.
	BarPress *float64 `json:"barPress,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Array of cloud cover descriptions - each element can be maximum of 16 characters long. Intended as, but not constrained to, MIL-STD-6016 cloud cover designations (e.g. SKY CLEAR, SCATTERED, BROKEN, OVERCAST, SKY OBSCURED). Each element of the array correspond to the elements in the cloudHght array specified respectively.
	CloudCover *[]string `json:"cloudCover,omitempty"`

	// Array of cloud base heights in meters described by the cloudHght array. Each element of the array correspond to the elements in the cloudCover array specified respectively.
	CloudHght *[]float64 `json:"cloudHght,omitempty"`

	// Reports the lowest altitude at which contrails are occurring, in meters.
	ContrailHghtLower *float64 `json:"contrailHghtLower,omitempty"`

	// Reports the highest altitude at which contrails are occurring, in meters.
	ContrailHghtUpper *float64 `json:"contrailHghtUpper,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode WeatherReportFullDataMode `json:"dataMode"`

	// Describes the flight conditions in route to the target  (NO STATEMENT, MAINLY IFR, MAINLY VFR, THUNDERSTORMS).
	//
	// MAINLY IFR:&nbsp;&nbsp;Predominantly Instrument Flight Rules.
	//
	// MAINLY VFR:&nbsp;&nbsp;Predominantly Visual Flight Rules.
	//
	// Thunderstorms:&nbsp;&nbsp;Thunderstorms expected in route.
	//
	EnRouteWeather *string `json:"enRouteWeather,omitempty"`

	// Reports the lowest altitude at which icing or freezing rain is occurring, in meters.
	IcingLowerLimit *float64 `json:"icingLowerLimit,omitempty"`

	// Reports the highest altitude at which icing or freezing rain is occurring, in meters.
	IcingUpperLimit *float64 `json:"icingUpperLimit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the ground imagery associated for this weather over target report.
	IdGroundImagery *string `json:"idGroundImagery,omitempty"`

	// WGS-84 latitude of the weather report, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the weather report, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Datetime of the weather observation in ISO 8601 UTC datetime format.
	ObTime time.Time `json:"obTime"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The speed at which water is being applied to a specific area in millimeters per hour.
	PrecipRate *float64 `json:"precipRate,omitempty"`

	// Altimeter set to read zero at mean sea level in kilopascals.
	Qnh *float64 `json:"qnh,omitempty"`

	// The percentage of water vapor in the atmosphere.
	RelHumidity *float64 `json:"relHumidity,omitempty"`

	// Sensor altitude at obTime in km. This includes pilot reports or other means of weather observation.
	Senalt *float64 `json:"senalt,omitempty"`

	// Sensor WGS84 latitude at obTime in degrees. -90 to 90 degrees (negative values south of equator). This includes pilot reports or other means of weather observation.
	Senlat *float64 `json:"senlat,omitempty"`

	// Sensor WGS84 longitude at obTime in degrees. -180 to 180 degrees (negative values west of Prime Meridian). This includes pilot reports or other means of weather observation.
	Senlon *float64 `json:"senlon,omitempty"`

	// The power per unit area received from the Sun in the form of electromagnetic radiation as measured in the wavelength range of the measuring instrument. The solar irradiance is measured in watt per square meter (W/m2).
	SolarRad *float64 `json:"solarRad,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Describes in which direction (if any) that better weather conditions exist. Intended as, but not constrained to, MIL-STD-6016 surrounding weather designations (e.g. NO STATEMENT, BETTER TO NORTH, BETTER TO EAST, BETTER TO SOUTH, BETTER TO WEST).
	SurroundingWeather *string `json:"surroundingWeather,omitempty"`

	// The measurement of air temperature in degrees C.
	Temperature *float64 `json:"temperature,omitempty"`

	// Visual distance in meters.
	Visibility *float64 `json:"visibility,omitempty"`

	// Amplifies the actual weather being reported. Intended as, but not constrained to, MIL-STD-6016 weather amplification designations (e.g. NO STATEMENT, NO SCATTERED BROKEN MEDIUM CLOUD, SCATTERED BROKEN MEDIUM CLOUDS, GUSTY WINDS AT SERVICE, FOG IN VALLEYS, HIGHER TERRAIN OBSCURED, SURFACE CONDITIONS VARIABLE, SURFACE WIND NE, SURFACE WIND SE, SURFACE WIND SW, SURFACE WIND NW, PRESENCE OF CUMULONIMBUS).
	WeatherAmp *string `json:"weatherAmp,omitempty"`

	// Used in conjunction with actWeather and weatherInt. Intended as, but not constrained to, MIL-STD-6016 actual weather descriptor (e.g. NO STATEMENT, SHALLOW ,PATCHES, LOW DRIFTING, BLOWING, SHOWERS, THUNDERSTORMS, SUPERCOOLED).
	WeatherDesc *string `json:"weatherDesc,omitempty"`

	// Identifier of the weather over target, which should remain the same on subsequent Weather Over Target records.
	WeatherId *string `json:"weatherId,omitempty"`

	// Weather Intensity. Used in conjunction with actWeather and weatherDesc. Intended as, but not constrained to, MIL-STD-6016 weather intensity (e.g. NO STATEMENT, LIGHT, MODERATE, HEAVY, IN VICINITY).
	WeatherInt *string `json:"weatherInt,omitempty"`

	// Covariance matrix, in knots and second based units.  The array values represent the lower triangular half of the covariance matrix. The size of the covariance matrix is 2x2.  The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	WindCov *[]float64 `json:"windCov,omitempty"`

	// Direction the wind is blowing, in degrees clockwise from true north.
	WindDir *float64 `json:"windDir,omitempty"`

	// Expresses the max gust speed of the wind, in meters/second.
	WindGust *float64 `json:"windGust,omitempty"`

	// Expresses the speed of the wind in meters/second.
	WindSpd *float64 `json:"windSpd,omitempty"`

	// Boolean describing whether or not the wind direction and/or speed is variable.
	WindVar *bool `json:"windVar,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type WeatherReportFullDataMode string

// These services provide for posting and querying Weather Over Target information. The information contained within describe the current weather conditions over a target area or region to include navigational considerations such as altimeter settings, visibility, cloud heights etc.
type WeatherReportIngest struct {
	// Describes the actual weather at position. Intended as, but not constrained to, MIL-STD-6016 actual weather (e.g. NO STATEMENT, NO SIGNIFICANT WEATHER, DRIZZLE, RAIN, SNOW, SNOW GRAINS, DIAMOND DUST, ICE PELLETS, HAIL, SMALL HAIL, MIST, FOG, SMOKE, VOLCANIC ASH, WIDESPREAD DUST, SAND, HAZE, WELL DEVELOPED DUST, SQUALLS, FUNNEL CLOUDS, SANDSTORM, DUSTSTORM, LOW CLOUDS, CLOUDY, GROUND FOG, DUST, HEAVY RAIN, THUNDERSTORMS AWT, HEAVY THUNDERSTORMS, HURRICANE TYPHOON CYCLONE, TROPICAL STORM, TORNADO, HIGH WINDS, LIGHTNING, FREEZING DRIZZLE, FREEZING RAIN, HEAVY SNOW, ICING, SNOW OR RAIN AND SNOW MIXED, SHOWERS, CLEAR).
	ActWeather *string `json:"actWeather,omitempty"`

	// Geographical ref as GeoJSON for region. See https://geojson.org/ for more information on the GeoJSON format.
	Agjson *string `json:"agjson,omitempty"`

	// Point height above ellipsoid (WGS-84), in meters.
	Alt *float64 `json:"alt,omitempty"`

	// Number of dimensions of the geometry depicted by region.
	Andims *int32 `json:"andims,omitempty"`

	// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
	Area *string `json:"area,omitempty"`

	// Geographical spatial_ref_sys for region.
	Asrid *int32 `json:"asrid,omitempty"`

	// Geographical region or polygon (lon/lat pairs) of the image as projected on the ground in Well-Known Text (WKT) format. See https://www.opengeospatial.org/standards/wkt-crs for more information on WKT.
	Atext *string `json:"atext,omitempty"`

	// Type of region as projected on the ground.
	Atype *string `json:"atype,omitempty"`

	// The measurement of air pressure in the atmosphere in kilopascals.
	BarPress *float64 `json:"barPress,omitempty"`

	// Classification marking of the data in IC/CAPCO Portion-marked format
	ClassificationMarking string `json:"classificationMarking"`

	// Array of cloud cover descriptions - each element can be maximum of 16 characters long. Intended as, but not constrained to, MIL-STD-6016 cloud cover designations (e.g. SKY CLEAR, SCATTERED, BROKEN, OVERCAST, SKY OBSCURED). Each element of the array correspond to the elements in the cloudHght array specified respectively.
	CloudCover *[]string `json:"cloudCover,omitempty"`

	// Array of cloud base heights in meters described by the cloudHght array. Each element of the array correspond to the elements in the cloudCover array specified respectively.
	CloudHght *[]float64 `json:"cloudHght,omitempty"`

	// Reports the lowest altitude at which contrails are occurring, in meters.
	ContrailHghtLower *float64 `json:"contrailHghtLower,omitempty"`

	// Reports the highest altitude at which contrails are occurring, in meters.
	ContrailHghtUpper *float64 `json:"contrailHghtUpper,omitempty"`

	// Time the row was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Application user who created the row in the database
	CreatedBy *string `json:"createdBy,omitempty"`

	// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
	//
	// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
	//
	// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
	//
	// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
	//
	// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
	//
	DataMode WeatherReportIngestDataMode `json:"dataMode"`

	// Describes the flight conditions in route to the target  (NO STATEMENT, MAINLY IFR, MAINLY VFR, THUNDERSTORMS).
	//
	// MAINLY IFR:&nbsp;&nbsp;Predominantly Instrument Flight Rules.
	//
	// MAINLY VFR:&nbsp;&nbsp;Predominantly Visual Flight Rules.
	//
	// Thunderstorms:&nbsp;&nbsp;Thunderstorms expected in route.
	//
	EnRouteWeather *string `json:"enRouteWeather,omitempty"`

	// Reports the lowest altitude at which icing or freezing rain is occurring, in meters.
	IcingLowerLimit *float64 `json:"icingLowerLimit,omitempty"`

	// Reports the highest altitude at which icing or freezing rain is occurring, in meters.
	IcingUpperLimit *float64 `json:"icingUpperLimit,omitempty"`

	// Unique identifier of the record, auto-generated by the system
	Id *string `json:"id,omitempty"`

	// Identifier of the ground imagery associated for this weather over target report.
	IdGroundImagery *string `json:"idGroundImagery,omitempty"`

	// WGS-84 latitude of the weather report, in degrees. -90 to 90 degrees (negative values south of equator).
	Lat float64 `json:"lat"`

	// WGS-84 longitude of the weather report, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
	Lon float64 `json:"lon"`

	// Datetime of the weather observation in ISO 8601 UTC datetime format.
	ObTime time.Time `json:"obTime"`

	// The originating source network on which this record was created, auto-populated by the system.
	OrigNetwork *string `json:"origNetwork,omitempty"`

	// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
	Origin *string `json:"origin,omitempty"`

	// The speed at which water is being applied to a specific area in millimeters per hour.
	PrecipRate *float64 `json:"precipRate,omitempty"`

	// Altimeter set to read zero at mean sea level in kilopascals.
	Qnh *float64 `json:"qnh,omitempty"`

	// The percentage of water vapor in the atmosphere.
	RelHumidity *float64 `json:"relHumidity,omitempty"`

	// Sensor altitude at obTime in km. This includes pilot reports or other means of weather observation.
	Senalt *float64 `json:"senalt,omitempty"`

	// Sensor WGS84 latitude at obTime in degrees. -90 to 90 degrees (negative values south of equator). This includes pilot reports or other means of weather observation.
	Senlat *float64 `json:"senlat,omitempty"`

	// Sensor WGS84 longitude at obTime in degrees. -180 to 180 degrees (negative values west of Prime Meridian). This includes pilot reports or other means of weather observation.
	Senlon *float64 `json:"senlon,omitempty"`

	// The power per unit area received from the Sun in the form of electromagnetic radiation as measured in the wavelength range of the measuring instrument. The solar irradiance is measured in watt per square meter (W/m2).
	SolarRad *float64 `json:"solarRad,omitempty"`

	// Source of the data
	Source string `json:"source"`

	// Describes in which direction (if any) that better weather conditions exist. Intended as, but not constrained to, MIL-STD-6016 surrounding weather designations (e.g. NO STATEMENT, BETTER TO NORTH, BETTER TO EAST, BETTER TO SOUTH, BETTER TO WEST).
	SurroundingWeather *string `json:"surroundingWeather,omitempty"`

	// The measurement of air temperature in degrees C.
	Temperature *float64 `json:"temperature,omitempty"`

	// Visual distance in meters.
	Visibility *float64 `json:"visibility,omitempty"`

	// Amplifies the actual weather being reported. Intended as, but not constrained to, MIL-STD-6016 weather amplification designations (e.g. NO STATEMENT, NO SCATTERED BROKEN MEDIUM CLOUD, SCATTERED BROKEN MEDIUM CLOUDS, GUSTY WINDS AT SERVICE, FOG IN VALLEYS, HIGHER TERRAIN OBSCURED, SURFACE CONDITIONS VARIABLE, SURFACE WIND NE, SURFACE WIND SE, SURFACE WIND SW, SURFACE WIND NW, PRESENCE OF CUMULONIMBUS).
	WeatherAmp *string `json:"weatherAmp,omitempty"`

	// Used in conjunction with actWeather and weatherInt. Intended as, but not constrained to, MIL-STD-6016 actual weather descriptor (e.g. NO STATEMENT, SHALLOW ,PATCHES, LOW DRIFTING, BLOWING, SHOWERS, THUNDERSTORMS, SUPERCOOLED).
	WeatherDesc *string `json:"weatherDesc,omitempty"`

	// Identifier of the weather over target, which should remain the same on subsequent Weather Over Target records.
	WeatherId *string `json:"weatherId,omitempty"`

	// Weather Intensity. Used in conjunction with actWeather and weatherDesc. Intended as, but not constrained to, MIL-STD-6016 weather intensity (e.g. NO STATEMENT, LIGHT, MODERATE, HEAVY, IN VICINITY).
	WeatherInt *string `json:"weatherInt,omitempty"`

	// Covariance matrix, in knots and second based units.  The array values represent the lower triangular half of the covariance matrix. The size of the covariance matrix is 2x2.  The covariance elements are position dependent within the array with values ordered as follows:
	//
	// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y
	//
	// x&nbsp;&nbsp;&nbsp;&nbsp;1
	//
	// y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
	//
	//
	// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
	//
	WindCov *[]float64 `json:"windCov,omitempty"`

	// Direction the wind is blowing, in degrees clockwise from true north.
	WindDir *float64 `json:"windDir,omitempty"`

	// Expresses the max gust speed of the wind, in meters/second.
	WindGust *float64 `json:"windGust,omitempty"`

	// Expresses the speed of the wind in meters/second.
	WindSpd *float64 `json:"windSpd,omitempty"`

	// Boolean describing whether or not the wind direction and/or speed is variable.
	WindVar *bool `json:"windVar,omitempty"`
}

// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
//
// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
//
// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
//
// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
//
// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
type WeatherReportIngestDataMode string

// FiledropEphemPostIdParams defines parameters for FiledropEphemPostId.
type FiledropEphemPostIdParams struct {
	// Unique identifier of the on-orbit satellite object.
	IdOnOrbit string `form:"idOnOrbit" json:"idOnOrbit"`

	// Classification marking of the data in IC/CAPCO Portion-marked format.
	Classification string `form:"classification" json:"classification"`

	// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
	DataMode DataMode `form:"dataMode" json:"dataMode"`

	// Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
	HasMnvr bool `form:"hasMnvr" json:"hasMnvr"`

	// Ephemeris type.
	Type string `form:"type" json:"type"`

	// Ephemeris category.
	Category string `form:"category" json:"category"`

	// Ephemeris format as documented in Flight Safety Handbook.
	EphemFormatType EphemFormatType `form:"ephemFormatType" json:"ephemFormatType"`

	// Optional origin of the Ephemeris.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`

	// Source of the Ephemeris data.
	Source string `form:"source" json:"source"`
}

// FiledropUdlAircraftsortiePostIdJSONBody defines parameters for FiledropUdlAircraftsortiePostId.
type FiledropUdlAircraftsortiePostIdJSONBody = []AircraftSortieIngest

// FiledropUdlAisPostIdJSONBody defines parameters for FiledropUdlAisPostId.
type FiledropUdlAisPostIdJSONBody = []AISIngest

// FiledropUdlAnalyticimageryPostIdJSONBody defines parameters for FiledropUdlAnalyticimageryPostId.
type FiledropUdlAnalyticimageryPostIdJSONBody = AnalyticImageryAbridged

// FiledropUdlAttitudesetPostIdJSONBody defines parameters for FiledropUdlAttitudesetPostId.
type FiledropUdlAttitudesetPostIdJSONBody = AttitudeSetIngest

// FiledropUdlElsetPostIdJSONBody defines parameters for FiledropUdlElsetPostId.
type FiledropUdlElsetPostIdJSONBody = []ElsetIngest

// FiledropUdlEphsetPostIdJSONBody defines parameters for FiledropUdlEphsetPostId.
type FiledropUdlEphsetPostIdJSONBody = EphemerisSetIngest

// FiledropUdlEventevolutionPostIdJSONBody defines parameters for FiledropUdlEventevolutionPostId.
type FiledropUdlEventevolutionPostIdJSONBody = []EventEvolutionIngest

// FiledropUdlOrbittrackPostIdJSONBody defines parameters for FiledropUdlOrbittrackPostId.
type FiledropUdlOrbittrackPostIdJSONBody = []OrbitTrackIngest

// FiledropUdlPoiPostIdJSONBody defines parameters for FiledropUdlPoiPostId.
type FiledropUdlPoiPostIdJSONBody = []POIIngest

// FiledropUdlSigactPostIdJSONBody defines parameters for FiledropUdlSigactPostId.
type FiledropUdlSigactPostIdJSONBody = []SigActIngest

// FiledropUdlTracksPostIdJSONBody defines parameters for FiledropUdlTracksPostId.
type FiledropUdlTracksPostIdJSONBody = []TrackIngest

// FiledropWeatherreportPostIdJSONBody defines parameters for FiledropWeatherreportPostId.
type FiledropWeatherreportPostIdJSONBody = []WeatherReportIngest

// Create2JSONBody defines parameters for Create2.
type Create2JSONBody = AircraftIngest

// FindAllTuples2Params defines parameters for FindAllTuples2.
type FindAllTuples2Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// EditJSONBody defines parameters for Edit.
type EditJSONBody = AircraftIngest

// FindAllWithStreamParams defines parameters for FindAllWithStream.
type FindAllWithStreamParams struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// Create3JSONBody defines parameters for Create3.
type Create3JSONBody = AircraftSortieIngest

// CountREST1Params defines parameters for CountREST1.
type CountREST1Params struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// CreateBulks1JSONBody defines parameters for CreateBulks1.
type CreateBulks1JSONBody = []AircraftSortieIngest

// FindAllHistory2Params defines parameters for FindAllHistory2.
type FindAllHistory2Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// FindAllHistoryAodr2Params defines parameters for FindAllHistoryAodr2.
type FindAllHistoryAodr2Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// CountHistory2Params defines parameters for CountHistory2.
type CountHistory2Params struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// FindAllTuples3Params defines parameters for FindAllTuples3.
type FindAllTuples3Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// Edit1JSONBody defines parameters for Edit1.
type Edit1JSONBody = AircraftSortieIngest

// Create4JSONBody defines parameters for Create4.
type Create4JSONBody = AircraftStatusIngest

// FindAllTuples4Params defines parameters for FindAllTuples4.
type FindAllTuples4Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// Edit2JSONBody defines parameters for Edit2.
type Edit2JSONBody = AircraftStatusIngest

// FindAllParams defines parameters for FindAll.
type FindAllParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateJSONBody defines parameters for Create.
type CreateJSONBody = AISIngest

// CountDuplicateParams defines parameters for CountDuplicate.
type CountDuplicateParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulksJSONBody defines parameters for CreateBulks.
type CreateBulksJSONBody = []AISIngest

// FindAllHistoryParams defines parameters for FindAllHistory.
type FindAllHistoryParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodrParams defines parameters for FindAllHistoryAodr.
type FindAllHistoryAodrParams struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistoryParams defines parameters for CountHistory.
type CountHistoryParams struct {
	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuplesParams defines parameters for FindAllTuples.
type FindAllTuplesParams struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The timestamp that the vessel position was recorded, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll4Params defines parameters for FindAll4.
type FindAll4Params struct {
	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// CountREST3Params defines parameters for CountREST3.
type CountREST3Params struct {
	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// FindAllHistory3Params defines parameters for FindAllHistory3.
type FindAllHistory3Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// FindAllHistoryAodr3Params defines parameters for FindAllHistoryAodr3.
type FindAllHistoryAodr3Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// CountHistory3Params defines parameters for CountHistory3.
type CountHistory3Params struct {
	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// FindAllTuples5Params defines parameters for FindAllTuples5.
type FindAllTuples5Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The message time of this image record, in ISO8601 UTC format with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	MsgTime time.Time `form:"msgTime" json:"msgTime"`
}

// FindAllWithStream1Params defines parameters for FindAllWithStream1.
type FindAllWithStream1Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// CountDuplicate2Params defines parameters for CountDuplicate2.
type CountDuplicate2Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllHistory4Params defines parameters for FindAllHistory4.
type FindAllHistory4Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllHistoryAodr4Params defines parameters for FindAllHistoryAodr4.
type FindAllHistoryAodr4Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// CountHistory4Params defines parameters for CountHistory4.
type CountHistory4Params struct {
	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllTuples7Params defines parameters for FindAllTuples7.
type FindAllTuples7Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Unique identifier of the parent AttitudeSet associated with this record. (uuid)
	AsId string `form:"asId" json:"asId"`
}

// FindAllWithStream2Params defines parameters for FindAllWithStream2.
type FindAllWithStream2Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// Create7JSONBody defines parameters for Create7.
type Create7JSONBody = AttitudeSetIngest

// CountREST5Params defines parameters for CountREST5.
type CountREST5Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllHistory5Params defines parameters for FindAllHistory5.
type FindAllHistory5Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllHistoryAodr5Params defines parameters for FindAllHistoryAodr5.
type FindAllHistoryAodr5Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// CountHistory5Params defines parameters for CountHistory5.
type CountHistory5Params struct {
	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// FindAllTuples8Params defines parameters for FindAllTuples8.
type FindAllTuples8Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The epoch or start time of the attitude parameter or attitude ephemeris, in ISO 8601 UTC format, with microsecond precision.  If this set is constituted by a single attitude parameter message then startTime is the epoch. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	StartTime time.Time `form:"startTime" json:"startTime"`
}

// PostCotToBluestaqTakServerJSONBody defines parameters for PostCotToBluestaqTakServer.
type PostCotToBluestaqTakServerJSONBody = CotDataIngest

// FindAllWithStream8Params defines parameters for FindAllWithStream8.
type FindAllWithStream8Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// Create28JSONBody defines parameters for Create28.
type Create28JSONBody = ElsetIngest

// CountREST24Params defines parameters for CountREST24.
type CountREST24Params struct {
	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// CreateBulks8JSONBody defines parameters for CreateBulks8.
type CreateBulks8JSONBody = []ElsetIngest

// CreateBulks8Params defines parameters for CreateBulks8.
type CreateBulks8Params struct {
	// Boolean indicating if these elsets should be checked for duplicates, default is not to
	DupeCheck *bool `form:"dupeCheck,omitempty" json:"dupeCheck,omitempty"`
}

// CreateBulkFromTLEParams defines parameters for CreateBulkFromTLE.
type CreateBulkFromTLEParams struct {
	// Data mode of the passed elsets (REAL, TEST, etc)
	DataMode string `form:"dataMode" json:"dataMode"`

	// Dissemination control of the passed elsets (e.g. to support tagging with proprietary markings)
	Control *string `form:"control,omitempty" json:"control,omitempty"`

	// Boolean indicating if these elsets should be set as the 'current' for their corresponding on-orbit/satellite numbers.
	MakeCurrent bool `form:"makeCurrent" json:"makeCurrent"`

	// Source of the elset data.
	Source string `form:"source" json:"source"`

	// Origin of the elset data.
	Origin *string `form:"origin,omitempty" json:"origin,omitempty"`

	// Boolean indicating if a shell Onorbit/satellite should be created if the passed satellite number doesn't exist.
	AutoCreateSats *bool `form:"autoCreateSats,omitempty" json:"autoCreateSats,omitempty"`

	// Optional comma-delineated list of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`
}

// CurrentTupleParams defines parameters for CurrentTuple.
type CurrentTupleParams struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// FindAllHistory16Params defines parameters for FindAllHistory16.
type FindAllHistory16Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllHistoryAodr16Params defines parameters for FindAllHistoryAodr16.
type FindAllHistoryAodr16Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// CountHistory16Params defines parameters for CountHistory16.
type CountHistory16Params struct {
	// Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch time.Time `form:"epoch" json:"epoch"`
}

// FindAllTuples29Params defines parameters for FindAllTuples29.
type FindAllTuples29Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'epoch, idElset' are required.) Elset epoch time in ISO 8601 UTC format, with microsecond precision (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Epoch *time.Time `form:"epoch,omitempty" json:"epoch,omitempty"`

	// (One or more of fields 'epoch, idElset' are required.) UUID of the elset
	IdElset *string `form:"idElset,omitempty" json:"idElset,omitempty"`
}

// FindAllWithStream9Params defines parameters for FindAllWithStream9.
type FindAllWithStream9Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountDuplicate6Params defines parameters for CountDuplicate6.
type CountDuplicate6Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistory17Params defines parameters for FindAllHistory17.
type FindAllHistory17Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllHistoryAodr17Params defines parameters for FindAllHistoryAodr17.
type FindAllHistoryAodr17Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// CountHistory17Params defines parameters for CountHistory17.
type CountHistory17Params struct {
	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllTuples32Params defines parameters for FindAllTuples32.
type FindAllTuples32Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Unique identifier of the parent EphemerisSet (uuid)
	EsId string `form:"esId" json:"esId"`
}

// FindAllWithStream10Params defines parameters for FindAllWithStream10.
type FindAllWithStream10Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// Create32JSONBody defines parameters for Create32.
type Create32JSONBody = EphemerisSetIngest

// CountREST27Params defines parameters for CountREST27.
type CountREST27Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistory18Params defines parameters for FindAllHistory18.
type FindAllHistory18Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllHistoryAodr18Params defines parameters for FindAllHistoryAodr18.
type FindAllHistoryAodr18Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// CountHistory18Params defines parameters for CountHistory18.
type CountHistory18Params struct {
	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAllTuples33Params defines parameters for FindAllTuples33.
type FindAllTuples33Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) End time/last time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointEndTime *time.Time `form:"pointEndTime,omitempty" json:"pointEndTime,omitempty"`

	// (One or more of fields 'pointEndTime, pointStartTime' are required.) Start time/first time point of the ephemeris, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	PointStartTime *time.Time `form:"pointStartTime,omitempty" json:"pointStartTime,omitempty"`
}

// FindAll27Params defines parameters for FindAll27.
type FindAll27Params struct {
	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// Create34JSONBody defines parameters for Create34.
type Create34JSONBody = EventEvolutionIngest

// CountParams defines parameters for Count.
type CountParams struct {
	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// CreateBulk4JSONBody defines parameters for CreateBulk4.
type CreateBulk4JSONBody = []EventEvolutionIngest

// FindAllHistory20Params defines parameters for FindAllHistory20.
type FindAllHistory20Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// FindAllHistoryAodr19Params defines parameters for FindAllHistoryAodr19.
type FindAllHistoryAodr19Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// CountHistory20Params defines parameters for CountHistory20.
type CountHistory20Params struct {
	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// FindAllTuples35Params defines parameters for FindAllTuples35.
type FindAllTuples35Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the 'queryhelp' operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// (One or more of fields 'eventId, startTime' are required.) User-provided unique identifier of this activity or event. This ID should remain the same on subsequent updates in order to associate all records pertaining to the activity or event.
	EventId *string `form:"eventId,omitempty" json:"eventId,omitempty"`

	// (One or more of fields 'eventId, startTime' are required.) The actual or estimated start time of the activity or event, in ISO 8601 UTC format. (YYYY-MM-DDTHH:MM:SS.sssZ)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`
}

// FindAll33Params defines parameters for FindAll33.
type FindAll33Params struct {
	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// Create38JSONBody defines parameters for Create38.
type Create38JSONBody = HazardIngest

// CountREST32Params defines parameters for CountREST32.
type CountREST32Params struct {
	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// CreateBulks10JSONBody defines parameters for CreateBulks10.
type CreateBulks10JSONBody = []HazardIngest

// FindAllHistory26Params defines parameters for FindAllHistory26.
type FindAllHistory26Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// FindAllHistoryAodr25Params defines parameters for FindAllHistoryAodr25.
type FindAllHistoryAodr25Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// CountHistory26Params defines parameters for CountHistory26.
type CountHistory26Params struct {
	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// FindAllTuples41Params defines parameters for FindAllTuples41.
type FindAllTuples41Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// The detect time, in ISO 8601 UTC format, with millisecond precision. (YYYY-MM-DDTHH:MM:SS.sssZ)
	DetectTime time.Time `form:"detectTime" json:"detectTime"`
}

// FindAll46Params defines parameters for FindAll46.
type FindAll46Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// Create53JSONBody defines parameters for Create53.
type Create53JSONBody = MissileTrackIngest

// CountDuplicate11Params defines parameters for CountDuplicate11.
type CountDuplicate11Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulks14JSONBody defines parameters for CreateBulks14.
type CreateBulks14JSONBody = []MissileTrackIngest

// FindAllHistory32Params defines parameters for FindAllHistory32.
type FindAllHistory32Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr31Params defines parameters for FindAllHistoryAodr31.
type FindAllHistoryAodr31Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory32Params defines parameters for CountHistory32.
type CountHistory32Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples54Params defines parameters for FindAllTuples54.
type FindAllTuples54Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll47Params defines parameters for FindAll47.
type FindAll47Params struct {
	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// Create54JSONBody defines parameters for Create54.
type Create54JSONBody = MissionAssignmentIngest

// CountREST43Params defines parameters for CountREST43.
type CountREST43Params struct {
	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// MissionAssignmentCreateBulkJSONBody defines parameters for MissionAssignmentCreateBulk.
type MissionAssignmentCreateBulkJSONBody = []MissionAssignmentIngest

// FindAllHistory33Params defines parameters for FindAllHistory33.
type FindAllHistory33Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr32Params defines parameters for FindAllHistoryAodr32.
type FindAllHistoryAodr32Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory33Params defines parameters for CountHistory33.
type CountHistory33Params struct {
	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples55Params defines parameters for FindAllTuples55.
type FindAllTuples55Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// the timestamp of the mission data, in ISO 8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// Edit29JSONBody defines parameters for Edit29.
type Edit29JSONBody = MissionAssignmentIngest

// FindAll62Params defines parameters for FindAll62.
type FindAll62Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// Create68JSONBody defines parameters for Create68.
type Create68JSONBody = OrbitTrackIngest

// CountDuplicate15Params defines parameters for CountDuplicate15.
type CountDuplicate15Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulks18JSONBody defines parameters for CreateBulks18.
type CreateBulks18JSONBody = []OrbitTrackIngest

// FindAllHistory38Params defines parameters for FindAllHistory38.
type FindAllHistory38Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr37Params defines parameters for FindAllHistoryAodr37.
type FindAllHistoryAodr37Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory38Params defines parameters for CountHistory38.
type CountHistory38Params struct {
	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples66Params defines parameters for FindAllTuples66.
type FindAllTuples66Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Track timestamp in ISO8601 UTC format, with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll65Params defines parameters for FindAll65.
type FindAll65Params struct {
	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// Create71JSONBody defines parameters for Create71.
type Create71JSONBody = POIIngest

// CountREST51Params defines parameters for CountREST51.
type CountREST51Params struct {
	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulks19JSONBody defines parameters for CreateBulks19.
type CreateBulks19JSONBody = []POIIngest

// FindAllHistory39Params defines parameters for FindAllHistory39.
type FindAllHistory39Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr38Params defines parameters for FindAllHistoryAodr38.
type FindAllHistoryAodr38Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory39Params defines parameters for CountHistory39.
type CountHistory39Params struct {
	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples68Params defines parameters for FindAllTuples68.
type FindAllTuples68Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the 'queryhelp' operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Activity/POI timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll85Params defines parameters for FindAll85.
type FindAll85Params struct {
	// Date of the report or filing. (YYYY-MM-DDTHH:MM:SS.sssZ)
	ReportDate time.Time `form:"reportDate" json:"reportDate"`
}

// Create91JSONBody defines parameters for Create91.
type Create91JSONBody = SigActIngest

// CountDuplicate16Params defines parameters for CountDuplicate16.
type CountDuplicate16Params struct {
	// Date of the report or filing. (YYYY-MM-DDTHH:MM:SS.sssZ)
	ReportDate time.Time `form:"reportDate" json:"reportDate"`
}

// FindAllHistory46Params defines parameters for FindAllHistory46.
type FindAllHistory46Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Date of the report or filing. (YYYY-MM-DDTHH:MM:SS.sssZ)
	ReportDate time.Time `form:"reportDate" json:"reportDate"`
}

// CountHistory46Params defines parameters for CountHistory46.
type CountHistory46Params struct {
	// Date of the report or filing. (YYYY-MM-DDTHH:MM:SS.sssZ)
	ReportDate time.Time `form:"reportDate" json:"reportDate"`
}

// FindAllTuples88Params defines parameters for FindAllTuples88.
type FindAllTuples88Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Date of the report or filing. (YYYY-MM-DDTHH:MM:SS.sssZ)
	ReportDate time.Time `form:"reportDate" json:"reportDate"`
}

// Create92JSONBody defines parameters for Create92.
type Create92JSONBody = SiteIngest

// FindAllTuples89Params defines parameters for FindAllTuples89.
type FindAllTuples89Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`
}

// Edit59JSONBody defines parameters for Edit59.
type Edit59JSONBody = SiteIngest

// FindAll87Params defines parameters for FindAll87.
type FindAll87Params struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// Create93JSONBody defines parameters for Create93.
type Create93JSONBody = SiteStatusIngest

// CountREST71Params defines parameters for CountREST71.
type CountREST71Params struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// FindAllHistory47Params defines parameters for FindAllHistory47.
type FindAllHistory47Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// CountHistory47Params defines parameters for CountHistory47.
type CountHistory47Params struct {
	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// FindAllTuples90Params defines parameters for FindAllTuples90.
type FindAllTuples90Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Time the row was created in the database, auto-populated by the system (YYYY-MM-DDTHH:MM:SS.sssZ)
	CreatedAt openapi_types.Date `form:"createdAt" json:"createdAt"`
}

// Edit60JSONBody defines parameters for Edit60.
type Edit60JSONBody = SiteStatusIngest

// FindAll99Params defines parameters for FindAll99.
type FindAll99Params struct {
	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountDuplicate18Params defines parameters for CountDuplicate18.
type CountDuplicate18Params struct {
	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulks26JSONBody defines parameters for CreateBulks26.
type CreateBulks26JSONBody = []TrackIngest

// FindAllHistory54Params defines parameters for FindAllHistory54.
type FindAllHistory54Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr50Params defines parameters for FindAllHistoryAodr50.
type FindAllHistoryAodr50Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory54Params defines parameters for CountHistory54.
type CountHistory54Params struct {
	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples102Params defines parameters for FindAllTuples102.
type FindAllTuples102Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Track timestamp in ISO8601 UTC format (YYYY-MM-DDTHH:MM:SS.sssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll98Params defines parameters for FindAll98.
type FindAll98Params struct {
	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountDuplicate17Params defines parameters for CountDuplicate17.
type CountDuplicate17Params struct {
	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CreateBulks25JSONBody defines parameters for CreateBulks25.
type CreateBulks25JSONBody = []TrackDetailsIngest

// FindAllHistory53Params defines parameters for FindAllHistory53.
type FindAllHistory53Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllHistoryAodr49Params defines parameters for FindAllHistoryAodr49.
type FindAllHistoryAodr49Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// CountHistory53Params defines parameters for CountHistory53.
type CountHistory53Params struct {
	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAllTuples101Params defines parameters for FindAllTuples101.
type FindAllTuples101Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// Track timestamp in ISO8601 UTC format with microsecond precision. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	Ts time.Time `form:"ts" json:"ts"`
}

// FindAll102Params defines parameters for FindAll102.
type FindAll102Params struct {
	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// Create106JSONBody defines parameters for Create106.
type Create106JSONBody = WeatherReportIngest

// Count2Params defines parameters for Count2.
type Count2Params struct {
	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// FindAllHistory56Params defines parameters for FindAllHistory56.
type FindAllHistory56Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// FindAllHistoryAodr51Params defines parameters for FindAllHistoryAodr51.
type FindAllHistoryAodr51Params struct {
	// optional, fields for retrieval. When omitted, ALL fields are assumed. See the queryhelp operation (/udl/&lt;datatype&gt;/queryhelp) for more details on valid query fields that can be selected.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`

	// optional, output format for the file. When omitted, JSON is assumed. Current valid values are: JSON and CSV
	OutputFormat *string `form:"outputFormat,omitempty" json:"outputFormat,omitempty"`

	// optional, field delimiter when the created file is not JSON. When omitted, "," is assumed. It is strongly encouraged that your field delimiter be a character unlikely to occur within the data
	OutputDelimiter *string `form:"outputDelimiter,omitempty" json:"outputDelimiter,omitempty"`

	// optional, notification method for the created file link. When omitted, EMAIL is assumed. Current valid values are: EMAIL, SMS
	Notification *string `form:"notification,omitempty" json:"notification,omitempty"`

	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// CountHistory56Params defines parameters for CountHistory56.
type CountHistory56Params struct {
	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// FindAllTuples105Params defines parameters for FindAllTuples105.
type FindAllTuples105Params struct {
	// Comma-separated list of valid field names for this data type to be returned in the response. Only the fields specified will be returned as well as the classification marking of the data, if applicable. See the queryhelp operation for a complete list of possible fields.
	Columns string `form:"columns" json:"columns"`

	// A Datetime of the weather observation in ISO 8601 UTC datetime format. (YYYY-MM-DDTHH:MM:SS.ssssssZ)
	ObTime time.Time `form:"obTime" json:"obTime"`
}

// FiledropUdlAircraftsortiePostIdJSONRequestBody defines body for FiledropUdlAircraftsortiePostId for application/json ContentType.
type FiledropUdlAircraftsortiePostIdJSONRequestBody = FiledropUdlAircraftsortiePostIdJSONBody

// FiledropUdlAisPostIdJSONRequestBody defines body for FiledropUdlAisPostId for application/json ContentType.
type FiledropUdlAisPostIdJSONRequestBody = FiledropUdlAisPostIdJSONBody

// FiledropUdlAnalyticimageryPostIdJSONRequestBody defines body for FiledropUdlAnalyticimageryPostId for application/json ContentType.
type FiledropUdlAnalyticimageryPostIdJSONRequestBody = FiledropUdlAnalyticimageryPostIdJSONBody

// FiledropUdlAttitudesetPostIdJSONRequestBody defines body for FiledropUdlAttitudesetPostId for application/json ContentType.
type FiledropUdlAttitudesetPostIdJSONRequestBody = FiledropUdlAttitudesetPostIdJSONBody

// FiledropUdlElsetPostIdJSONRequestBody defines body for FiledropUdlElsetPostId for application/json ContentType.
type FiledropUdlElsetPostIdJSONRequestBody = FiledropUdlElsetPostIdJSONBody

// FiledropUdlEphsetPostIdJSONRequestBody defines body for FiledropUdlEphsetPostId for application/json ContentType.
type FiledropUdlEphsetPostIdJSONRequestBody = FiledropUdlEphsetPostIdJSONBody

// FiledropUdlEventevolutionPostIdJSONRequestBody defines body for FiledropUdlEventevolutionPostId for application/json ContentType.
type FiledropUdlEventevolutionPostIdJSONRequestBody = FiledropUdlEventevolutionPostIdJSONBody

// FiledropUdlOrbittrackPostIdJSONRequestBody defines body for FiledropUdlOrbittrackPostId for application/json ContentType.
type FiledropUdlOrbittrackPostIdJSONRequestBody = FiledropUdlOrbittrackPostIdJSONBody

// FiledropUdlPoiPostIdJSONRequestBody defines body for FiledropUdlPoiPostId for application/json ContentType.
type FiledropUdlPoiPostIdJSONRequestBody = FiledropUdlPoiPostIdJSONBody

// FiledropUdlSigactPostIdJSONRequestBody defines body for FiledropUdlSigactPostId for application/json ContentType.
type FiledropUdlSigactPostIdJSONRequestBody = FiledropUdlSigactPostIdJSONBody

// FiledropUdlTracksPostIdJSONRequestBody defines body for FiledropUdlTracksPostId for application/json ContentType.
type FiledropUdlTracksPostIdJSONRequestBody = FiledropUdlTracksPostIdJSONBody

// FiledropWeatherreportPostIdJSONRequestBody defines body for FiledropWeatherreportPostId for application/json ContentType.
type FiledropWeatherreportPostIdJSONRequestBody = FiledropWeatherreportPostIdJSONBody

// Create2JSONRequestBody defines body for Create2 for application/json ContentType.
type Create2JSONRequestBody = Create2JSONBody

// EditJSONRequestBody defines body for Edit for application/json ContentType.
type EditJSONRequestBody = EditJSONBody

// Create3JSONRequestBody defines body for Create3 for application/json ContentType.
type Create3JSONRequestBody = Create3JSONBody

// CreateBulks1JSONRequestBody defines body for CreateBulks1 for application/json ContentType.
type CreateBulks1JSONRequestBody = CreateBulks1JSONBody

// Edit1JSONRequestBody defines body for Edit1 for application/json ContentType.
type Edit1JSONRequestBody = Edit1JSONBody

// Create4JSONRequestBody defines body for Create4 for application/json ContentType.
type Create4JSONRequestBody = Create4JSONBody

// Edit2JSONRequestBody defines body for Edit2 for application/json ContentType.
type Edit2JSONRequestBody = Edit2JSONBody

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = CreateJSONBody

// CreateBulksJSONRequestBody defines body for CreateBulks for application/json ContentType.
type CreateBulksJSONRequestBody = CreateBulksJSONBody

// Create7JSONRequestBody defines body for Create7 for application/json ContentType.
type Create7JSONRequestBody = Create7JSONBody

// PostCotToBluestaqTakServerJSONRequestBody defines body for PostCotToBluestaqTakServer for application/json ContentType.
type PostCotToBluestaqTakServerJSONRequestBody = PostCotToBluestaqTakServerJSONBody

// Create28JSONRequestBody defines body for Create28 for application/json ContentType.
type Create28JSONRequestBody = Create28JSONBody

// CreateBulks8JSONRequestBody defines body for CreateBulks8 for application/json ContentType.
type CreateBulks8JSONRequestBody = CreateBulks8JSONBody

// Create32JSONRequestBody defines body for Create32 for application/json ContentType.
type Create32JSONRequestBody = Create32JSONBody

// Create34JSONRequestBody defines body for Create34 for application/json ContentType.
type Create34JSONRequestBody = Create34JSONBody

// CreateBulk4JSONRequestBody defines body for CreateBulk4 for application/json ContentType.
type CreateBulk4JSONRequestBody = CreateBulk4JSONBody

// Create38JSONRequestBody defines body for Create38 for application/json ContentType.
type Create38JSONRequestBody = Create38JSONBody

// CreateBulks10JSONRequestBody defines body for CreateBulks10 for application/json ContentType.
type CreateBulks10JSONRequestBody = CreateBulks10JSONBody

// Create53JSONRequestBody defines body for Create53 for application/json ContentType.
type Create53JSONRequestBody = Create53JSONBody

// CreateBulks14JSONRequestBody defines body for CreateBulks14 for application/json ContentType.
type CreateBulks14JSONRequestBody = CreateBulks14JSONBody

// Create54JSONRequestBody defines body for Create54 for application/json ContentType.
type Create54JSONRequestBody = Create54JSONBody

// MissionAssignmentCreateBulkJSONRequestBody defines body for MissionAssignmentCreateBulk for application/json ContentType.
type MissionAssignmentCreateBulkJSONRequestBody = MissionAssignmentCreateBulkJSONBody

// Edit29JSONRequestBody defines body for Edit29 for application/json ContentType.
type Edit29JSONRequestBody = Edit29JSONBody

// Create68JSONRequestBody defines body for Create68 for application/json ContentType.
type Create68JSONRequestBody = Create68JSONBody

// CreateBulks18JSONRequestBody defines body for CreateBulks18 for application/json ContentType.
type CreateBulks18JSONRequestBody = CreateBulks18JSONBody

// Create71JSONRequestBody defines body for Create71 for application/json ContentType.
type Create71JSONRequestBody = Create71JSONBody

// CreateBulks19JSONRequestBody defines body for CreateBulks19 for application/json ContentType.
type CreateBulks19JSONRequestBody = CreateBulks19JSONBody

// Create91JSONRequestBody defines body for Create91 for application/json ContentType.
type Create91JSONRequestBody = Create91JSONBody

// Create92JSONRequestBody defines body for Create92 for application/json ContentType.
type Create92JSONRequestBody = Create92JSONBody

// Edit59JSONRequestBody defines body for Edit59 for application/json ContentType.
type Edit59JSONRequestBody = Edit59JSONBody

// Create93JSONRequestBody defines body for Create93 for application/json ContentType.
type Create93JSONRequestBody = Create93JSONBody

// Edit60JSONRequestBody defines body for Edit60 for application/json ContentType.
type Edit60JSONRequestBody = Edit60JSONBody

// CreateBulks26JSONRequestBody defines body for CreateBulks26 for application/json ContentType.
type CreateBulks26JSONRequestBody = CreateBulks26JSONBody

// CreateBulks25JSONRequestBody defines body for CreateBulks25 for application/json ContentType.
type CreateBulks25JSONRequestBody = CreateBulks25JSONBody

// Create106JSONRequestBody defines body for Create106 for application/json ContentType.
type Create106JSONRequestBody = Create106JSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAircraftsortiePostId request with any body
	FiledropUdlAircraftsortiePostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAircraftsortiePostId(ctx context.Context, body FiledropUdlAircraftsortiePostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAisPostId request with any body
	FiledropUdlAisPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAisPostId(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAnalyticimageryPostId request with any body
	FiledropUdlAnalyticimageryPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAnalyticimageryPostId(ctx context.Context, body FiledropUdlAnalyticimageryPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlAttitudesetPostId request with any body
	FiledropUdlAttitudesetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlAttitudesetPostId(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlEventevolutionPostId request with any body
	FiledropUdlEventevolutionPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlEventevolutionPostId(ctx context.Context, body FiledropUdlEventevolutionPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlOrbittrackPostId request with any body
	FiledropUdlOrbittrackPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlOrbittrackPostId(ctx context.Context, body FiledropUdlOrbittrackPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlPoiPostId request with any body
	FiledropUdlPoiPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlPoiPostId(ctx context.Context, body FiledropUdlPoiPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlSigactPostId request with any body
	FiledropUdlSigactPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlSigactPostId(ctx context.Context, body FiledropUdlSigactPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropUdlTracksPostId request with any body
	FiledropUdlTracksPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropUdlTracksPostId(ctx context.Context, body FiledropUdlTracksPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiledropWeatherreportPostId request with any body
	FiledropWeatherreportPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiledropWeatherreportPostId(ctx context.Context, body FiledropWeatherreportPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll2 request
	FindAll2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create2 request with any body
	Create2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create2(ctx context.Context, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST request
	CountREST(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp2 request
	Queryhelp2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples2 request
	FindAllTuples2(ctx context.Context, params *FindAllTuples2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find request
	Find(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit request with any body
	EditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit(ctx context.Context, id string, body EditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream request
	FindAllWithStream(ctx context.Context, params *FindAllWithStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create3 request with any body
	Create3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create3(ctx context.Context, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST1 request
	CountREST1(ctx context.Context, params *CountREST1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks1 request with any body
	CreateBulks1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks1(ctx context.Context, body CreateBulks1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory2 request
	FindAllHistory2(ctx context.Context, params *FindAllHistory2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr2 request
	FindAllHistoryAodr2(ctx context.Context, params *FindAllHistoryAodr2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory2 request
	CountHistory2(ctx context.Context, params *CountHistory2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp3 request
	Queryhelp3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples3 request
	FindAllTuples3(ctx context.Context, params *FindAllTuples3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Remove request
	Remove(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find1 request
	Find1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit1 request with any body
	Edit1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit1(ctx context.Context, id string, body Edit1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll3 request
	FindAll3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create4 request with any body
	Create4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create4(ctx context.Context, body Create4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST2 request
	CountREST2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp4 request
	Queryhelp4(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples4 request
	FindAllTuples4(ctx context.Context, params *FindAllTuples4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Remove1 request
	Remove1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find2 request
	Find2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit2 request with any body
	Edit2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit2(ctx context.Context, id string, body Edit2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll request
	FindAll(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create request with any body
	CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate request
	CountDuplicate(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks request with any body
	CreateBulksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory request
	FindAllHistory(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr request
	FindAllHistoryAodr(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory request
	CountHistory(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp request
	Queryhelp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples request
	FindAllTuples(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll4 request
	FindAll4(ctx context.Context, params *FindAll4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST3 request
	CountREST3(ctx context.Context, params *CountREST3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory3 request
	FindAllHistory3(ctx context.Context, params *FindAllHistory3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr3 request
	FindAllHistoryAodr3(ctx context.Context, params *FindAllHistoryAodr3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory3 request
	CountHistory3(ctx context.Context, params *CountHistory3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp5 request
	Queryhelp5(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples5 request
	FindAllTuples5(ctx context.Context, params *FindAllTuples5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find3 request
	Find3(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream1 request
	FindAllWithStream1(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate2 request
	CountDuplicate2(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory4 request
	FindAllHistory4(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr4 request
	FindAllHistoryAodr4(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory4 request
	CountHistory4(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp7 request
	Queryhelp7(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples7 request
	FindAllTuples7(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream2 request
	FindAllWithStream2(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create7 request with any body
	Create7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create7(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST5 request
	CountREST5(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory5 request
	FindAllHistory5(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr5 request
	FindAllHistoryAodr5(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory5 request
	CountHistory5(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp8 request
	Queryhelp8(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples8 request
	FindAllTuples8(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find6 request
	Find6(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCotToBluestaqTakServer request with any body
	PostCotToBluestaqTakServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCotToBluestaqTakServer(ctx context.Context, body PostCotToBluestaqTakServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Current request
	Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp21 request
	Queryhelp21(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create28 request with any body
	Create28WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create28(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST24 request
	CountREST24(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Current1 request
	Current1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentTuple request
	CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory16 request
	FindAllHistory16(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr16 request
	FindAllHistoryAodr16(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory16 request
	CountHistory16(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp31 request
	Queryhelp31(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples29 request
	FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find25 request
	Find25(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream9 request
	FindAllWithStream9(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate6 request
	CountDuplicate6(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory17 request
	FindAllHistory17(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr17 request
	FindAllHistoryAodr17(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory17 request
	CountHistory17(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp34 request
	Queryhelp34(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples32 request
	FindAllTuples32(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllWithStream10 request
	FindAllWithStream10(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create32 request with any body
	Create32WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create32(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST27 request
	CountREST27(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile1 request
	GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory18 request
	FindAllHistory18(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr18 request
	FindAllHistoryAodr18(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory18 request
	CountHistory18(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp35 request
	Queryhelp35(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples33 request
	FindAllTuples33(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find29 request
	Find29(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll27 request
	FindAll27(ctx context.Context, params *FindAll27Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create34 request with any body
	Create34WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create34(ctx context.Context, body Create34JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Count request
	Count(ctx context.Context, params *CountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulk4 request with any body
	CreateBulk4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulk4(ctx context.Context, body CreateBulk4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory20 request
	FindAllHistory20(ctx context.Context, params *FindAllHistory20Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr19 request
	FindAllHistoryAodr19(ctx context.Context, params *FindAllHistoryAodr19Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory20 request
	CountHistory20(ctx context.Context, params *CountHistory20Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp37 request
	Queryhelp37(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples35 request
	FindAllTuples35(ctx context.Context, params *FindAllTuples35Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find30 request
	Find30(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll33 request
	FindAll33(ctx context.Context, params *FindAll33Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create38 request with any body
	Create38WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create38(ctx context.Context, body Create38JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST32 request
	CountREST32(ctx context.Context, params *CountREST32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks10 request with any body
	CreateBulks10WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks10(ctx context.Context, body CreateBulks10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory26 request
	FindAllHistory26(ctx context.Context, params *FindAllHistory26Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr25 request
	FindAllHistoryAodr25(ctx context.Context, params *FindAllHistoryAodr25Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory26 request
	CountHistory26(ctx context.Context, params *CountHistory26Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp43 request
	Queryhelp43(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples41 request
	FindAllTuples41(ctx context.Context, params *FindAllTuples41Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find35 request
	Find35(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll46 request
	FindAll46(ctx context.Context, params *FindAll46Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create53 request with any body
	Create53WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create53(ctx context.Context, body Create53JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate11 request
	CountDuplicate11(ctx context.Context, params *CountDuplicate11Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks14 request with any body
	CreateBulks14WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks14(ctx context.Context, body CreateBulks14JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory32 request
	FindAllHistory32(ctx context.Context, params *FindAllHistory32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr31 request
	FindAllHistoryAodr31(ctx context.Context, params *FindAllHistoryAodr31Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory32 request
	CountHistory32(ctx context.Context, params *CountHistory32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp56 request
	Queryhelp56(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples54 request
	FindAllTuples54(ctx context.Context, params *FindAllTuples54Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll47 request
	FindAll47(ctx context.Context, params *FindAll47Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create54 request with any body
	Create54WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create54(ctx context.Context, body Create54JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST43 request
	CountREST43(ctx context.Context, params *CountREST43Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MissionAssignmentCreateBulk request with any body
	MissionAssignmentCreateBulkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MissionAssignmentCreateBulk(ctx context.Context, body MissionAssignmentCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory33 request
	FindAllHistory33(ctx context.Context, params *FindAllHistory33Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr32 request
	FindAllHistoryAodr32(ctx context.Context, params *FindAllHistoryAodr32Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory33 request
	CountHistory33(ctx context.Context, params *CountHistory33Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp57 request
	Queryhelp57(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples55 request
	FindAllTuples55(ctx context.Context, params *FindAllTuples55Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Remove27 request
	Remove27(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find48 request
	Find48(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit29 request with any body
	Edit29WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit29(ctx context.Context, id string, body Edit29JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll62 request
	FindAll62(ctx context.Context, params *FindAll62Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create68 request with any body
	Create68WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create68(ctx context.Context, body Create68JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate15 request
	CountDuplicate15(ctx context.Context, params *CountDuplicate15Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks18 request with any body
	CreateBulks18WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks18(ctx context.Context, body CreateBulks18JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory38 request
	FindAllHistory38(ctx context.Context, params *FindAllHistory38Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr37 request
	FindAllHistoryAodr37(ctx context.Context, params *FindAllHistoryAodr37Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory38 request
	CountHistory38(ctx context.Context, params *CountHistory38Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp68 request
	Queryhelp68(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples66 request
	FindAllTuples66(ctx context.Context, params *FindAllTuples66Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll65 request
	FindAll65(ctx context.Context, params *FindAll65Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create71 request with any body
	Create71WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create71(ctx context.Context, body Create71JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST51 request
	CountREST51(ctx context.Context, params *CountREST51Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks19 request with any body
	CreateBulks19WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks19(ctx context.Context, body CreateBulks19JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory39 request
	FindAllHistory39(ctx context.Context, params *FindAllHistory39Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr38 request
	FindAllHistoryAodr38(ctx context.Context, params *FindAllHistoryAodr38Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory39 request
	CountHistory39(ctx context.Context, params *CountHistory39Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp70 request
	Queryhelp70(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples68 request
	FindAllTuples68(ctx context.Context, params *FindAllTuples68Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find63 request
	Find63(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll85 request
	FindAll85(ctx context.Context, params *FindAll85Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create91 request with any body
	Create91WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create91(ctx context.Context, body Create91JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate16 request
	CountDuplicate16(ctx context.Context, params *CountDuplicate16Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory46 request
	FindAllHistory46(ctx context.Context, params *FindAllHistory46Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory46 request
	CountHistory46(ctx context.Context, params *CountHistory46Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp92 request
	Queryhelp92(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples88 request
	FindAllTuples88(ctx context.Context, params *FindAllTuples88Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll86 request
	FindAll86(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create92 request with any body
	Create92WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create92(ctx context.Context, body Create92JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST70 request
	CountREST70(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp93 request
	Queryhelp93(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples89 request
	FindAllTuples89(ctx context.Context, params *FindAllTuples89Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find84 request
	Find84(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit59 request with any body
	Edit59WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit59(ctx context.Context, id string, body Edit59JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll87 request
	FindAll87(ctx context.Context, params *FindAll87Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create93 request with any body
	Create93WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create93(ctx context.Context, body Create93JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountREST71 request
	CountREST71(ctx context.Context, params *CountREST71Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory47 request
	FindAllHistory47(ctx context.Context, params *FindAllHistory47Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory47 request
	CountHistory47(ctx context.Context, params *CountHistory47Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp94 request
	Queryhelp94(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples90 request
	FindAllTuples90(ctx context.Context, params *FindAllTuples90Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Remove56 request
	Remove56(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find85 request
	Find85(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Edit60 request with any body
	Edit60WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Edit60(ctx context.Context, id string, body Edit60JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll99 request
	FindAll99(ctx context.Context, params *FindAll99Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate18 request
	CountDuplicate18(ctx context.Context, params *CountDuplicate18Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks26 request with any body
	CreateBulks26WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks26(ctx context.Context, body CreateBulks26JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory54 request
	FindAllHistory54(ctx context.Context, params *FindAllHistory54Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr50 request
	FindAllHistoryAodr50(ctx context.Context, params *FindAllHistoryAodr50Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory54 request
	CountHistory54(ctx context.Context, params *CountHistory54Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp106 request
	Queryhelp106(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples102 request
	FindAllTuples102(ctx context.Context, params *FindAllTuples102Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll98 request
	FindAll98(ctx context.Context, params *FindAll98Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountDuplicate17 request
	CountDuplicate17(ctx context.Context, params *CountDuplicate17Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBulks25 request with any body
	CreateBulks25WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBulks25(ctx context.Context, body CreateBulks25JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory53 request
	FindAllHistory53(ctx context.Context, params *FindAllHistory53Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr49 request
	FindAllHistoryAodr49(ctx context.Context, params *FindAllHistoryAodr49Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory53 request
	CountHistory53(ctx context.Context, params *CountHistory53Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp105 request
	Queryhelp105(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples101 request
	FindAllTuples101(ctx context.Context, params *FindAllTuples101Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAll102 request
	FindAll102(ctx context.Context, params *FindAll102Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create106 request with any body
	Create106WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Create106(ctx context.Context, body Create106JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Count2 request
	Count2(ctx context.Context, params *Count2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistory56 request
	FindAllHistory56(ctx context.Context, params *FindAllHistory56Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllHistoryAodr51 request
	FindAllHistoryAodr51(ctx context.Context, params *FindAllHistoryAodr51Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountHistory56 request
	CountHistory56(ctx context.Context, params *CountHistory56Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Queryhelp109 request
	Queryhelp109(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAllTuples105 request
	FindAllTuples105(ctx context.Context, params *FindAllTuples105Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Find99 request
	Find99(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) FiledropEphemPostIdWithBody(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropEphemPostIdRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAircraftsortiePostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAircraftsortiePostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAircraftsortiePostId(ctx context.Context, body FiledropUdlAircraftsortiePostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAircraftsortiePostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAisPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAisPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAisPostId(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAisPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAnalyticimageryPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAnalyticimageryPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAnalyticimageryPostId(ctx context.Context, body FiledropUdlAnalyticimageryPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAnalyticimageryPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAttitudesetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAttitudesetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlAttitudesetPostId(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlAttitudesetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlElsetPostId(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlElsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEphsetPostId(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEphsetPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEventevolutionPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEventevolutionPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlEventevolutionPostId(ctx context.Context, body FiledropUdlEventevolutionPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlEventevolutionPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlOrbittrackPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlOrbittrackPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlOrbittrackPostId(ctx context.Context, body FiledropUdlOrbittrackPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlOrbittrackPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlPoiPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlPoiPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlPoiPostId(ctx context.Context, body FiledropUdlPoiPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlPoiPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlSigactPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlSigactPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlSigactPostId(ctx context.Context, body FiledropUdlSigactPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlSigactPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlTracksPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlTracksPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropUdlTracksPostId(ctx context.Context, body FiledropUdlTracksPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropUdlTracksPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropWeatherreportPostIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropWeatherreportPostIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiledropWeatherreportPostId(ctx context.Context, body FiledropWeatherreportPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiledropWeatherreportPostIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create2(ctx context.Context, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountRESTRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples2(ctx context.Context, params *FindAllTuples2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit(ctx context.Context, id string, body EditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream(ctx context.Context, params *FindAllWithStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStreamRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create3WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate3RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create3(ctx context.Context, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate3Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST1(ctx context.Context, params *CountREST1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks1(ctx context.Context, body CreateBulks1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory2(ctx context.Context, params *FindAllHistory2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr2(ctx context.Context, params *FindAllHistoryAodr2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory2(ctx context.Context, params *CountHistory2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp3Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples3(ctx context.Context, params *FindAllTuples3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Remove(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit1WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit1RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit1(ctx context.Context, id string, body Edit1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit1Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll3Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate4RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create4(ctx context.Context, body Create4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate4Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp4(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp4Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples4(ctx context.Context, params *FindAllTuples4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Remove1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemove1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit2(ctx context.Context, id string, body Edit2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodrRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelpRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuplesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll4(ctx context.Context, params *FindAll4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST3(ctx context.Context, params *CountREST3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory3(ctx context.Context, params *FindAllHistory3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr3(ctx context.Context, params *FindAllHistoryAodr3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory3(ctx context.Context, params *CountHistory3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp5(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp5Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples5(ctx context.Context, params *FindAllTuples5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find3(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind3Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream1(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate2(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory4(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr4(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory4(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp7(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp7Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples7(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples7Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream2(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create7WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate7RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create7(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate7Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST5(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory5(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr5(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory5(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp8(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp8Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples8(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find6(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind6Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCotToBluestaqTakServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCotToBluestaqTakServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCotToBluestaqTakServer(ctx context.Context, body PostCotToBluestaqTakServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCotToBluestaqTakServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Current(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp21(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp21Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream8(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create28WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate28RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create28(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate28Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST24(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST24Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8WithBody(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8RequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks8(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks8Request(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulkFromTLEWithBody(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulkFromTLERequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Current1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrent1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentTuple(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentTupleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory16(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr16(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory16(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp31(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp31Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples29(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples29Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find25(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind25Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream9(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream9Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate6(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate6Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory17(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr17(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory17(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp34(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp34Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples32(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllWithStream10(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllWithStream10Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create32WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate32RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create32(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate32Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST27(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST27Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile1(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFile1Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory18(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr18(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory18(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp35(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp35Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples33(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples33Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find29(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind29Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll27(ctx context.Context, params *FindAll27Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll27Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create34WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate34RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create34(ctx context.Context, body Create34JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate34Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Count(ctx context.Context, params *CountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulk4WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulk4RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulk4(ctx context.Context, body CreateBulk4JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulk4Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory20(ctx context.Context, params *FindAllHistory20Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory20Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr19(ctx context.Context, params *FindAllHistoryAodr19Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr19Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory20(ctx context.Context, params *CountHistory20Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory20Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp37(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp37Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples35(ctx context.Context, params *FindAllTuples35Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples35Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find30(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind30Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll33(ctx context.Context, params *FindAll33Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll33Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create38WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate38RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create38(ctx context.Context, body Create38JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate38Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST32(ctx context.Context, params *CountREST32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks10WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks10RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks10(ctx context.Context, body CreateBulks10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks10Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory26(ctx context.Context, params *FindAllHistory26Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory26Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr25(ctx context.Context, params *FindAllHistoryAodr25Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr25Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory26(ctx context.Context, params *CountHistory26Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory26Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp43(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp43Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples41(ctx context.Context, params *FindAllTuples41Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples41Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find35(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind35Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll46(ctx context.Context, params *FindAll46Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll46Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create53WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate53RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create53(ctx context.Context, body Create53JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate53Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate11(ctx context.Context, params *CountDuplicate11Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate11Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks14WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks14RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks14(ctx context.Context, body CreateBulks14JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks14Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory32(ctx context.Context, params *FindAllHistory32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr31(ctx context.Context, params *FindAllHistoryAodr31Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr31Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory32(ctx context.Context, params *CountHistory32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp56(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp56Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples54(ctx context.Context, params *FindAllTuples54Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples54Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll47(ctx context.Context, params *FindAll47Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll47Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create54WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate54RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create54(ctx context.Context, body Create54JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate54Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST43(ctx context.Context, params *CountREST43Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST43Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MissionAssignmentCreateBulkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMissionAssignmentCreateBulkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MissionAssignmentCreateBulk(ctx context.Context, body MissionAssignmentCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMissionAssignmentCreateBulkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory33(ctx context.Context, params *FindAllHistory33Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory33Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr32(ctx context.Context, params *FindAllHistoryAodr32Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr32Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory33(ctx context.Context, params *CountHistory33Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory33Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp57(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp57Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples55(ctx context.Context, params *FindAllTuples55Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples55Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Remove27(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemove27Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find48(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind48Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit29WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit29RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit29(ctx context.Context, id string, body Edit29JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit29Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll62(ctx context.Context, params *FindAll62Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll62Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create68WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate68RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create68(ctx context.Context, body Create68JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate68Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate15(ctx context.Context, params *CountDuplicate15Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate15Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks18WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks18RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks18(ctx context.Context, body CreateBulks18JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks18Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory38(ctx context.Context, params *FindAllHistory38Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory38Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr37(ctx context.Context, params *FindAllHistoryAodr37Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr37Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory38(ctx context.Context, params *CountHistory38Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory38Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp68(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp68Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples66(ctx context.Context, params *FindAllTuples66Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples66Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll65(ctx context.Context, params *FindAll65Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll65Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create71WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate71RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create71(ctx context.Context, body Create71JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate71Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST51(ctx context.Context, params *CountREST51Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST51Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks19WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks19RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks19(ctx context.Context, body CreateBulks19JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks19Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory39(ctx context.Context, params *FindAllHistory39Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory39Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr38(ctx context.Context, params *FindAllHistoryAodr38Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr38Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory39(ctx context.Context, params *CountHistory39Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory39Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp70(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp70Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples68(ctx context.Context, params *FindAllTuples68Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples68Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find63(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind63Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll85(ctx context.Context, params *FindAll85Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll85Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create91WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate91RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create91(ctx context.Context, body Create91JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate91Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate16(ctx context.Context, params *CountDuplicate16Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate16Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory46(ctx context.Context, params *FindAllHistory46Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory46Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory46(ctx context.Context, params *CountHistory46Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory46Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp92(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp92Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples88(ctx context.Context, params *FindAllTuples88Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples88Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll86(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll86Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create92WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate92RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create92(ctx context.Context, body Create92JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate92Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST70(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST70Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp93(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp93Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples89(ctx context.Context, params *FindAllTuples89Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples89Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find84(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind84Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit59WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit59RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit59(ctx context.Context, id string, body Edit59JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit59Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll87(ctx context.Context, params *FindAll87Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll87Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create93WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate93RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create93(ctx context.Context, body Create93JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate93Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountREST71(ctx context.Context, params *CountREST71Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountREST71Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory47(ctx context.Context, params *FindAllHistory47Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory47Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory47(ctx context.Context, params *CountHistory47Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory47Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp94(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp94Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples90(ctx context.Context, params *FindAllTuples90Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples90Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Remove56(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemove56Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find85(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind85Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit60WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit60RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Edit60(ctx context.Context, id string, body Edit60JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEdit60Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll99(ctx context.Context, params *FindAll99Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll99Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate18(ctx context.Context, params *CountDuplicate18Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate18Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks26WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks26RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks26(ctx context.Context, body CreateBulks26JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks26Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory54(ctx context.Context, params *FindAllHistory54Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory54Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr50(ctx context.Context, params *FindAllHistoryAodr50Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr50Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory54(ctx context.Context, params *CountHistory54Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory54Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp106(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp106Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples102(ctx context.Context, params *FindAllTuples102Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples102Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll98(ctx context.Context, params *FindAll98Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll98Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountDuplicate17(ctx context.Context, params *CountDuplicate17Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountDuplicate17Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks25WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks25RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBulks25(ctx context.Context, body CreateBulks25JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBulks25Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory53(ctx context.Context, params *FindAllHistory53Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory53Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr49(ctx context.Context, params *FindAllHistoryAodr49Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr49Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory53(ctx context.Context, params *CountHistory53Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory53Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp105(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp105Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples101(ctx context.Context, params *FindAllTuples101Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples101Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAll102(ctx context.Context, params *FindAll102Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAll102Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create106WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate106RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Create106(ctx context.Context, body Create106JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreate106Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Count2(ctx context.Context, params *Count2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCount2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistory56(ctx context.Context, params *FindAllHistory56Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistory56Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllHistoryAodr51(ctx context.Context, params *FindAllHistoryAodr51Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllHistoryAodr51Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountHistory56(ctx context.Context, params *CountHistory56Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountHistory56Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Queryhelp109(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryhelp109Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAllTuples105(ctx context.Context, params *FindAllTuples105Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAllTuples105Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Find99(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFind99Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewFiledropEphemPostIdRequestWithBody generates requests for FiledropEphemPostId with any type of body
func NewFiledropEphemPostIdRequestWithBody(server string, params *FiledropEphemPostIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/ephem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idOnOrbit", runtime.ParamLocationQuery, params.IdOnOrbit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "classification", runtime.ParamLocationQuery, params.Classification); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasMnvr", runtime.ParamLocationQuery, params.HasMnvr); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, params.Category); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ephemFormatType", runtime.ParamLocationQuery, params.EphemFormatType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAircraftsortiePostIdRequest calls the generic FiledropUdlAircraftsortiePostId builder with application/json body
func NewFiledropUdlAircraftsortiePostIdRequest(server string, body FiledropUdlAircraftsortiePostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAircraftsortiePostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAircraftsortiePostIdRequestWithBody generates requests for FiledropUdlAircraftsortiePostId with any type of body
func NewFiledropUdlAircraftsortiePostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-aircraftsortie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAisPostIdRequest calls the generic FiledropUdlAisPostId builder with application/json body
func NewFiledropUdlAisPostIdRequest(server string, body FiledropUdlAisPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAisPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAisPostIdRequestWithBody generates requests for FiledropUdlAisPostId with any type of body
func NewFiledropUdlAisPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAnalyticimageryPostIdRequest calls the generic FiledropUdlAnalyticimageryPostId builder with application/json body
func NewFiledropUdlAnalyticimageryPostIdRequest(server string, body FiledropUdlAnalyticimageryPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAnalyticimageryPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAnalyticimageryPostIdRequestWithBody generates requests for FiledropUdlAnalyticimageryPostId with any type of body
func NewFiledropUdlAnalyticimageryPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-analyticimagery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlAttitudesetPostIdRequest calls the generic FiledropUdlAttitudesetPostId builder with application/json body
func NewFiledropUdlAttitudesetPostIdRequest(server string, body FiledropUdlAttitudesetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlAttitudesetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlAttitudesetPostIdRequestWithBody generates requests for FiledropUdlAttitudesetPostId with any type of body
func NewFiledropUdlAttitudesetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlElsetPostIdRequest calls the generic FiledropUdlElsetPostId builder with application/json body
func NewFiledropUdlElsetPostIdRequest(server string, body FiledropUdlElsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlElsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlElsetPostIdRequestWithBody generates requests for FiledropUdlElsetPostId with any type of body
func NewFiledropUdlElsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlEphsetPostIdRequest calls the generic FiledropUdlEphsetPostId builder with application/json body
func NewFiledropUdlEphsetPostIdRequest(server string, body FiledropUdlEphsetPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlEphsetPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlEphsetPostIdRequestWithBody generates requests for FiledropUdlEphsetPostId with any type of body
func NewFiledropUdlEphsetPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-ephset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlEventevolutionPostIdRequest calls the generic FiledropUdlEventevolutionPostId builder with application/json body
func NewFiledropUdlEventevolutionPostIdRequest(server string, body FiledropUdlEventevolutionPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlEventevolutionPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlEventevolutionPostIdRequestWithBody generates requests for FiledropUdlEventevolutionPostId with any type of body
func NewFiledropUdlEventevolutionPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-eventevolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlOrbittrackPostIdRequest calls the generic FiledropUdlOrbittrackPostId builder with application/json body
func NewFiledropUdlOrbittrackPostIdRequest(server string, body FiledropUdlOrbittrackPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlOrbittrackPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlOrbittrackPostIdRequestWithBody generates requests for FiledropUdlOrbittrackPostId with any type of body
func NewFiledropUdlOrbittrackPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-orbittrack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlPoiPostIdRequest calls the generic FiledropUdlPoiPostId builder with application/json body
func NewFiledropUdlPoiPostIdRequest(server string, body FiledropUdlPoiPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlPoiPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlPoiPostIdRequestWithBody generates requests for FiledropUdlPoiPostId with any type of body
func NewFiledropUdlPoiPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-poi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlSigactPostIdRequest calls the generic FiledropUdlSigactPostId builder with application/json body
func NewFiledropUdlSigactPostIdRequest(server string, body FiledropUdlSigactPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlSigactPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlSigactPostIdRequestWithBody generates requests for FiledropUdlSigactPostId with any type of body
func NewFiledropUdlSigactPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-sigact")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropUdlTracksPostIdRequest calls the generic FiledropUdlTracksPostId builder with application/json body
func NewFiledropUdlTracksPostIdRequest(server string, body FiledropUdlTracksPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropUdlTracksPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropUdlTracksPostIdRequestWithBody generates requests for FiledropUdlTracksPostId with any type of body
func NewFiledropUdlTracksPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFiledropWeatherreportPostIdRequest calls the generic FiledropWeatherreportPostId builder with application/json body
func NewFiledropWeatherreportPostIdRequest(server string, body FiledropWeatherreportPostIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiledropWeatherreportPostIdRequestWithBody(server, "application/json", bodyReader)
}

// NewFiledropWeatherreportPostIdRequestWithBody generates requests for FiledropWeatherreportPostId with any type of body
func NewFiledropWeatherreportPostIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filedrop/udl-weatherreport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAll2Request generates requests for FindAll2
func NewFindAll2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate2Request calls the generic Create2 builder with application/json body
func NewCreate2Request(server string, body Create2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate2RequestWithBody generates requests for Create2 with any type of body
func NewCreate2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountRESTRequest generates requests for CountREST
func NewCountRESTRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp2Request generates requests for Queryhelp2
func NewQueryhelp2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples2Request generates requests for FindAllTuples2
func NewFindAllTuples2Request(server string, params *FindAllTuples2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindRequest generates requests for Find
func NewFindRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditRequest calls the generic Edit builder with application/json body
func NewEditRequest(server string, id string, body EditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEditRequestWithBody generates requests for Edit with any type of body
func NewEditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraft/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllWithStreamRequest generates requests for FindAllWithStream
func NewFindAllWithStreamRequest(server string, params *FindAllWithStreamParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate3Request calls the generic Create3 builder with application/json body
func NewCreate3Request(server string, body Create3JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate3RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate3RequestWithBody generates requests for Create3 with any type of body
func NewCreate3RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST1Request generates requests for CountREST1
func NewCountREST1Request(server string, params *CountREST1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks1Request calls the generic CreateBulks1 builder with application/json body
func NewCreateBulks1Request(server string, body CreateBulks1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks1RequestWithBody generates requests for CreateBulks1 with any type of body
func NewCreateBulks1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory2Request generates requests for FindAllHistory2
func NewFindAllHistory2Request(server string, params *FindAllHistory2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr2Request generates requests for FindAllHistoryAodr2
func NewFindAllHistoryAodr2Request(server string, params *FindAllHistoryAodr2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory2Request generates requests for CountHistory2
func NewCountHistory2Request(server string, params *CountHistory2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp3Request generates requests for Queryhelp3
func NewQueryhelp3Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples3Request generates requests for FindAllTuples3
func NewFindAllTuples3Request(server string, params *FindAllTuples3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRequest generates requests for Remove
func NewRemoveRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind1Request generates requests for Find1
func NewFind1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEdit1Request calls the generic Edit1 builder with application/json body
func NewEdit1Request(server string, id string, body Edit1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEdit1RequestWithBody(server, id, "application/json", bodyReader)
}

// NewEdit1RequestWithBody generates requests for Edit1 with any type of body
func NewEdit1RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftsortie/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAll3Request generates requests for FindAll3
func NewFindAll3Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate4Request calls the generic Create4 builder with application/json body
func NewCreate4Request(server string, body Create4JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate4RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate4RequestWithBody generates requests for Create4 with any type of body
func NewCreate4RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST2Request generates requests for CountREST2
func NewCountREST2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp4Request generates requests for Queryhelp4
func NewQueryhelp4Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples4Request generates requests for FindAllTuples4
func NewFindAllTuples4Request(server string, params *FindAllTuples4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemove1Request generates requests for Remove1
func NewRemove1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind2Request generates requests for Find2
func NewFind2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEdit2Request calls the generic Edit2 builder with application/json body
func NewEdit2Request(server string, id string, body Edit2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEdit2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewEdit2RequestWithBody generates requests for Edit2 with any type of body
func NewEdit2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/aircraftstatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllRequest generates requests for FindAll
func NewFindAllRequest(server string, params *FindAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(server string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDuplicateRequest generates requests for CountDuplicate
func NewCountDuplicateRequest(server string, params *CountDuplicateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulksRequest calls the generic CreateBulks builder with application/json body
func NewCreateBulksRequest(server string, body CreateBulksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulksRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulksRequestWithBody generates requests for CreateBulks with any type of body
func NewCreateBulksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistoryRequest generates requests for FindAllHistory
func NewFindAllHistoryRequest(server string, params *FindAllHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodrRequest generates requests for FindAllHistoryAodr
func NewFindAllHistoryAodrRequest(server string, params *FindAllHistoryAodrParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistoryRequest generates requests for CountHistory
func NewCountHistoryRequest(server string, params *CountHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelpRequest generates requests for Queryhelp
func NewQueryhelpRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuplesRequest generates requests for FindAllTuples
func NewFindAllTuplesRequest(server string, params *FindAllTuplesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ais/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll4Request generates requests for FindAll4
func NewFindAll4Request(server string, params *FindAll4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountREST3Request generates requests for CountREST3
func NewCountREST3Request(server string, params *CountREST3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/getFile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory3Request generates requests for FindAllHistory3
func NewFindAllHistory3Request(server string, params *FindAllHistory3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr3Request generates requests for FindAllHistoryAodr3
func NewFindAllHistoryAodr3Request(server string, params *FindAllHistoryAodr3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory3Request generates requests for CountHistory3
func NewCountHistory3Request(server string, params *CountHistory3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp5Request generates requests for Queryhelp5
func NewQueryhelp5Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples5Request generates requests for FindAllTuples5
func NewFindAllTuples5Request(server string, params *FindAllTuples5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msgTime", runtime.ParamLocationQuery, params.MsgTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind3Request generates requests for Find3
func NewFind3Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/analyticimagery/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream1Request generates requests for FindAllWithStream1
func NewFindAllWithStream1Request(server string, params *FindAllWithStream1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate2Request generates requests for CountDuplicate2
func NewCountDuplicate2Request(server string, params *CountDuplicate2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory4Request generates requests for FindAllHistory4
func NewFindAllHistory4Request(server string, params *FindAllHistory4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr4Request generates requests for FindAllHistoryAodr4
func NewFindAllHistoryAodr4Request(server string, params *FindAllHistoryAodr4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory4Request generates requests for CountHistory4
func NewCountHistory4Request(server string, params *CountHistory4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp7Request generates requests for Queryhelp7
func NewQueryhelp7Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples7Request generates requests for FindAllTuples7
func NewFindAllTuples7Request(server string, params *FindAllTuples7Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudedata/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asId", runtime.ParamLocationQuery, params.AsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream2Request generates requests for FindAllWithStream2
func NewFindAllWithStream2Request(server string, params *FindAllWithStream2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate7Request calls the generic Create7 builder with application/json body
func NewCreate7Request(server string, body Create7JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate7RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate7RequestWithBody generates requests for Create7 with any type of body
func NewCreate7RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST5Request generates requests for CountREST5
func NewCountREST5Request(server string, params *CountREST5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory5Request generates requests for FindAllHistory5
func NewFindAllHistory5Request(server string, params *FindAllHistory5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr5Request generates requests for FindAllHistoryAodr5
func NewFindAllHistoryAodr5Request(server string, params *FindAllHistoryAodr5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory5Request generates requests for CountHistory5
func NewCountHistory5Request(server string, params *CountHistory5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp8Request generates requests for Queryhelp8
func NewQueryhelp8Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples8Request generates requests for FindAllTuples8
func NewFindAllTuples8Request(server string, params *FindAllTuples8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind6Request generates requests for Find6
func NewFind6Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/attitudeset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCotToBluestaqTakServerRequest calls the generic PostCotToBluestaqTakServer builder with application/json body
func NewPostCotToBluestaqTakServerRequest(server string, body PostCotToBluestaqTakServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCotToBluestaqTakServerRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCotToBluestaqTakServerRequestWithBody generates requests for PostCotToBluestaqTakServer with any type of body
func NewPostCotToBluestaqTakServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/cot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrentRequest generates requests for Current
func NewCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/currentelset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp21Request generates requests for Queryhelp21
func NewQueryhelp21Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/currentelset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream8Request generates requests for FindAllWithStream8
func NewFindAllWithStream8Request(server string, params *FindAllWithStream8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate28Request calls the generic Create28 builder with application/json body
func NewCreate28Request(server string, body Create28JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate28RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate28RequestWithBody generates requests for Create28 with any type of body
func NewCreate28RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST24Request generates requests for CountREST24
func NewCountREST24Request(server string, params *CountREST24Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks8Request calls the generic CreateBulks8 builder with application/json body
func NewCreateBulks8Request(server string, params *CreateBulks8Params, body CreateBulks8JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks8RequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBulks8RequestWithBody generates requests for CreateBulks8 with any type of body
func NewCreateBulks8RequestWithBody(server string, params *CreateBulks8Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DupeCheck != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dupeCheck", runtime.ParamLocationQuery, *params.DupeCheck); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBulkFromTLERequestWithBody generates requests for CreateBulkFromTLE with any type of body
func NewCreateBulkFromTLERequestWithBody(server string, params *CreateBulkFromTLEParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/createBulkFromTLE")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataMode", runtime.ParamLocationQuery, params.DataMode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Control != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "control", runtime.ParamLocationQuery, *params.Control); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "makeCurrent", runtime.ParamLocationQuery, params.MakeCurrent); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Origin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, *params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AutoCreateSats != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoCreateSats", runtime.ParamLocationQuery, *params.AutoCreateSats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrent1Request generates requests for Current1
func NewCurrent1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentTupleRequest generates requests for CurrentTuple
func NewCurrentTupleRequest(server string, params *CurrentTupleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/current/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory16Request generates requests for FindAllHistory16
func NewFindAllHistory16Request(server string, params *FindAllHistory16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr16Request generates requests for FindAllHistoryAodr16
func NewFindAllHistoryAodr16Request(server string, params *FindAllHistoryAodr16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory16Request generates requests for CountHistory16
func NewCountHistory16Request(server string, params *CountHistory16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, params.Epoch); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp31Request generates requests for Queryhelp31
func NewQueryhelp31Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples29Request generates requests for FindAllTuples29
func NewFindAllTuples29Request(server string, params *FindAllTuples29Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Epoch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "epoch", runtime.ParamLocationQuery, *params.Epoch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IdElset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idElset", runtime.ParamLocationQuery, *params.IdElset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind25Request generates requests for Find25
func NewFind25Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/elset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream9Request generates requests for FindAllWithStream9
func NewFindAllWithStream9Request(server string, params *FindAllWithStream9Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate6Request generates requests for CountDuplicate6
func NewCountDuplicate6Request(server string, params *CountDuplicate6Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory17Request generates requests for FindAllHistory17
func NewFindAllHistory17Request(server string, params *FindAllHistory17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr17Request generates requests for FindAllHistoryAodr17
func NewFindAllHistoryAodr17Request(server string, params *FindAllHistoryAodr17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory17Request generates requests for CountHistory17
func NewCountHistory17Request(server string, params *CountHistory17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp34Request generates requests for Queryhelp34
func NewQueryhelp34Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples32Request generates requests for FindAllTuples32
func NewFindAllTuples32Request(server string, params *FindAllTuples32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemeris/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "esId", runtime.ParamLocationQuery, params.EsId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllWithStream10Request generates requests for FindAllWithStream10
func NewFindAllWithStream10Request(server string, params *FindAllWithStream10Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate32Request calls the generic Create32 builder with application/json body
func NewCreate32Request(server string, body Create32JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate32RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate32RequestWithBody generates requests for Create32 with any type of body
func NewCreate32RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST27Request generates requests for CountREST27
func NewCountREST27Request(server string, params *CountREST27Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFile1Request generates requests for GetFile1
func NewGetFile1Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/getFile/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory18Request generates requests for FindAllHistory18
func NewFindAllHistory18Request(server string, params *FindAllHistory18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr18Request generates requests for FindAllHistoryAodr18
func NewFindAllHistoryAodr18Request(server string, params *FindAllHistoryAodr18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory18Request generates requests for CountHistory18
func NewCountHistory18Request(server string, params *CountHistory18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp35Request generates requests for Queryhelp35
func NewQueryhelp35Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples33Request generates requests for FindAllTuples33
func NewFindAllTuples33Request(server string, params *FindAllTuples33Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.PointEndTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointEndTime", runtime.ParamLocationQuery, *params.PointEndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PointStartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pointStartTime", runtime.ParamLocationQuery, *params.PointStartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind29Request generates requests for Find29
func NewFind29Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/ephemerisset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll27Request generates requests for FindAll27
func NewFindAll27Request(server string, params *FindAll27Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate34Request calls the generic Create34 builder with application/json body
func NewCreate34Request(server string, body Create34JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate34RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate34RequestWithBody generates requests for Create34 with any type of body
func NewCreate34RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountRequest generates requests for Count
func NewCountRequest(server string, params *CountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulk4Request calls the generic CreateBulk4 builder with application/json body
func NewCreateBulk4Request(server string, body CreateBulk4JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulk4RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulk4RequestWithBody generates requests for CreateBulk4 with any type of body
func NewCreateBulk4RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory20Request generates requests for FindAllHistory20
func NewFindAllHistory20Request(server string, params *FindAllHistory20Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr19Request generates requests for FindAllHistoryAodr19
func NewFindAllHistoryAodr19Request(server string, params *FindAllHistoryAodr19Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory20Request generates requests for CountHistory20
func NewCountHistory20Request(server string, params *CountHistory20Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp37Request generates requests for Queryhelp37
func NewQueryhelp37Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples35Request generates requests for FindAllTuples35
func NewFindAllTuples35Request(server string, params *FindAllTuples35Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, *params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind30Request generates requests for Find30
func NewFind30Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/eventevolution/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll33Request generates requests for FindAll33
func NewFindAll33Request(server string, params *FindAll33Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate38Request calls the generic Create38 builder with application/json body
func NewCreate38Request(server string, body Create38JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate38RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate38RequestWithBody generates requests for Create38 with any type of body
func NewCreate38RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST32Request generates requests for CountREST32
func NewCountREST32Request(server string, params *CountREST32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks10Request calls the generic CreateBulks10 builder with application/json body
func NewCreateBulks10Request(server string, body CreateBulks10JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks10RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks10RequestWithBody generates requests for CreateBulks10 with any type of body
func NewCreateBulks10RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory26Request generates requests for FindAllHistory26
func NewFindAllHistory26Request(server string, params *FindAllHistory26Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr25Request generates requests for FindAllHistoryAodr25
func NewFindAllHistoryAodr25Request(server string, params *FindAllHistoryAodr25Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory26Request generates requests for CountHistory26
func NewCountHistory26Request(server string, params *CountHistory26Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp43Request generates requests for Queryhelp43
func NewQueryhelp43Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples41Request generates requests for FindAllTuples41
func NewFindAllTuples41Request(server string, params *FindAllTuples41Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "detectTime", runtime.ParamLocationQuery, params.DetectTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind35Request generates requests for Find35
func NewFind35Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/hazard/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll46Request generates requests for FindAll46
func NewFindAll46Request(server string, params *FindAll46Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate53Request calls the generic Create53 builder with application/json body
func NewCreate53Request(server string, body Create53JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate53RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate53RequestWithBody generates requests for Create53 with any type of body
func NewCreate53RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDuplicate11Request generates requests for CountDuplicate11
func NewCountDuplicate11Request(server string, params *CountDuplicate11Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks14Request calls the generic CreateBulks14 builder with application/json body
func NewCreateBulks14Request(server string, body CreateBulks14JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks14RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks14RequestWithBody generates requests for CreateBulks14 with any type of body
func NewCreateBulks14RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory32Request generates requests for FindAllHistory32
func NewFindAllHistory32Request(server string, params *FindAllHistory32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr31Request generates requests for FindAllHistoryAodr31
func NewFindAllHistoryAodr31Request(server string, params *FindAllHistoryAodr31Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory32Request generates requests for CountHistory32
func NewCountHistory32Request(server string, params *CountHistory32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp56Request generates requests for Queryhelp56
func NewQueryhelp56Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples54Request generates requests for FindAllTuples54
func NewFindAllTuples54Request(server string, params *FindAllTuples54Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missiletrack/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll47Request generates requests for FindAll47
func NewFindAll47Request(server string, params *FindAll47Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate54Request calls the generic Create54 builder with application/json body
func NewCreate54Request(server string, body Create54JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate54RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate54RequestWithBody generates requests for Create54 with any type of body
func NewCreate54RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST43Request generates requests for CountREST43
func NewCountREST43Request(server string, params *CountREST43Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMissionAssignmentCreateBulkRequest calls the generic MissionAssignmentCreateBulk builder with application/json body
func NewMissionAssignmentCreateBulkRequest(server string, body MissionAssignmentCreateBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMissionAssignmentCreateBulkRequestWithBody(server, "application/json", bodyReader)
}

// NewMissionAssignmentCreateBulkRequestWithBody generates requests for MissionAssignmentCreateBulk with any type of body
func NewMissionAssignmentCreateBulkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory33Request generates requests for FindAllHistory33
func NewFindAllHistory33Request(server string, params *FindAllHistory33Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr32Request generates requests for FindAllHistoryAodr32
func NewFindAllHistoryAodr32Request(server string, params *FindAllHistoryAodr32Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory33Request generates requests for CountHistory33
func NewCountHistory33Request(server string, params *CountHistory33Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp57Request generates requests for Queryhelp57
func NewQueryhelp57Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples55Request generates requests for FindAllTuples55
func NewFindAllTuples55Request(server string, params *FindAllTuples55Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemove27Request generates requests for Remove27
func NewRemove27Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind48Request generates requests for Find48
func NewFind48Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEdit29Request calls the generic Edit29 builder with application/json body
func NewEdit29Request(server string, id string, body Edit29JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEdit29RequestWithBody(server, id, "application/json", bodyReader)
}

// NewEdit29RequestWithBody generates requests for Edit29 with any type of body
func NewEdit29RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/missionassignment/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAll62Request generates requests for FindAll62
func NewFindAll62Request(server string, params *FindAll62Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate68Request calls the generic Create68 builder with application/json body
func NewCreate68Request(server string, body Create68JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate68RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate68RequestWithBody generates requests for Create68 with any type of body
func NewCreate68RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDuplicate15Request generates requests for CountDuplicate15
func NewCountDuplicate15Request(server string, params *CountDuplicate15Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks18Request calls the generic CreateBulks18 builder with application/json body
func NewCreateBulks18Request(server string, body CreateBulks18JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks18RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks18RequestWithBody generates requests for CreateBulks18 with any type of body
func NewCreateBulks18RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory38Request generates requests for FindAllHistory38
func NewFindAllHistory38Request(server string, params *FindAllHistory38Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr37Request generates requests for FindAllHistoryAodr37
func NewFindAllHistoryAodr37Request(server string, params *FindAllHistoryAodr37Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory38Request generates requests for CountHistory38
func NewCountHistory38Request(server string, params *CountHistory38Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp68Request generates requests for Queryhelp68
func NewQueryhelp68Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples66Request generates requests for FindAllTuples66
func NewFindAllTuples66Request(server string, params *FindAllTuples66Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/orbittrack/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll65Request generates requests for FindAll65
func NewFindAll65Request(server string, params *FindAll65Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate71Request calls the generic Create71 builder with application/json body
func NewCreate71Request(server string, body Create71JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate71RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate71RequestWithBody generates requests for Create71 with any type of body
func NewCreate71RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST51Request generates requests for CountREST51
func NewCountREST51Request(server string, params *CountREST51Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks19Request calls the generic CreateBulks19 builder with application/json body
func NewCreateBulks19Request(server string, body CreateBulks19JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks19RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks19RequestWithBody generates requests for CreateBulks19 with any type of body
func NewCreateBulks19RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory39Request generates requests for FindAllHistory39
func NewFindAllHistory39Request(server string, params *FindAllHistory39Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr38Request generates requests for FindAllHistoryAodr38
func NewFindAllHistoryAodr38Request(server string, params *FindAllHistoryAodr38Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory39Request generates requests for CountHistory39
func NewCountHistory39Request(server string, params *CountHistory39Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp70Request generates requests for Queryhelp70
func NewQueryhelp70Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples68Request generates requests for FindAllTuples68
func NewFindAllTuples68Request(server string, params *FindAllTuples68Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind63Request generates requests for Find63
func NewFind63Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/poi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll85Request generates requests for FindAll85
func NewFindAll85Request(server string, params *FindAll85Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportDate", runtime.ParamLocationQuery, params.ReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate91Request calls the generic Create91 builder with application/json body
func NewCreate91Request(server string, body Create91JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate91RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate91RequestWithBody generates requests for Create91 with any type of body
func NewCreate91RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountDuplicate16Request generates requests for CountDuplicate16
func NewCountDuplicate16Request(server string, params *CountDuplicate16Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportDate", runtime.ParamLocationQuery, params.ReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory46Request generates requests for FindAllHistory46
func NewFindAllHistory46Request(server string, params *FindAllHistory46Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportDate", runtime.ParamLocationQuery, params.ReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory46Request generates requests for CountHistory46
func NewCountHistory46Request(server string, params *CountHistory46Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportDate", runtime.ParamLocationQuery, params.ReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp92Request generates requests for Queryhelp92
func NewQueryhelp92Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples88Request generates requests for FindAllTuples88
func NewFindAllTuples88Request(server string, params *FindAllTuples88Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sigact/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportDate", runtime.ParamLocationQuery, params.ReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll86Request generates requests for FindAll86
func NewFindAll86Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate92Request calls the generic Create92 builder with application/json body
func NewCreate92Request(server string, body Create92JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate92RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate92RequestWithBody generates requests for Create92 with any type of body
func NewCreate92RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST70Request generates requests for CountREST70
func NewCountREST70Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp93Request generates requests for Queryhelp93
func NewQueryhelp93Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples89Request generates requests for FindAllTuples89
func NewFindAllTuples89Request(server string, params *FindAllTuples89Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind84Request generates requests for Find84
func NewFind84Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEdit59Request calls the generic Edit59 builder with application/json body
func NewEdit59Request(server string, id string, body Edit59JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEdit59RequestWithBody(server, id, "application/json", bodyReader)
}

// NewEdit59RequestWithBody generates requests for Edit59 with any type of body
func NewEdit59RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/site/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAll87Request generates requests for FindAll87
func NewFindAll87Request(server string, params *FindAll87Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate93Request calls the generic Create93 builder with application/json body
func NewCreate93Request(server string, body Create93JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate93RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate93RequestWithBody generates requests for Create93 with any type of body
func NewCreate93RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountREST71Request generates requests for CountREST71
func NewCountREST71Request(server string, params *CountREST71Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory47Request generates requests for FindAllHistory47
func NewFindAllHistory47Request(server string, params *FindAllHistory47Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory47Request generates requests for CountHistory47
func NewCountHistory47Request(server string, params *CountHistory47Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp94Request generates requests for Queryhelp94
func NewQueryhelp94Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples90Request generates requests for FindAllTuples90
func NewFindAllTuples90Request(server string, params *FindAllTuples90Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt", runtime.ParamLocationQuery, params.CreatedAt); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemove56Request generates requests for Remove56
func NewRemove56Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind85Request generates requests for Find85
func NewFind85Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEdit60Request calls the generic Edit60 builder with application/json body
func NewEdit60Request(server string, id string, body Edit60JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEdit60RequestWithBody(server, id, "application/json", bodyReader)
}

// NewEdit60RequestWithBody generates requests for Edit60 with any type of body
func NewEdit60RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/sitestatus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAll99Request generates requests for FindAll99
func NewFindAll99Request(server string, params *FindAll99Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate18Request generates requests for CountDuplicate18
func NewCountDuplicate18Request(server string, params *CountDuplicate18Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks26Request calls the generic CreateBulks26 builder with application/json body
func NewCreateBulks26Request(server string, body CreateBulks26JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks26RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks26RequestWithBody generates requests for CreateBulks26 with any type of body
func NewCreateBulks26RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory54Request generates requests for FindAllHistory54
func NewFindAllHistory54Request(server string, params *FindAllHistory54Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr50Request generates requests for FindAllHistoryAodr50
func NewFindAllHistoryAodr50Request(server string, params *FindAllHistoryAodr50Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory54Request generates requests for CountHistory54
func NewCountHistory54Request(server string, params *CountHistory54Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp106Request generates requests for Queryhelp106
func NewQueryhelp106Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples102Request generates requests for FindAllTuples102
func NewFindAllTuples102Request(server string, params *FindAllTuples102Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/track/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll98Request generates requests for FindAll98
func NewFindAll98Request(server string, params *FindAll98Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountDuplicate17Request generates requests for CountDuplicate17
func NewCountDuplicate17Request(server string, params *CountDuplicate17Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBulks25Request calls the generic CreateBulks25 builder with application/json body
func NewCreateBulks25Request(server string, body CreateBulks25JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBulks25RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBulks25RequestWithBody generates requests for CreateBulks25 with any type of body
func NewCreateBulks25RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/createBulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAllHistory53Request generates requests for FindAllHistory53
func NewFindAllHistory53Request(server string, params *FindAllHistory53Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr49Request generates requests for FindAllHistoryAodr49
func NewFindAllHistoryAodr49Request(server string, params *FindAllHistoryAodr49Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory53Request generates requests for CountHistory53
func NewCountHistory53Request(server string, params *CountHistory53Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp105Request generates requests for Queryhelp105
func NewQueryhelp105Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples101Request generates requests for FindAllTuples101
func NewFindAllTuples101Request(server string, params *FindAllTuples101Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/trackdetails/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts", runtime.ParamLocationQuery, params.Ts); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAll102Request generates requests for FindAll102
func NewFindAll102Request(server string, params *FindAll102Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreate106Request calls the generic Create106 builder with application/json body
func NewCreate106Request(server string, body Create106JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreate106RequestWithBody(server, "application/json", bodyReader)
}

// NewCreate106RequestWithBody generates requests for Create106 with any type of body
func NewCreate106RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCount2Request generates requests for Count2
func NewCount2Request(server string, params *Count2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistory56Request generates requests for FindAllHistory56
func NewFindAllHistory56Request(server string, params *FindAllHistory56Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllHistoryAodr51Request generates requests for FindAllHistoryAodr51
func NewFindAllHistoryAodr51Request(server string, params *FindAllHistoryAodr51Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/history/aodr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Columns != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputFormat", runtime.ParamLocationQuery, *params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OutputDelimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputDelimiter", runtime.ParamLocationQuery, *params.OutputDelimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Notification != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification", runtime.ParamLocationQuery, *params.Notification); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCountHistory56Request generates requests for CountHistory56
func NewCountHistory56Request(server string, params *CountHistory56Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/history/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryhelp109Request generates requests for Queryhelp109
func NewQueryhelp109Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/queryhelp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAllTuples105Request generates requests for FindAllTuples105
func NewFindAllTuples105Request(server string, params *FindAllTuples105Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/tuple")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, params.Columns); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "obTime", runtime.ParamLocationQuery, params.ObTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFind99Request generates requests for Find99
func NewFind99Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/udl/weatherreport/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// FiledropEphemPostId request with any body
	FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error)

	// FiledropUdlAircraftsortiePostId request with any body
	FiledropUdlAircraftsortiePostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAircraftsortiePostIdResponse, error)

	FiledropUdlAircraftsortiePostIdWithResponse(ctx context.Context, body FiledropUdlAircraftsortiePostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAircraftsortiePostIdResponse, error)

	// FiledropUdlAisPostId request with any body
	FiledropUdlAisPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error)

	FiledropUdlAisPostIdWithResponse(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error)

	// FiledropUdlAnalyticimageryPostId request with any body
	FiledropUdlAnalyticimageryPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAnalyticimageryPostIdResponse, error)

	FiledropUdlAnalyticimageryPostIdWithResponse(ctx context.Context, body FiledropUdlAnalyticimageryPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAnalyticimageryPostIdResponse, error)

	// FiledropUdlAttitudesetPostId request with any body
	FiledropUdlAttitudesetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error)

	FiledropUdlAttitudesetPostIdWithResponse(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error)

	// FiledropUdlElsetPostId request with any body
	FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error)

	// FiledropUdlEphsetPostId request with any body
	FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error)

	// FiledropUdlEventevolutionPostId request with any body
	FiledropUdlEventevolutionPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEventevolutionPostIdResponse, error)

	FiledropUdlEventevolutionPostIdWithResponse(ctx context.Context, body FiledropUdlEventevolutionPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEventevolutionPostIdResponse, error)

	// FiledropUdlOrbittrackPostId request with any body
	FiledropUdlOrbittrackPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlOrbittrackPostIdResponse, error)

	FiledropUdlOrbittrackPostIdWithResponse(ctx context.Context, body FiledropUdlOrbittrackPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlOrbittrackPostIdResponse, error)

	// FiledropUdlPoiPostId request with any body
	FiledropUdlPoiPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlPoiPostIdResponse, error)

	FiledropUdlPoiPostIdWithResponse(ctx context.Context, body FiledropUdlPoiPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlPoiPostIdResponse, error)

	// FiledropUdlSigactPostId request with any body
	FiledropUdlSigactPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlSigactPostIdResponse, error)

	FiledropUdlSigactPostIdWithResponse(ctx context.Context, body FiledropUdlSigactPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlSigactPostIdResponse, error)

	// FiledropUdlTracksPostId request with any body
	FiledropUdlTracksPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlTracksPostIdResponse, error)

	FiledropUdlTracksPostIdWithResponse(ctx context.Context, body FiledropUdlTracksPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlTracksPostIdResponse, error)

	// FiledropWeatherreportPostId request with any body
	FiledropWeatherreportPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropWeatherreportPostIdResponse, error)

	FiledropWeatherreportPostIdWithResponse(ctx context.Context, body FiledropWeatherreportPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropWeatherreportPostIdResponse, error)

	// FindAll2 request
	FindAll2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll2Response, error)

	// Create2 request with any body
	Create2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create2Response, error)

	Create2WithResponse(ctx context.Context, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*Create2Response, error)

	// CountREST request
	CountRESTWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountRESTResponse, error)

	// Queryhelp2 request
	Queryhelp2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp2Response, error)

	// FindAllTuples2 request
	FindAllTuples2WithResponse(ctx context.Context, params *FindAllTuples2Params, reqEditors ...RequestEditorFn) (*FindAllTuples2Response, error)

	// Find request
	FindWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindResponse, error)

	// Edit request with any body
	EditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditResponse, error)

	EditWithResponse(ctx context.Context, id string, body EditJSONRequestBody, reqEditors ...RequestEditorFn) (*EditResponse, error)

	// FindAllWithStream request
	FindAllWithStreamWithResponse(ctx context.Context, params *FindAllWithStreamParams, reqEditors ...RequestEditorFn) (*FindAllWithStreamResponse, error)

	// Create3 request with any body
	Create3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create3Response, error)

	Create3WithResponse(ctx context.Context, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*Create3Response, error)

	// CountREST1 request
	CountREST1WithResponse(ctx context.Context, params *CountREST1Params, reqEditors ...RequestEditorFn) (*CountREST1Response, error)

	// CreateBulks1 request with any body
	CreateBulks1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks1Response, error)

	CreateBulks1WithResponse(ctx context.Context, body CreateBulks1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks1Response, error)

	// FindAllHistory2 request
	FindAllHistory2WithResponse(ctx context.Context, params *FindAllHistory2Params, reqEditors ...RequestEditorFn) (*FindAllHistory2Response, error)

	// FindAllHistoryAodr2 request
	FindAllHistoryAodr2WithResponse(ctx context.Context, params *FindAllHistoryAodr2Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr2Response, error)

	// CountHistory2 request
	CountHistory2WithResponse(ctx context.Context, params *CountHistory2Params, reqEditors ...RequestEditorFn) (*CountHistory2Response, error)

	// Queryhelp3 request
	Queryhelp3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp3Response, error)

	// FindAllTuples3 request
	FindAllTuples3WithResponse(ctx context.Context, params *FindAllTuples3Params, reqEditors ...RequestEditorFn) (*FindAllTuples3Response, error)

	// Remove request
	RemoveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveResponse, error)

	// Find1 request
	Find1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find1Response, error)

	// Edit1 request with any body
	Edit1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit1Response, error)

	Edit1WithResponse(ctx context.Context, id string, body Edit1JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit1Response, error)

	// FindAll3 request
	FindAll3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll3Response, error)

	// Create4 request with any body
	Create4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create4Response, error)

	Create4WithResponse(ctx context.Context, body Create4JSONRequestBody, reqEditors ...RequestEditorFn) (*Create4Response, error)

	// CountREST2 request
	CountREST2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountREST2Response, error)

	// Queryhelp4 request
	Queryhelp4WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp4Response, error)

	// FindAllTuples4 request
	FindAllTuples4WithResponse(ctx context.Context, params *FindAllTuples4Params, reqEditors ...RequestEditorFn) (*FindAllTuples4Response, error)

	// Remove1 request
	Remove1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove1Response, error)

	// Find2 request
	Find2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find2Response, error)

	// Edit2 request with any body
	Edit2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit2Response, error)

	Edit2WithResponse(ctx context.Context, id string, body Edit2JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit2Response, error)

	// FindAll request
	FindAllWithResponse(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*FindAllResponse, error)

	// Create request with any body
	CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// CountDuplicate request
	CountDuplicateWithResponse(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*CountDuplicateResponse, error)

	// CreateBulks request with any body
	CreateBulksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error)

	CreateBulksWithResponse(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error)

	// FindAllHistory request
	FindAllHistoryWithResponse(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*FindAllHistoryResponse, error)

	// FindAllHistoryAodr request
	FindAllHistoryAodrWithResponse(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*FindAllHistoryAodrResponse, error)

	// CountHistory request
	CountHistoryWithResponse(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*CountHistoryResponse, error)

	// Queryhelp request
	QueryhelpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryhelpResponse, error)

	// FindAllTuples request
	FindAllTuplesWithResponse(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*FindAllTuplesResponse, error)

	// FindAll4 request
	FindAll4WithResponse(ctx context.Context, params *FindAll4Params, reqEditors ...RequestEditorFn) (*FindAll4Response, error)

	// CountREST3 request
	CountREST3WithResponse(ctx context.Context, params *CountREST3Params, reqEditors ...RequestEditorFn) (*CountREST3Response, error)

	// GetFile request
	GetFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// FindAllHistory3 request
	FindAllHistory3WithResponse(ctx context.Context, params *FindAllHistory3Params, reqEditors ...RequestEditorFn) (*FindAllHistory3Response, error)

	// FindAllHistoryAodr3 request
	FindAllHistoryAodr3WithResponse(ctx context.Context, params *FindAllHistoryAodr3Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr3Response, error)

	// CountHistory3 request
	CountHistory3WithResponse(ctx context.Context, params *CountHistory3Params, reqEditors ...RequestEditorFn) (*CountHistory3Response, error)

	// Queryhelp5 request
	Queryhelp5WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp5Response, error)

	// FindAllTuples5 request
	FindAllTuples5WithResponse(ctx context.Context, params *FindAllTuples5Params, reqEditors ...RequestEditorFn) (*FindAllTuples5Response, error)

	// Find3 request
	Find3WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find3Response, error)

	// FindAllWithStream1 request
	FindAllWithStream1WithResponse(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*FindAllWithStream1Response, error)

	// CountDuplicate2 request
	CountDuplicate2WithResponse(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*CountDuplicate2Response, error)

	// FindAllHistory4 request
	FindAllHistory4WithResponse(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*FindAllHistory4Response, error)

	// FindAllHistoryAodr4 request
	FindAllHistoryAodr4WithResponse(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr4Response, error)

	// CountHistory4 request
	CountHistory4WithResponse(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*CountHistory4Response, error)

	// Queryhelp7 request
	Queryhelp7WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp7Response, error)

	// FindAllTuples7 request
	FindAllTuples7WithResponse(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*FindAllTuples7Response, error)

	// FindAllWithStream2 request
	FindAllWithStream2WithResponse(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*FindAllWithStream2Response, error)

	// Create7 request with any body
	Create7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create7Response, error)

	Create7WithResponse(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*Create7Response, error)

	// CountREST5 request
	CountREST5WithResponse(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*CountREST5Response, error)

	// FindAllHistory5 request
	FindAllHistory5WithResponse(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*FindAllHistory5Response, error)

	// FindAllHistoryAodr5 request
	FindAllHistoryAodr5WithResponse(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr5Response, error)

	// CountHistory5 request
	CountHistory5WithResponse(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*CountHistory5Response, error)

	// Queryhelp8 request
	Queryhelp8WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp8Response, error)

	// FindAllTuples8 request
	FindAllTuples8WithResponse(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*FindAllTuples8Response, error)

	// Find6 request
	Find6WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find6Response, error)

	// PostCotToBluestaqTakServer request with any body
	PostCotToBluestaqTakServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCotToBluestaqTakServerResponse, error)

	PostCotToBluestaqTakServerWithResponse(ctx context.Context, body PostCotToBluestaqTakServerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCotToBluestaqTakServerResponse, error)

	// Current request
	CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error)

	// Queryhelp21 request
	Queryhelp21WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp21Response, error)

	// FindAllWithStream8 request
	FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error)

	// Create28 request with any body
	Create28WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create28Response, error)

	Create28WithResponse(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*Create28Response, error)

	// CountREST24 request
	CountREST24WithResponse(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*CountREST24Response, error)

	// CreateBulks8 request with any body
	CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error)

	// CreateBulkFromTLE request with any body
	CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error)

	// Current1 request
	Current1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Current1Response, error)

	// CurrentTuple request
	CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error)

	// FindAllHistory16 request
	FindAllHistory16WithResponse(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*FindAllHistory16Response, error)

	// FindAllHistoryAodr16 request
	FindAllHistoryAodr16WithResponse(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr16Response, error)

	// CountHistory16 request
	CountHistory16WithResponse(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*CountHistory16Response, error)

	// Queryhelp31 request
	Queryhelp31WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp31Response, error)

	// FindAllTuples29 request
	FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error)

	// Find25 request
	Find25WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find25Response, error)

	// FindAllWithStream9 request
	FindAllWithStream9WithResponse(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*FindAllWithStream9Response, error)

	// CountDuplicate6 request
	CountDuplicate6WithResponse(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*CountDuplicate6Response, error)

	// FindAllHistory17 request
	FindAllHistory17WithResponse(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*FindAllHistory17Response, error)

	// FindAllHistoryAodr17 request
	FindAllHistoryAodr17WithResponse(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr17Response, error)

	// CountHistory17 request
	CountHistory17WithResponse(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*CountHistory17Response, error)

	// Queryhelp34 request
	Queryhelp34WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp34Response, error)

	// FindAllTuples32 request
	FindAllTuples32WithResponse(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*FindAllTuples32Response, error)

	// FindAllWithStream10 request
	FindAllWithStream10WithResponse(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*FindAllWithStream10Response, error)

	// Create32 request with any body
	Create32WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create32Response, error)

	Create32WithResponse(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*Create32Response, error)

	// CountREST27 request
	CountREST27WithResponse(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*CountREST27Response, error)

	// GetFile1 request
	GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error)

	// FindAllHistory18 request
	FindAllHistory18WithResponse(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*FindAllHistory18Response, error)

	// FindAllHistoryAodr18 request
	FindAllHistoryAodr18WithResponse(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr18Response, error)

	// CountHistory18 request
	CountHistory18WithResponse(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*CountHistory18Response, error)

	// Queryhelp35 request
	Queryhelp35WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp35Response, error)

	// FindAllTuples33 request
	FindAllTuples33WithResponse(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*FindAllTuples33Response, error)

	// Find29 request
	Find29WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find29Response, error)

	// FindAll27 request
	FindAll27WithResponse(ctx context.Context, params *FindAll27Params, reqEditors ...RequestEditorFn) (*FindAll27Response, error)

	// Create34 request with any body
	Create34WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create34Response, error)

	Create34WithResponse(ctx context.Context, body Create34JSONRequestBody, reqEditors ...RequestEditorFn) (*Create34Response, error)

	// Count request
	CountWithResponse(ctx context.Context, params *CountParams, reqEditors ...RequestEditorFn) (*CountResponse, error)

	// CreateBulk4 request with any body
	CreateBulk4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulk4Response, error)

	CreateBulk4WithResponse(ctx context.Context, body CreateBulk4JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulk4Response, error)

	// FindAllHistory20 request
	FindAllHistory20WithResponse(ctx context.Context, params *FindAllHistory20Params, reqEditors ...RequestEditorFn) (*FindAllHistory20Response, error)

	// FindAllHistoryAodr19 request
	FindAllHistoryAodr19WithResponse(ctx context.Context, params *FindAllHistoryAodr19Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr19Response, error)

	// CountHistory20 request
	CountHistory20WithResponse(ctx context.Context, params *CountHistory20Params, reqEditors ...RequestEditorFn) (*CountHistory20Response, error)

	// Queryhelp37 request
	Queryhelp37WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp37Response, error)

	// FindAllTuples35 request
	FindAllTuples35WithResponse(ctx context.Context, params *FindAllTuples35Params, reqEditors ...RequestEditorFn) (*FindAllTuples35Response, error)

	// Find30 request
	Find30WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find30Response, error)

	// FindAll33 request
	FindAll33WithResponse(ctx context.Context, params *FindAll33Params, reqEditors ...RequestEditorFn) (*FindAll33Response, error)

	// Create38 request with any body
	Create38WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create38Response, error)

	Create38WithResponse(ctx context.Context, body Create38JSONRequestBody, reqEditors ...RequestEditorFn) (*Create38Response, error)

	// CountREST32 request
	CountREST32WithResponse(ctx context.Context, params *CountREST32Params, reqEditors ...RequestEditorFn) (*CountREST32Response, error)

	// CreateBulks10 request with any body
	CreateBulks10WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks10Response, error)

	CreateBulks10WithResponse(ctx context.Context, body CreateBulks10JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks10Response, error)

	// FindAllHistory26 request
	FindAllHistory26WithResponse(ctx context.Context, params *FindAllHistory26Params, reqEditors ...RequestEditorFn) (*FindAllHistory26Response, error)

	// FindAllHistoryAodr25 request
	FindAllHistoryAodr25WithResponse(ctx context.Context, params *FindAllHistoryAodr25Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr25Response, error)

	// CountHistory26 request
	CountHistory26WithResponse(ctx context.Context, params *CountHistory26Params, reqEditors ...RequestEditorFn) (*CountHistory26Response, error)

	// Queryhelp43 request
	Queryhelp43WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp43Response, error)

	// FindAllTuples41 request
	FindAllTuples41WithResponse(ctx context.Context, params *FindAllTuples41Params, reqEditors ...RequestEditorFn) (*FindAllTuples41Response, error)

	// Find35 request
	Find35WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find35Response, error)

	// FindAll46 request
	FindAll46WithResponse(ctx context.Context, params *FindAll46Params, reqEditors ...RequestEditorFn) (*FindAll46Response, error)

	// Create53 request with any body
	Create53WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create53Response, error)

	Create53WithResponse(ctx context.Context, body Create53JSONRequestBody, reqEditors ...RequestEditorFn) (*Create53Response, error)

	// CountDuplicate11 request
	CountDuplicate11WithResponse(ctx context.Context, params *CountDuplicate11Params, reqEditors ...RequestEditorFn) (*CountDuplicate11Response, error)

	// CreateBulks14 request with any body
	CreateBulks14WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks14Response, error)

	CreateBulks14WithResponse(ctx context.Context, body CreateBulks14JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks14Response, error)

	// FindAllHistory32 request
	FindAllHistory32WithResponse(ctx context.Context, params *FindAllHistory32Params, reqEditors ...RequestEditorFn) (*FindAllHistory32Response, error)

	// FindAllHistoryAodr31 request
	FindAllHistoryAodr31WithResponse(ctx context.Context, params *FindAllHistoryAodr31Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr31Response, error)

	// CountHistory32 request
	CountHistory32WithResponse(ctx context.Context, params *CountHistory32Params, reqEditors ...RequestEditorFn) (*CountHistory32Response, error)

	// Queryhelp56 request
	Queryhelp56WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp56Response, error)

	// FindAllTuples54 request
	FindAllTuples54WithResponse(ctx context.Context, params *FindAllTuples54Params, reqEditors ...RequestEditorFn) (*FindAllTuples54Response, error)

	// FindAll47 request
	FindAll47WithResponse(ctx context.Context, params *FindAll47Params, reqEditors ...RequestEditorFn) (*FindAll47Response, error)

	// Create54 request with any body
	Create54WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create54Response, error)

	Create54WithResponse(ctx context.Context, body Create54JSONRequestBody, reqEditors ...RequestEditorFn) (*Create54Response, error)

	// CountREST43 request
	CountREST43WithResponse(ctx context.Context, params *CountREST43Params, reqEditors ...RequestEditorFn) (*CountREST43Response, error)

	// MissionAssignmentCreateBulk request with any body
	MissionAssignmentCreateBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MissionAssignmentCreateBulkResponse, error)

	MissionAssignmentCreateBulkWithResponse(ctx context.Context, body MissionAssignmentCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*MissionAssignmentCreateBulkResponse, error)

	// FindAllHistory33 request
	FindAllHistory33WithResponse(ctx context.Context, params *FindAllHistory33Params, reqEditors ...RequestEditorFn) (*FindAllHistory33Response, error)

	// FindAllHistoryAodr32 request
	FindAllHistoryAodr32WithResponse(ctx context.Context, params *FindAllHistoryAodr32Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr32Response, error)

	// CountHistory33 request
	CountHistory33WithResponse(ctx context.Context, params *CountHistory33Params, reqEditors ...RequestEditorFn) (*CountHistory33Response, error)

	// Queryhelp57 request
	Queryhelp57WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp57Response, error)

	// FindAllTuples55 request
	FindAllTuples55WithResponse(ctx context.Context, params *FindAllTuples55Params, reqEditors ...RequestEditorFn) (*FindAllTuples55Response, error)

	// Remove27 request
	Remove27WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove27Response, error)

	// Find48 request
	Find48WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find48Response, error)

	// Edit29 request with any body
	Edit29WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit29Response, error)

	Edit29WithResponse(ctx context.Context, id string, body Edit29JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit29Response, error)

	// FindAll62 request
	FindAll62WithResponse(ctx context.Context, params *FindAll62Params, reqEditors ...RequestEditorFn) (*FindAll62Response, error)

	// Create68 request with any body
	Create68WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create68Response, error)

	Create68WithResponse(ctx context.Context, body Create68JSONRequestBody, reqEditors ...RequestEditorFn) (*Create68Response, error)

	// CountDuplicate15 request
	CountDuplicate15WithResponse(ctx context.Context, params *CountDuplicate15Params, reqEditors ...RequestEditorFn) (*CountDuplicate15Response, error)

	// CreateBulks18 request with any body
	CreateBulks18WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks18Response, error)

	CreateBulks18WithResponse(ctx context.Context, body CreateBulks18JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks18Response, error)

	// FindAllHistory38 request
	FindAllHistory38WithResponse(ctx context.Context, params *FindAllHistory38Params, reqEditors ...RequestEditorFn) (*FindAllHistory38Response, error)

	// FindAllHistoryAodr37 request
	FindAllHistoryAodr37WithResponse(ctx context.Context, params *FindAllHistoryAodr37Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr37Response, error)

	// CountHistory38 request
	CountHistory38WithResponse(ctx context.Context, params *CountHistory38Params, reqEditors ...RequestEditorFn) (*CountHistory38Response, error)

	// Queryhelp68 request
	Queryhelp68WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp68Response, error)

	// FindAllTuples66 request
	FindAllTuples66WithResponse(ctx context.Context, params *FindAllTuples66Params, reqEditors ...RequestEditorFn) (*FindAllTuples66Response, error)

	// FindAll65 request
	FindAll65WithResponse(ctx context.Context, params *FindAll65Params, reqEditors ...RequestEditorFn) (*FindAll65Response, error)

	// Create71 request with any body
	Create71WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create71Response, error)

	Create71WithResponse(ctx context.Context, body Create71JSONRequestBody, reqEditors ...RequestEditorFn) (*Create71Response, error)

	// CountREST51 request
	CountREST51WithResponse(ctx context.Context, params *CountREST51Params, reqEditors ...RequestEditorFn) (*CountREST51Response, error)

	// CreateBulks19 request with any body
	CreateBulks19WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks19Response, error)

	CreateBulks19WithResponse(ctx context.Context, body CreateBulks19JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks19Response, error)

	// FindAllHistory39 request
	FindAllHistory39WithResponse(ctx context.Context, params *FindAllHistory39Params, reqEditors ...RequestEditorFn) (*FindAllHistory39Response, error)

	// FindAllHistoryAodr38 request
	FindAllHistoryAodr38WithResponse(ctx context.Context, params *FindAllHistoryAodr38Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr38Response, error)

	// CountHistory39 request
	CountHistory39WithResponse(ctx context.Context, params *CountHistory39Params, reqEditors ...RequestEditorFn) (*CountHistory39Response, error)

	// Queryhelp70 request
	Queryhelp70WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp70Response, error)

	// FindAllTuples68 request
	FindAllTuples68WithResponse(ctx context.Context, params *FindAllTuples68Params, reqEditors ...RequestEditorFn) (*FindAllTuples68Response, error)

	// Find63 request
	Find63WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find63Response, error)

	// FindAll85 request
	FindAll85WithResponse(ctx context.Context, params *FindAll85Params, reqEditors ...RequestEditorFn) (*FindAll85Response, error)

	// Create91 request with any body
	Create91WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create91Response, error)

	Create91WithResponse(ctx context.Context, body Create91JSONRequestBody, reqEditors ...RequestEditorFn) (*Create91Response, error)

	// CountDuplicate16 request
	CountDuplicate16WithResponse(ctx context.Context, params *CountDuplicate16Params, reqEditors ...RequestEditorFn) (*CountDuplicate16Response, error)

	// FindAllHistory46 request
	FindAllHistory46WithResponse(ctx context.Context, params *FindAllHistory46Params, reqEditors ...RequestEditorFn) (*FindAllHistory46Response, error)

	// CountHistory46 request
	CountHistory46WithResponse(ctx context.Context, params *CountHistory46Params, reqEditors ...RequestEditorFn) (*CountHistory46Response, error)

	// Queryhelp92 request
	Queryhelp92WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp92Response, error)

	// FindAllTuples88 request
	FindAllTuples88WithResponse(ctx context.Context, params *FindAllTuples88Params, reqEditors ...RequestEditorFn) (*FindAllTuples88Response, error)

	// FindAll86 request
	FindAll86WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll86Response, error)

	// Create92 request with any body
	Create92WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create92Response, error)

	Create92WithResponse(ctx context.Context, body Create92JSONRequestBody, reqEditors ...RequestEditorFn) (*Create92Response, error)

	// CountREST70 request
	CountREST70WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountREST70Response, error)

	// Queryhelp93 request
	Queryhelp93WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp93Response, error)

	// FindAllTuples89 request
	FindAllTuples89WithResponse(ctx context.Context, params *FindAllTuples89Params, reqEditors ...RequestEditorFn) (*FindAllTuples89Response, error)

	// Find84 request
	Find84WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find84Response, error)

	// Edit59 request with any body
	Edit59WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit59Response, error)

	Edit59WithResponse(ctx context.Context, id string, body Edit59JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit59Response, error)

	// FindAll87 request
	FindAll87WithResponse(ctx context.Context, params *FindAll87Params, reqEditors ...RequestEditorFn) (*FindAll87Response, error)

	// Create93 request with any body
	Create93WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create93Response, error)

	Create93WithResponse(ctx context.Context, body Create93JSONRequestBody, reqEditors ...RequestEditorFn) (*Create93Response, error)

	// CountREST71 request
	CountREST71WithResponse(ctx context.Context, params *CountREST71Params, reqEditors ...RequestEditorFn) (*CountREST71Response, error)

	// FindAllHistory47 request
	FindAllHistory47WithResponse(ctx context.Context, params *FindAllHistory47Params, reqEditors ...RequestEditorFn) (*FindAllHistory47Response, error)

	// CountHistory47 request
	CountHistory47WithResponse(ctx context.Context, params *CountHistory47Params, reqEditors ...RequestEditorFn) (*CountHistory47Response, error)

	// Queryhelp94 request
	Queryhelp94WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp94Response, error)

	// FindAllTuples90 request
	FindAllTuples90WithResponse(ctx context.Context, params *FindAllTuples90Params, reqEditors ...RequestEditorFn) (*FindAllTuples90Response, error)

	// Remove56 request
	Remove56WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove56Response, error)

	// Find85 request
	Find85WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find85Response, error)

	// Edit60 request with any body
	Edit60WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit60Response, error)

	Edit60WithResponse(ctx context.Context, id string, body Edit60JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit60Response, error)

	// FindAll99 request
	FindAll99WithResponse(ctx context.Context, params *FindAll99Params, reqEditors ...RequestEditorFn) (*FindAll99Response, error)

	// CountDuplicate18 request
	CountDuplicate18WithResponse(ctx context.Context, params *CountDuplicate18Params, reqEditors ...RequestEditorFn) (*CountDuplicate18Response, error)

	// CreateBulks26 request with any body
	CreateBulks26WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks26Response, error)

	CreateBulks26WithResponse(ctx context.Context, body CreateBulks26JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks26Response, error)

	// FindAllHistory54 request
	FindAllHistory54WithResponse(ctx context.Context, params *FindAllHistory54Params, reqEditors ...RequestEditorFn) (*FindAllHistory54Response, error)

	// FindAllHistoryAodr50 request
	FindAllHistoryAodr50WithResponse(ctx context.Context, params *FindAllHistoryAodr50Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr50Response, error)

	// CountHistory54 request
	CountHistory54WithResponse(ctx context.Context, params *CountHistory54Params, reqEditors ...RequestEditorFn) (*CountHistory54Response, error)

	// Queryhelp106 request
	Queryhelp106WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp106Response, error)

	// FindAllTuples102 request
	FindAllTuples102WithResponse(ctx context.Context, params *FindAllTuples102Params, reqEditors ...RequestEditorFn) (*FindAllTuples102Response, error)

	// FindAll98 request
	FindAll98WithResponse(ctx context.Context, params *FindAll98Params, reqEditors ...RequestEditorFn) (*FindAll98Response, error)

	// CountDuplicate17 request
	CountDuplicate17WithResponse(ctx context.Context, params *CountDuplicate17Params, reqEditors ...RequestEditorFn) (*CountDuplicate17Response, error)

	// CreateBulks25 request with any body
	CreateBulks25WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks25Response, error)

	CreateBulks25WithResponse(ctx context.Context, body CreateBulks25JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks25Response, error)

	// FindAllHistory53 request
	FindAllHistory53WithResponse(ctx context.Context, params *FindAllHistory53Params, reqEditors ...RequestEditorFn) (*FindAllHistory53Response, error)

	// FindAllHistoryAodr49 request
	FindAllHistoryAodr49WithResponse(ctx context.Context, params *FindAllHistoryAodr49Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr49Response, error)

	// CountHistory53 request
	CountHistory53WithResponse(ctx context.Context, params *CountHistory53Params, reqEditors ...RequestEditorFn) (*CountHistory53Response, error)

	// Queryhelp105 request
	Queryhelp105WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp105Response, error)

	// FindAllTuples101 request
	FindAllTuples101WithResponse(ctx context.Context, params *FindAllTuples101Params, reqEditors ...RequestEditorFn) (*FindAllTuples101Response, error)

	// FindAll102 request
	FindAll102WithResponse(ctx context.Context, params *FindAll102Params, reqEditors ...RequestEditorFn) (*FindAll102Response, error)

	// Create106 request with any body
	Create106WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create106Response, error)

	Create106WithResponse(ctx context.Context, body Create106JSONRequestBody, reqEditors ...RequestEditorFn) (*Create106Response, error)

	// Count2 request
	Count2WithResponse(ctx context.Context, params *Count2Params, reqEditors ...RequestEditorFn) (*Count2Response, error)

	// FindAllHistory56 request
	FindAllHistory56WithResponse(ctx context.Context, params *FindAllHistory56Params, reqEditors ...RequestEditorFn) (*FindAllHistory56Response, error)

	// FindAllHistoryAodr51 request
	FindAllHistoryAodr51WithResponse(ctx context.Context, params *FindAllHistoryAodr51Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr51Response, error)

	// CountHistory56 request
	CountHistory56WithResponse(ctx context.Context, params *CountHistory56Params, reqEditors ...RequestEditorFn) (*CountHistory56Response, error)

	// Queryhelp109 request
	Queryhelp109WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp109Response, error)

	// FindAllTuples105 request
	FindAllTuples105WithResponse(ctx context.Context, params *FindAllTuples105Params, reqEditors ...RequestEditorFn) (*FindAllTuples105Response, error)

	// Find99 request
	Find99WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find99Response, error)
}

type FiledropEphemPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropEphemPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropEphemPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAircraftsortiePostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAircraftsortiePostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAircraftsortiePostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAisPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAisPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAisPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAnalyticimageryPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAnalyticimageryPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAnalyticimageryPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlAttitudesetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlAttitudesetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlAttitudesetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlElsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlElsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlElsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlEphsetPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlEphsetPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlEphsetPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlEventevolutionPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlEventevolutionPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlEventevolutionPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlOrbittrackPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlOrbittrackPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlOrbittrackPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlPoiPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlPoiPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlPoiPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlSigactPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlSigactPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlSigactPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropUdlTracksPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropUdlTracksPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropUdlTracksPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiledropWeatherreportPostIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FiledropWeatherreportPostIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiledropWeatherreportPostIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountRESTResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountRESTResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountRESTResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AircraftFull
}

// Status returns HTTPResponse.Status
func (r FindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftSortieAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftSortieFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftSortieFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AircraftSortieFull
}

// Status returns HTTPResponse.Status
func (r Find1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Edit1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Edit1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Edit1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftStatusAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AircraftStatusFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Remove1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Remove1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Remove1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AircraftStatusFull
}

// Status returns HTTPResponse.Status
func (r Find2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Edit2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Edit2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Edit2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryhelpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueryhelpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryhelpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AISFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AnalyticImageryAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AnalyticImageryFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AnalyticImageryFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnalyticImageryFull
}

// Status returns HTTPResponse.Status
func (r Find3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp7Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeDataFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create7Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory5Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp8Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttitudeSetFull
}

// Status returns HTTPResponse.Status
func (r Find6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCotToBluestaqTakServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostCotToBluestaqTakServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCotToBluestaqTakServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r CurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp21Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create28Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create28Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create28Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST24Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST24Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST24Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks8Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulkFromTLEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulkFromTLEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulkFromTLEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Current1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetAbridged
}

// Status returns HTTPResponse.Status
func (r Current1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Current1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentTupleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r CurrentTupleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentTupleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory16Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr16Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory16Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp31Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp31Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp31Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples29Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElsetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find25Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElsetFull
}

// Status returns HTTPResponse.Status
func (r Find25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream9Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream9Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream9Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate6Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory17Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr17Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory17Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp34Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp34Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp34Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples32Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllWithStream10Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetAbridged
}

// Status returns HTTPResponse.Status
func (r FindAllWithStream10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllWithStream10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create32Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST27Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST27Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST27Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFile1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFile1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFile1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory18Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp35Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp35Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp35Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples33Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples33Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples33Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find29Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EphemerisSetFull
}

// Status returns HTTPResponse.Status
func (r Find29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll27Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EventEvolutionAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll27Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll27Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create34Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create34Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create34Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulk4Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulk4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulk4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory20Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EventEvolutionFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory20Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory20Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr19Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr19Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr19Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory20Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory20Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory20Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp37Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp37Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp37Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples35Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EventEvolutionFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples35Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples35Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find30Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventEvolutionFull
}

// Status returns HTTPResponse.Status
func (r Find30Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find30Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll33Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HazardAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll33Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll33Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create38Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create38Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create38Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST32Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks10Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory26Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HazardFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory26Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory26Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr25Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory26Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory26Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory26Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp43Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp43Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp43Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples41Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HazardFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples41Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples41Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find35Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HazardFull
}

// Status returns HTTPResponse.Status
func (r Find35Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find35Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll46Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissileTrackAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll46Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll46Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create53Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create53Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create53Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate11Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate11Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate11Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks14Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks14Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks14Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory32Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissileTrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr31Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr31Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr31Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory32Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp56Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp56Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp56Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples54Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissileTrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples54Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples54Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll47Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissionAssignmentAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll47Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll47Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create54Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create54Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create54Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST43Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST43Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST43Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MissionAssignmentCreateBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MissionAssignmentCreateBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MissionAssignmentCreateBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory33Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissionAssignmentFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory33Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory33Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr32Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr32Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr32Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory33Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory33Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory33Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp57Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp57Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp57Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples55Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MissionAssignmentFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples55Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples55Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Remove27Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Remove27Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Remove27Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find48Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MissionAssignmentFull
}

// Status returns HTTPResponse.Status
func (r Find48Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find48Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Edit29Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Edit29Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Edit29Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll62Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrbitTrackAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll62Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll62Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create68Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create68Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create68Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate15Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate15Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate15Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory38Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrbitTrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory38Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory38Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr37Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr37Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr37Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory38Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory38Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory38Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp68Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp68Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp68Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples66Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrbitTrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples66Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples66Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll65Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]POIAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll65Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll65Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create71Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create71Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create71Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST51Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST51Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST51Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks19Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks19Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks19Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory39Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]POIFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory39Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory39Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr38Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr38Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr38Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory39Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory39Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory39Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp70Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp70Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp70Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples68Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]POIFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples68Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples68Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find63Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *POIFull
}

// Status returns HTTPResponse.Status
func (r Find63Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find63Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll85Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SigActAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll85Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll85Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create91Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create91Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create91Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate16Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate16Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate16Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory46Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SigActFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory46Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory46Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory46Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory46Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory46Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp92Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp92Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp92Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples88Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SigActFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples88Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples88Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll86Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SiteAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll86Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll86Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create92Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create92Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create92Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST70Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST70Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST70Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp93Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp93Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp93Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples89Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SiteFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples89Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples89Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find84Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SiteFull
}

// Status returns HTTPResponse.Status
func (r Find84Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find84Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Edit59Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Edit59Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Edit59Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll87Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SiteStatusAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll87Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll87Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create93Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create93Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create93Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountREST71Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountREST71Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountREST71Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory47Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SiteStatusFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory47Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory47Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory47Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory47Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory47Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp94Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp94Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp94Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples90Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SiteStatusFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples90Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples90Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Remove56Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Remove56Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Remove56Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find85Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SiteStatusFull
}

// Status returns HTTPResponse.Status
func (r Find85Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find85Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Edit60Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Edit60Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Edit60Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll99Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll99Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll99Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate18Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate18Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate18Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks26Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks26Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks26Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory54Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory54Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory54Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr50Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr50Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr50Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory54Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory54Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory54Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp106Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp106Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp106Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples102Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples102Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples102Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll98Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackDetailsAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll98Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll98Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountDuplicate17Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountDuplicate17Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountDuplicate17Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBulks25Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBulks25Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBulks25Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory53Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackDetailsFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory53Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory53Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr49Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr49Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr49Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory53Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory53Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory53Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp105Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp105Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp105Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples101Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TrackDetailsFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples101Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples101Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAll102Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WeatherReportAbridged
}

// Status returns HTTPResponse.Status
func (r FindAll102Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAll102Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Create106Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Create106Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Create106Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Count2Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Count2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Count2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistory56Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WeatherReportFull
}

// Status returns HTTPResponse.Status
func (r FindAllHistory56Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistory56Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllHistoryAodr51Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FindAllHistoryAodr51Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllHistoryAodr51Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountHistory56Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountHistory56Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountHistory56Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Queryhelp109Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Queryhelp109Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Queryhelp109Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAllTuples105Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WeatherReportFull
}

// Status returns HTTPResponse.Status
func (r FindAllTuples105Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAllTuples105Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Find99Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WeatherReportFull
}

// Status returns HTTPResponse.Status
func (r Find99Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Find99Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// FiledropEphemPostIdWithBodyWithResponse request with arbitrary body returning *FiledropEphemPostIdResponse
func (c *ClientWithResponses) FiledropEphemPostIdWithBodyWithResponse(ctx context.Context, params *FiledropEphemPostIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropEphemPostIdResponse, error) {
	rsp, err := c.FiledropEphemPostIdWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropEphemPostIdResponse(rsp)
}

// FiledropUdlAircraftsortiePostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAircraftsortiePostIdResponse
func (c *ClientWithResponses) FiledropUdlAircraftsortiePostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAircraftsortiePostIdResponse, error) {
	rsp, err := c.FiledropUdlAircraftsortiePostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAircraftsortiePostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAircraftsortiePostIdWithResponse(ctx context.Context, body FiledropUdlAircraftsortiePostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAircraftsortiePostIdResponse, error) {
	rsp, err := c.FiledropUdlAircraftsortiePostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAircraftsortiePostIdResponse(rsp)
}

// FiledropUdlAisPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAisPostIdResponse
func (c *ClientWithResponses) FiledropUdlAisPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error) {
	rsp, err := c.FiledropUdlAisPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAisPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAisPostIdWithResponse(ctx context.Context, body FiledropUdlAisPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAisPostIdResponse, error) {
	rsp, err := c.FiledropUdlAisPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAisPostIdResponse(rsp)
}

// FiledropUdlAnalyticimageryPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAnalyticimageryPostIdResponse
func (c *ClientWithResponses) FiledropUdlAnalyticimageryPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAnalyticimageryPostIdResponse, error) {
	rsp, err := c.FiledropUdlAnalyticimageryPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAnalyticimageryPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAnalyticimageryPostIdWithResponse(ctx context.Context, body FiledropUdlAnalyticimageryPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAnalyticimageryPostIdResponse, error) {
	rsp, err := c.FiledropUdlAnalyticimageryPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAnalyticimageryPostIdResponse(rsp)
}

// FiledropUdlAttitudesetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlAttitudesetPostIdResponse
func (c *ClientWithResponses) FiledropUdlAttitudesetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error) {
	rsp, err := c.FiledropUdlAttitudesetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAttitudesetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlAttitudesetPostIdWithResponse(ctx context.Context, body FiledropUdlAttitudesetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlAttitudesetPostIdResponse, error) {
	rsp, err := c.FiledropUdlAttitudesetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlAttitudesetPostIdResponse(rsp)
}

// FiledropUdlElsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlElsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlElsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlElsetPostIdWithResponse(ctx context.Context, body FiledropUdlElsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlElsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlElsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlElsetPostIdResponse(rsp)
}

// FiledropUdlEphsetPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlEphsetPostIdResponse
func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlEphsetPostIdWithResponse(ctx context.Context, body FiledropUdlEphsetPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEphsetPostIdResponse, error) {
	rsp, err := c.FiledropUdlEphsetPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEphsetPostIdResponse(rsp)
}

// FiledropUdlEventevolutionPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlEventevolutionPostIdResponse
func (c *ClientWithResponses) FiledropUdlEventevolutionPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlEventevolutionPostIdResponse, error) {
	rsp, err := c.FiledropUdlEventevolutionPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEventevolutionPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlEventevolutionPostIdWithResponse(ctx context.Context, body FiledropUdlEventevolutionPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlEventevolutionPostIdResponse, error) {
	rsp, err := c.FiledropUdlEventevolutionPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlEventevolutionPostIdResponse(rsp)
}

// FiledropUdlOrbittrackPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlOrbittrackPostIdResponse
func (c *ClientWithResponses) FiledropUdlOrbittrackPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlOrbittrackPostIdResponse, error) {
	rsp, err := c.FiledropUdlOrbittrackPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlOrbittrackPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlOrbittrackPostIdWithResponse(ctx context.Context, body FiledropUdlOrbittrackPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlOrbittrackPostIdResponse, error) {
	rsp, err := c.FiledropUdlOrbittrackPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlOrbittrackPostIdResponse(rsp)
}

// FiledropUdlPoiPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlPoiPostIdResponse
func (c *ClientWithResponses) FiledropUdlPoiPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlPoiPostIdResponse, error) {
	rsp, err := c.FiledropUdlPoiPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlPoiPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlPoiPostIdWithResponse(ctx context.Context, body FiledropUdlPoiPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlPoiPostIdResponse, error) {
	rsp, err := c.FiledropUdlPoiPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlPoiPostIdResponse(rsp)
}

// FiledropUdlSigactPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlSigactPostIdResponse
func (c *ClientWithResponses) FiledropUdlSigactPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlSigactPostIdResponse, error) {
	rsp, err := c.FiledropUdlSigactPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlSigactPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlSigactPostIdWithResponse(ctx context.Context, body FiledropUdlSigactPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlSigactPostIdResponse, error) {
	rsp, err := c.FiledropUdlSigactPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlSigactPostIdResponse(rsp)
}

// FiledropUdlTracksPostIdWithBodyWithResponse request with arbitrary body returning *FiledropUdlTracksPostIdResponse
func (c *ClientWithResponses) FiledropUdlTracksPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropUdlTracksPostIdResponse, error) {
	rsp, err := c.FiledropUdlTracksPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlTracksPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropUdlTracksPostIdWithResponse(ctx context.Context, body FiledropUdlTracksPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropUdlTracksPostIdResponse, error) {
	rsp, err := c.FiledropUdlTracksPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropUdlTracksPostIdResponse(rsp)
}

// FiledropWeatherreportPostIdWithBodyWithResponse request with arbitrary body returning *FiledropWeatherreportPostIdResponse
func (c *ClientWithResponses) FiledropWeatherreportPostIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiledropWeatherreportPostIdResponse, error) {
	rsp, err := c.FiledropWeatherreportPostIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropWeatherreportPostIdResponse(rsp)
}

func (c *ClientWithResponses) FiledropWeatherreportPostIdWithResponse(ctx context.Context, body FiledropWeatherreportPostIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FiledropWeatherreportPostIdResponse, error) {
	rsp, err := c.FiledropWeatherreportPostId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiledropWeatherreportPostIdResponse(rsp)
}

// FindAll2WithResponse request returning *FindAll2Response
func (c *ClientWithResponses) FindAll2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll2Response, error) {
	rsp, err := c.FindAll2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll2Response(rsp)
}

// Create2WithBodyWithResponse request with arbitrary body returning *Create2Response
func (c *ClientWithResponses) Create2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create2Response, error) {
	rsp, err := c.Create2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate2Response(rsp)
}

func (c *ClientWithResponses) Create2WithResponse(ctx context.Context, body Create2JSONRequestBody, reqEditors ...RequestEditorFn) (*Create2Response, error) {
	rsp, err := c.Create2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate2Response(rsp)
}

// CountRESTWithResponse request returning *CountRESTResponse
func (c *ClientWithResponses) CountRESTWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountRESTResponse, error) {
	rsp, err := c.CountREST(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountRESTResponse(rsp)
}

// Queryhelp2WithResponse request returning *Queryhelp2Response
func (c *ClientWithResponses) Queryhelp2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp2Response, error) {
	rsp, err := c.Queryhelp2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp2Response(rsp)
}

// FindAllTuples2WithResponse request returning *FindAllTuples2Response
func (c *ClientWithResponses) FindAllTuples2WithResponse(ctx context.Context, params *FindAllTuples2Params, reqEditors ...RequestEditorFn) (*FindAllTuples2Response, error) {
	rsp, err := c.FindAllTuples2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples2Response(rsp)
}

// FindWithResponse request returning *FindResponse
func (c *ClientWithResponses) FindWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*FindResponse, error) {
	rsp, err := c.Find(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindResponse(rsp)
}

// EditWithBodyWithResponse request with arbitrary body returning *EditResponse
func (c *ClientWithResponses) EditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditResponse, error) {
	rsp, err := c.EditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditResponse(rsp)
}

func (c *ClientWithResponses) EditWithResponse(ctx context.Context, id string, body EditJSONRequestBody, reqEditors ...RequestEditorFn) (*EditResponse, error) {
	rsp, err := c.Edit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditResponse(rsp)
}

// FindAllWithStreamWithResponse request returning *FindAllWithStreamResponse
func (c *ClientWithResponses) FindAllWithStreamWithResponse(ctx context.Context, params *FindAllWithStreamParams, reqEditors ...RequestEditorFn) (*FindAllWithStreamResponse, error) {
	rsp, err := c.FindAllWithStream(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStreamResponse(rsp)
}

// Create3WithBodyWithResponse request with arbitrary body returning *Create3Response
func (c *ClientWithResponses) Create3WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create3Response, error) {
	rsp, err := c.Create3WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate3Response(rsp)
}

func (c *ClientWithResponses) Create3WithResponse(ctx context.Context, body Create3JSONRequestBody, reqEditors ...RequestEditorFn) (*Create3Response, error) {
	rsp, err := c.Create3(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate3Response(rsp)
}

// CountREST1WithResponse request returning *CountREST1Response
func (c *ClientWithResponses) CountREST1WithResponse(ctx context.Context, params *CountREST1Params, reqEditors ...RequestEditorFn) (*CountREST1Response, error) {
	rsp, err := c.CountREST1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST1Response(rsp)
}

// CreateBulks1WithBodyWithResponse request with arbitrary body returning *CreateBulks1Response
func (c *ClientWithResponses) CreateBulks1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks1Response, error) {
	rsp, err := c.CreateBulks1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks1Response(rsp)
}

func (c *ClientWithResponses) CreateBulks1WithResponse(ctx context.Context, body CreateBulks1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks1Response, error) {
	rsp, err := c.CreateBulks1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks1Response(rsp)
}

// FindAllHistory2WithResponse request returning *FindAllHistory2Response
func (c *ClientWithResponses) FindAllHistory2WithResponse(ctx context.Context, params *FindAllHistory2Params, reqEditors ...RequestEditorFn) (*FindAllHistory2Response, error) {
	rsp, err := c.FindAllHistory2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory2Response(rsp)
}

// FindAllHistoryAodr2WithResponse request returning *FindAllHistoryAodr2Response
func (c *ClientWithResponses) FindAllHistoryAodr2WithResponse(ctx context.Context, params *FindAllHistoryAodr2Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr2Response, error) {
	rsp, err := c.FindAllHistoryAodr2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr2Response(rsp)
}

// CountHistory2WithResponse request returning *CountHistory2Response
func (c *ClientWithResponses) CountHistory2WithResponse(ctx context.Context, params *CountHistory2Params, reqEditors ...RequestEditorFn) (*CountHistory2Response, error) {
	rsp, err := c.CountHistory2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory2Response(rsp)
}

// Queryhelp3WithResponse request returning *Queryhelp3Response
func (c *ClientWithResponses) Queryhelp3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp3Response, error) {
	rsp, err := c.Queryhelp3(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp3Response(rsp)
}

// FindAllTuples3WithResponse request returning *FindAllTuples3Response
func (c *ClientWithResponses) FindAllTuples3WithResponse(ctx context.Context, params *FindAllTuples3Params, reqEditors ...RequestEditorFn) (*FindAllTuples3Response, error) {
	rsp, err := c.FindAllTuples3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples3Response(rsp)
}

// RemoveWithResponse request returning *RemoveResponse
func (c *ClientWithResponses) RemoveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RemoveResponse, error) {
	rsp, err := c.Remove(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveResponse(rsp)
}

// Find1WithResponse request returning *Find1Response
func (c *ClientWithResponses) Find1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find1Response, error) {
	rsp, err := c.Find1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind1Response(rsp)
}

// Edit1WithBodyWithResponse request with arbitrary body returning *Edit1Response
func (c *ClientWithResponses) Edit1WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit1Response, error) {
	rsp, err := c.Edit1WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit1Response(rsp)
}

func (c *ClientWithResponses) Edit1WithResponse(ctx context.Context, id string, body Edit1JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit1Response, error) {
	rsp, err := c.Edit1(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit1Response(rsp)
}

// FindAll3WithResponse request returning *FindAll3Response
func (c *ClientWithResponses) FindAll3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll3Response, error) {
	rsp, err := c.FindAll3(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll3Response(rsp)
}

// Create4WithBodyWithResponse request with arbitrary body returning *Create4Response
func (c *ClientWithResponses) Create4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create4Response, error) {
	rsp, err := c.Create4WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate4Response(rsp)
}

func (c *ClientWithResponses) Create4WithResponse(ctx context.Context, body Create4JSONRequestBody, reqEditors ...RequestEditorFn) (*Create4Response, error) {
	rsp, err := c.Create4(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate4Response(rsp)
}

// CountREST2WithResponse request returning *CountREST2Response
func (c *ClientWithResponses) CountREST2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountREST2Response, error) {
	rsp, err := c.CountREST2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST2Response(rsp)
}

// Queryhelp4WithResponse request returning *Queryhelp4Response
func (c *ClientWithResponses) Queryhelp4WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp4Response, error) {
	rsp, err := c.Queryhelp4(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp4Response(rsp)
}

// FindAllTuples4WithResponse request returning *FindAllTuples4Response
func (c *ClientWithResponses) FindAllTuples4WithResponse(ctx context.Context, params *FindAllTuples4Params, reqEditors ...RequestEditorFn) (*FindAllTuples4Response, error) {
	rsp, err := c.FindAllTuples4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples4Response(rsp)
}

// Remove1WithResponse request returning *Remove1Response
func (c *ClientWithResponses) Remove1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove1Response, error) {
	rsp, err := c.Remove1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemove1Response(rsp)
}

// Find2WithResponse request returning *Find2Response
func (c *ClientWithResponses) Find2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find2Response, error) {
	rsp, err := c.Find2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind2Response(rsp)
}

// Edit2WithBodyWithResponse request with arbitrary body returning *Edit2Response
func (c *ClientWithResponses) Edit2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit2Response, error) {
	rsp, err := c.Edit2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit2Response(rsp)
}

func (c *ClientWithResponses) Edit2WithResponse(ctx context.Context, id string, body Edit2JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit2Response, error) {
	rsp, err := c.Edit2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit2Response(rsp)
}

// FindAllWithResponse request returning *FindAllResponse
func (c *ClientWithResponses) FindAllWithResponse(ctx context.Context, params *FindAllParams, reqEditors ...RequestEditorFn) (*FindAllResponse, error) {
	rsp, err := c.FindAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllResponse(rsp)
}

// CreateWithBodyWithResponse request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.Create(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResponse(rsp)
}

// CountDuplicateWithResponse request returning *CountDuplicateResponse
func (c *ClientWithResponses) CountDuplicateWithResponse(ctx context.Context, params *CountDuplicateParams, reqEditors ...RequestEditorFn) (*CountDuplicateResponse, error) {
	rsp, err := c.CountDuplicate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicateResponse(rsp)
}

// CreateBulksWithBodyWithResponse request with arbitrary body returning *CreateBulksResponse
func (c *ClientWithResponses) CreateBulksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error) {
	rsp, err := c.CreateBulksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulksResponse(rsp)
}

func (c *ClientWithResponses) CreateBulksWithResponse(ctx context.Context, body CreateBulksJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulksResponse, error) {
	rsp, err := c.CreateBulks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulksResponse(rsp)
}

// FindAllHistoryWithResponse request returning *FindAllHistoryResponse
func (c *ClientWithResponses) FindAllHistoryWithResponse(ctx context.Context, params *FindAllHistoryParams, reqEditors ...RequestEditorFn) (*FindAllHistoryResponse, error) {
	rsp, err := c.FindAllHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryResponse(rsp)
}

// FindAllHistoryAodrWithResponse request returning *FindAllHistoryAodrResponse
func (c *ClientWithResponses) FindAllHistoryAodrWithResponse(ctx context.Context, params *FindAllHistoryAodrParams, reqEditors ...RequestEditorFn) (*FindAllHistoryAodrResponse, error) {
	rsp, err := c.FindAllHistoryAodr(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodrResponse(rsp)
}

// CountHistoryWithResponse request returning *CountHistoryResponse
func (c *ClientWithResponses) CountHistoryWithResponse(ctx context.Context, params *CountHistoryParams, reqEditors ...RequestEditorFn) (*CountHistoryResponse, error) {
	rsp, err := c.CountHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistoryResponse(rsp)
}

// QueryhelpWithResponse request returning *QueryhelpResponse
func (c *ClientWithResponses) QueryhelpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryhelpResponse, error) {
	rsp, err := c.Queryhelp(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelpResponse(rsp)
}

// FindAllTuplesWithResponse request returning *FindAllTuplesResponse
func (c *ClientWithResponses) FindAllTuplesWithResponse(ctx context.Context, params *FindAllTuplesParams, reqEditors ...RequestEditorFn) (*FindAllTuplesResponse, error) {
	rsp, err := c.FindAllTuples(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuplesResponse(rsp)
}

// FindAll4WithResponse request returning *FindAll4Response
func (c *ClientWithResponses) FindAll4WithResponse(ctx context.Context, params *FindAll4Params, reqEditors ...RequestEditorFn) (*FindAll4Response, error) {
	rsp, err := c.FindAll4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll4Response(rsp)
}

// CountREST3WithResponse request returning *CountREST3Response
func (c *ClientWithResponses) CountREST3WithResponse(ctx context.Context, params *CountREST3Params, reqEditors ...RequestEditorFn) (*CountREST3Response, error) {
	rsp, err := c.CountREST3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST3Response(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// FindAllHistory3WithResponse request returning *FindAllHistory3Response
func (c *ClientWithResponses) FindAllHistory3WithResponse(ctx context.Context, params *FindAllHistory3Params, reqEditors ...RequestEditorFn) (*FindAllHistory3Response, error) {
	rsp, err := c.FindAllHistory3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory3Response(rsp)
}

// FindAllHistoryAodr3WithResponse request returning *FindAllHistoryAodr3Response
func (c *ClientWithResponses) FindAllHistoryAodr3WithResponse(ctx context.Context, params *FindAllHistoryAodr3Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr3Response, error) {
	rsp, err := c.FindAllHistoryAodr3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr3Response(rsp)
}

// CountHistory3WithResponse request returning *CountHistory3Response
func (c *ClientWithResponses) CountHistory3WithResponse(ctx context.Context, params *CountHistory3Params, reqEditors ...RequestEditorFn) (*CountHistory3Response, error) {
	rsp, err := c.CountHistory3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory3Response(rsp)
}

// Queryhelp5WithResponse request returning *Queryhelp5Response
func (c *ClientWithResponses) Queryhelp5WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp5Response, error) {
	rsp, err := c.Queryhelp5(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp5Response(rsp)
}

// FindAllTuples5WithResponse request returning *FindAllTuples5Response
func (c *ClientWithResponses) FindAllTuples5WithResponse(ctx context.Context, params *FindAllTuples5Params, reqEditors ...RequestEditorFn) (*FindAllTuples5Response, error) {
	rsp, err := c.FindAllTuples5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples5Response(rsp)
}

// Find3WithResponse request returning *Find3Response
func (c *ClientWithResponses) Find3WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find3Response, error) {
	rsp, err := c.Find3(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind3Response(rsp)
}

// FindAllWithStream1WithResponse request returning *FindAllWithStream1Response
func (c *ClientWithResponses) FindAllWithStream1WithResponse(ctx context.Context, params *FindAllWithStream1Params, reqEditors ...RequestEditorFn) (*FindAllWithStream1Response, error) {
	rsp, err := c.FindAllWithStream1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream1Response(rsp)
}

// CountDuplicate2WithResponse request returning *CountDuplicate2Response
func (c *ClientWithResponses) CountDuplicate2WithResponse(ctx context.Context, params *CountDuplicate2Params, reqEditors ...RequestEditorFn) (*CountDuplicate2Response, error) {
	rsp, err := c.CountDuplicate2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate2Response(rsp)
}

// FindAllHistory4WithResponse request returning *FindAllHistory4Response
func (c *ClientWithResponses) FindAllHistory4WithResponse(ctx context.Context, params *FindAllHistory4Params, reqEditors ...RequestEditorFn) (*FindAllHistory4Response, error) {
	rsp, err := c.FindAllHistory4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory4Response(rsp)
}

// FindAllHistoryAodr4WithResponse request returning *FindAllHistoryAodr4Response
func (c *ClientWithResponses) FindAllHistoryAodr4WithResponse(ctx context.Context, params *FindAllHistoryAodr4Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr4Response, error) {
	rsp, err := c.FindAllHistoryAodr4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr4Response(rsp)
}

// CountHistory4WithResponse request returning *CountHistory4Response
func (c *ClientWithResponses) CountHistory4WithResponse(ctx context.Context, params *CountHistory4Params, reqEditors ...RequestEditorFn) (*CountHistory4Response, error) {
	rsp, err := c.CountHistory4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory4Response(rsp)
}

// Queryhelp7WithResponse request returning *Queryhelp7Response
func (c *ClientWithResponses) Queryhelp7WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp7Response, error) {
	rsp, err := c.Queryhelp7(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp7Response(rsp)
}

// FindAllTuples7WithResponse request returning *FindAllTuples7Response
func (c *ClientWithResponses) FindAllTuples7WithResponse(ctx context.Context, params *FindAllTuples7Params, reqEditors ...RequestEditorFn) (*FindAllTuples7Response, error) {
	rsp, err := c.FindAllTuples7(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples7Response(rsp)
}

// FindAllWithStream2WithResponse request returning *FindAllWithStream2Response
func (c *ClientWithResponses) FindAllWithStream2WithResponse(ctx context.Context, params *FindAllWithStream2Params, reqEditors ...RequestEditorFn) (*FindAllWithStream2Response, error) {
	rsp, err := c.FindAllWithStream2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream2Response(rsp)
}

// Create7WithBodyWithResponse request with arbitrary body returning *Create7Response
func (c *ClientWithResponses) Create7WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create7Response, error) {
	rsp, err := c.Create7WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate7Response(rsp)
}

func (c *ClientWithResponses) Create7WithResponse(ctx context.Context, body Create7JSONRequestBody, reqEditors ...RequestEditorFn) (*Create7Response, error) {
	rsp, err := c.Create7(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate7Response(rsp)
}

// CountREST5WithResponse request returning *CountREST5Response
func (c *ClientWithResponses) CountREST5WithResponse(ctx context.Context, params *CountREST5Params, reqEditors ...RequestEditorFn) (*CountREST5Response, error) {
	rsp, err := c.CountREST5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST5Response(rsp)
}

// FindAllHistory5WithResponse request returning *FindAllHistory5Response
func (c *ClientWithResponses) FindAllHistory5WithResponse(ctx context.Context, params *FindAllHistory5Params, reqEditors ...RequestEditorFn) (*FindAllHistory5Response, error) {
	rsp, err := c.FindAllHistory5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory5Response(rsp)
}

// FindAllHistoryAodr5WithResponse request returning *FindAllHistoryAodr5Response
func (c *ClientWithResponses) FindAllHistoryAodr5WithResponse(ctx context.Context, params *FindAllHistoryAodr5Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr5Response, error) {
	rsp, err := c.FindAllHistoryAodr5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr5Response(rsp)
}

// CountHistory5WithResponse request returning *CountHistory5Response
func (c *ClientWithResponses) CountHistory5WithResponse(ctx context.Context, params *CountHistory5Params, reqEditors ...RequestEditorFn) (*CountHistory5Response, error) {
	rsp, err := c.CountHistory5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory5Response(rsp)
}

// Queryhelp8WithResponse request returning *Queryhelp8Response
func (c *ClientWithResponses) Queryhelp8WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp8Response, error) {
	rsp, err := c.Queryhelp8(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp8Response(rsp)
}

// FindAllTuples8WithResponse request returning *FindAllTuples8Response
func (c *ClientWithResponses) FindAllTuples8WithResponse(ctx context.Context, params *FindAllTuples8Params, reqEditors ...RequestEditorFn) (*FindAllTuples8Response, error) {
	rsp, err := c.FindAllTuples8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples8Response(rsp)
}

// Find6WithResponse request returning *Find6Response
func (c *ClientWithResponses) Find6WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find6Response, error) {
	rsp, err := c.Find6(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind6Response(rsp)
}

// PostCotToBluestaqTakServerWithBodyWithResponse request with arbitrary body returning *PostCotToBluestaqTakServerResponse
func (c *ClientWithResponses) PostCotToBluestaqTakServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCotToBluestaqTakServerResponse, error) {
	rsp, err := c.PostCotToBluestaqTakServerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCotToBluestaqTakServerResponse(rsp)
}

func (c *ClientWithResponses) PostCotToBluestaqTakServerWithResponse(ctx context.Context, body PostCotToBluestaqTakServerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCotToBluestaqTakServerResponse, error) {
	rsp, err := c.PostCotToBluestaqTakServer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCotToBluestaqTakServerResponse(rsp)
}

// CurrentWithResponse request returning *CurrentResponse
func (c *ClientWithResponses) CurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentResponse, error) {
	rsp, err := c.Current(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentResponse(rsp)
}

// Queryhelp21WithResponse request returning *Queryhelp21Response
func (c *ClientWithResponses) Queryhelp21WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp21Response, error) {
	rsp, err := c.Queryhelp21(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp21Response(rsp)
}

// FindAllWithStream8WithResponse request returning *FindAllWithStream8Response
func (c *ClientWithResponses) FindAllWithStream8WithResponse(ctx context.Context, params *FindAllWithStream8Params, reqEditors ...RequestEditorFn) (*FindAllWithStream8Response, error) {
	rsp, err := c.FindAllWithStream8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream8Response(rsp)
}

// Create28WithBodyWithResponse request with arbitrary body returning *Create28Response
func (c *ClientWithResponses) Create28WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create28Response, error) {
	rsp, err := c.Create28WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate28Response(rsp)
}

func (c *ClientWithResponses) Create28WithResponse(ctx context.Context, body Create28JSONRequestBody, reqEditors ...RequestEditorFn) (*Create28Response, error) {
	rsp, err := c.Create28(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate28Response(rsp)
}

// CountREST24WithResponse request returning *CountREST24Response
func (c *ClientWithResponses) CountREST24WithResponse(ctx context.Context, params *CountREST24Params, reqEditors ...RequestEditorFn) (*CountREST24Response, error) {
	rsp, err := c.CountREST24(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST24Response(rsp)
}

// CreateBulks8WithBodyWithResponse request with arbitrary body returning *CreateBulks8Response
func (c *ClientWithResponses) CreateBulks8WithBodyWithResponse(ctx context.Context, params *CreateBulks8Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8WithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

func (c *ClientWithResponses) CreateBulks8WithResponse(ctx context.Context, params *CreateBulks8Params, body CreateBulks8JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks8Response, error) {
	rsp, err := c.CreateBulks8(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks8Response(rsp)
}

// CreateBulkFromTLEWithBodyWithResponse request with arbitrary body returning *CreateBulkFromTLEResponse
func (c *ClientWithResponses) CreateBulkFromTLEWithBodyWithResponse(ctx context.Context, params *CreateBulkFromTLEParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulkFromTLEResponse, error) {
	rsp, err := c.CreateBulkFromTLEWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulkFromTLEResponse(rsp)
}

// Current1WithResponse request returning *Current1Response
func (c *ClientWithResponses) Current1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Current1Response, error) {
	rsp, err := c.Current1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrent1Response(rsp)
}

// CurrentTupleWithResponse request returning *CurrentTupleResponse
func (c *ClientWithResponses) CurrentTupleWithResponse(ctx context.Context, params *CurrentTupleParams, reqEditors ...RequestEditorFn) (*CurrentTupleResponse, error) {
	rsp, err := c.CurrentTuple(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentTupleResponse(rsp)
}

// FindAllHistory16WithResponse request returning *FindAllHistory16Response
func (c *ClientWithResponses) FindAllHistory16WithResponse(ctx context.Context, params *FindAllHistory16Params, reqEditors ...RequestEditorFn) (*FindAllHistory16Response, error) {
	rsp, err := c.FindAllHistory16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory16Response(rsp)
}

// FindAllHistoryAodr16WithResponse request returning *FindAllHistoryAodr16Response
func (c *ClientWithResponses) FindAllHistoryAodr16WithResponse(ctx context.Context, params *FindAllHistoryAodr16Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr16Response, error) {
	rsp, err := c.FindAllHistoryAodr16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr16Response(rsp)
}

// CountHistory16WithResponse request returning *CountHistory16Response
func (c *ClientWithResponses) CountHistory16WithResponse(ctx context.Context, params *CountHistory16Params, reqEditors ...RequestEditorFn) (*CountHistory16Response, error) {
	rsp, err := c.CountHistory16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory16Response(rsp)
}

// Queryhelp31WithResponse request returning *Queryhelp31Response
func (c *ClientWithResponses) Queryhelp31WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp31Response, error) {
	rsp, err := c.Queryhelp31(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp31Response(rsp)
}

// FindAllTuples29WithResponse request returning *FindAllTuples29Response
func (c *ClientWithResponses) FindAllTuples29WithResponse(ctx context.Context, params *FindAllTuples29Params, reqEditors ...RequestEditorFn) (*FindAllTuples29Response, error) {
	rsp, err := c.FindAllTuples29(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples29Response(rsp)
}

// Find25WithResponse request returning *Find25Response
func (c *ClientWithResponses) Find25WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find25Response, error) {
	rsp, err := c.Find25(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind25Response(rsp)
}

// FindAllWithStream9WithResponse request returning *FindAllWithStream9Response
func (c *ClientWithResponses) FindAllWithStream9WithResponse(ctx context.Context, params *FindAllWithStream9Params, reqEditors ...RequestEditorFn) (*FindAllWithStream9Response, error) {
	rsp, err := c.FindAllWithStream9(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream9Response(rsp)
}

// CountDuplicate6WithResponse request returning *CountDuplicate6Response
func (c *ClientWithResponses) CountDuplicate6WithResponse(ctx context.Context, params *CountDuplicate6Params, reqEditors ...RequestEditorFn) (*CountDuplicate6Response, error) {
	rsp, err := c.CountDuplicate6(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate6Response(rsp)
}

// FindAllHistory17WithResponse request returning *FindAllHistory17Response
func (c *ClientWithResponses) FindAllHistory17WithResponse(ctx context.Context, params *FindAllHistory17Params, reqEditors ...RequestEditorFn) (*FindAllHistory17Response, error) {
	rsp, err := c.FindAllHistory17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory17Response(rsp)
}

// FindAllHistoryAodr17WithResponse request returning *FindAllHistoryAodr17Response
func (c *ClientWithResponses) FindAllHistoryAodr17WithResponse(ctx context.Context, params *FindAllHistoryAodr17Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr17Response, error) {
	rsp, err := c.FindAllHistoryAodr17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr17Response(rsp)
}

// CountHistory17WithResponse request returning *CountHistory17Response
func (c *ClientWithResponses) CountHistory17WithResponse(ctx context.Context, params *CountHistory17Params, reqEditors ...RequestEditorFn) (*CountHistory17Response, error) {
	rsp, err := c.CountHistory17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory17Response(rsp)
}

// Queryhelp34WithResponse request returning *Queryhelp34Response
func (c *ClientWithResponses) Queryhelp34WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp34Response, error) {
	rsp, err := c.Queryhelp34(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp34Response(rsp)
}

// FindAllTuples32WithResponse request returning *FindAllTuples32Response
func (c *ClientWithResponses) FindAllTuples32WithResponse(ctx context.Context, params *FindAllTuples32Params, reqEditors ...RequestEditorFn) (*FindAllTuples32Response, error) {
	rsp, err := c.FindAllTuples32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples32Response(rsp)
}

// FindAllWithStream10WithResponse request returning *FindAllWithStream10Response
func (c *ClientWithResponses) FindAllWithStream10WithResponse(ctx context.Context, params *FindAllWithStream10Params, reqEditors ...RequestEditorFn) (*FindAllWithStream10Response, error) {
	rsp, err := c.FindAllWithStream10(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllWithStream10Response(rsp)
}

// Create32WithBodyWithResponse request with arbitrary body returning *Create32Response
func (c *ClientWithResponses) Create32WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create32Response, error) {
	rsp, err := c.Create32WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate32Response(rsp)
}

func (c *ClientWithResponses) Create32WithResponse(ctx context.Context, body Create32JSONRequestBody, reqEditors ...RequestEditorFn) (*Create32Response, error) {
	rsp, err := c.Create32(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate32Response(rsp)
}

// CountREST27WithResponse request returning *CountREST27Response
func (c *ClientWithResponses) CountREST27WithResponse(ctx context.Context, params *CountREST27Params, reqEditors ...RequestEditorFn) (*CountREST27Response, error) {
	rsp, err := c.CountREST27(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST27Response(rsp)
}

// GetFile1WithResponse request returning *GetFile1Response
func (c *ClientWithResponses) GetFile1WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFile1Response, error) {
	rsp, err := c.GetFile1(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFile1Response(rsp)
}

// FindAllHistory18WithResponse request returning *FindAllHistory18Response
func (c *ClientWithResponses) FindAllHistory18WithResponse(ctx context.Context, params *FindAllHistory18Params, reqEditors ...RequestEditorFn) (*FindAllHistory18Response, error) {
	rsp, err := c.FindAllHistory18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory18Response(rsp)
}

// FindAllHistoryAodr18WithResponse request returning *FindAllHistoryAodr18Response
func (c *ClientWithResponses) FindAllHistoryAodr18WithResponse(ctx context.Context, params *FindAllHistoryAodr18Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr18Response, error) {
	rsp, err := c.FindAllHistoryAodr18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr18Response(rsp)
}

// CountHistory18WithResponse request returning *CountHistory18Response
func (c *ClientWithResponses) CountHistory18WithResponse(ctx context.Context, params *CountHistory18Params, reqEditors ...RequestEditorFn) (*CountHistory18Response, error) {
	rsp, err := c.CountHistory18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory18Response(rsp)
}

// Queryhelp35WithResponse request returning *Queryhelp35Response
func (c *ClientWithResponses) Queryhelp35WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp35Response, error) {
	rsp, err := c.Queryhelp35(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp35Response(rsp)
}

// FindAllTuples33WithResponse request returning *FindAllTuples33Response
func (c *ClientWithResponses) FindAllTuples33WithResponse(ctx context.Context, params *FindAllTuples33Params, reqEditors ...RequestEditorFn) (*FindAllTuples33Response, error) {
	rsp, err := c.FindAllTuples33(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples33Response(rsp)
}

// Find29WithResponse request returning *Find29Response
func (c *ClientWithResponses) Find29WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find29Response, error) {
	rsp, err := c.Find29(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind29Response(rsp)
}

// FindAll27WithResponse request returning *FindAll27Response
func (c *ClientWithResponses) FindAll27WithResponse(ctx context.Context, params *FindAll27Params, reqEditors ...RequestEditorFn) (*FindAll27Response, error) {
	rsp, err := c.FindAll27(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll27Response(rsp)
}

// Create34WithBodyWithResponse request with arbitrary body returning *Create34Response
func (c *ClientWithResponses) Create34WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create34Response, error) {
	rsp, err := c.Create34WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate34Response(rsp)
}

func (c *ClientWithResponses) Create34WithResponse(ctx context.Context, body Create34JSONRequestBody, reqEditors ...RequestEditorFn) (*Create34Response, error) {
	rsp, err := c.Create34(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate34Response(rsp)
}

// CountWithResponse request returning *CountResponse
func (c *ClientWithResponses) CountWithResponse(ctx context.Context, params *CountParams, reqEditors ...RequestEditorFn) (*CountResponse, error) {
	rsp, err := c.Count(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountResponse(rsp)
}

// CreateBulk4WithBodyWithResponse request with arbitrary body returning *CreateBulk4Response
func (c *ClientWithResponses) CreateBulk4WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulk4Response, error) {
	rsp, err := c.CreateBulk4WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulk4Response(rsp)
}

func (c *ClientWithResponses) CreateBulk4WithResponse(ctx context.Context, body CreateBulk4JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulk4Response, error) {
	rsp, err := c.CreateBulk4(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulk4Response(rsp)
}

// FindAllHistory20WithResponse request returning *FindAllHistory20Response
func (c *ClientWithResponses) FindAllHistory20WithResponse(ctx context.Context, params *FindAllHistory20Params, reqEditors ...RequestEditorFn) (*FindAllHistory20Response, error) {
	rsp, err := c.FindAllHistory20(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory20Response(rsp)
}

// FindAllHistoryAodr19WithResponse request returning *FindAllHistoryAodr19Response
func (c *ClientWithResponses) FindAllHistoryAodr19WithResponse(ctx context.Context, params *FindAllHistoryAodr19Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr19Response, error) {
	rsp, err := c.FindAllHistoryAodr19(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr19Response(rsp)
}

// CountHistory20WithResponse request returning *CountHistory20Response
func (c *ClientWithResponses) CountHistory20WithResponse(ctx context.Context, params *CountHistory20Params, reqEditors ...RequestEditorFn) (*CountHistory20Response, error) {
	rsp, err := c.CountHistory20(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory20Response(rsp)
}

// Queryhelp37WithResponse request returning *Queryhelp37Response
func (c *ClientWithResponses) Queryhelp37WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp37Response, error) {
	rsp, err := c.Queryhelp37(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp37Response(rsp)
}

// FindAllTuples35WithResponse request returning *FindAllTuples35Response
func (c *ClientWithResponses) FindAllTuples35WithResponse(ctx context.Context, params *FindAllTuples35Params, reqEditors ...RequestEditorFn) (*FindAllTuples35Response, error) {
	rsp, err := c.FindAllTuples35(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples35Response(rsp)
}

// Find30WithResponse request returning *Find30Response
func (c *ClientWithResponses) Find30WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find30Response, error) {
	rsp, err := c.Find30(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind30Response(rsp)
}

// FindAll33WithResponse request returning *FindAll33Response
func (c *ClientWithResponses) FindAll33WithResponse(ctx context.Context, params *FindAll33Params, reqEditors ...RequestEditorFn) (*FindAll33Response, error) {
	rsp, err := c.FindAll33(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll33Response(rsp)
}

// Create38WithBodyWithResponse request with arbitrary body returning *Create38Response
func (c *ClientWithResponses) Create38WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create38Response, error) {
	rsp, err := c.Create38WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate38Response(rsp)
}

func (c *ClientWithResponses) Create38WithResponse(ctx context.Context, body Create38JSONRequestBody, reqEditors ...RequestEditorFn) (*Create38Response, error) {
	rsp, err := c.Create38(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate38Response(rsp)
}

// CountREST32WithResponse request returning *CountREST32Response
func (c *ClientWithResponses) CountREST32WithResponse(ctx context.Context, params *CountREST32Params, reqEditors ...RequestEditorFn) (*CountREST32Response, error) {
	rsp, err := c.CountREST32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST32Response(rsp)
}

// CreateBulks10WithBodyWithResponse request with arbitrary body returning *CreateBulks10Response
func (c *ClientWithResponses) CreateBulks10WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks10Response, error) {
	rsp, err := c.CreateBulks10WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks10Response(rsp)
}

func (c *ClientWithResponses) CreateBulks10WithResponse(ctx context.Context, body CreateBulks10JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks10Response, error) {
	rsp, err := c.CreateBulks10(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks10Response(rsp)
}

// FindAllHistory26WithResponse request returning *FindAllHistory26Response
func (c *ClientWithResponses) FindAllHistory26WithResponse(ctx context.Context, params *FindAllHistory26Params, reqEditors ...RequestEditorFn) (*FindAllHistory26Response, error) {
	rsp, err := c.FindAllHistory26(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory26Response(rsp)
}

// FindAllHistoryAodr25WithResponse request returning *FindAllHistoryAodr25Response
func (c *ClientWithResponses) FindAllHistoryAodr25WithResponse(ctx context.Context, params *FindAllHistoryAodr25Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr25Response, error) {
	rsp, err := c.FindAllHistoryAodr25(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr25Response(rsp)
}

// CountHistory26WithResponse request returning *CountHistory26Response
func (c *ClientWithResponses) CountHistory26WithResponse(ctx context.Context, params *CountHistory26Params, reqEditors ...RequestEditorFn) (*CountHistory26Response, error) {
	rsp, err := c.CountHistory26(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory26Response(rsp)
}

// Queryhelp43WithResponse request returning *Queryhelp43Response
func (c *ClientWithResponses) Queryhelp43WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp43Response, error) {
	rsp, err := c.Queryhelp43(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp43Response(rsp)
}

// FindAllTuples41WithResponse request returning *FindAllTuples41Response
func (c *ClientWithResponses) FindAllTuples41WithResponse(ctx context.Context, params *FindAllTuples41Params, reqEditors ...RequestEditorFn) (*FindAllTuples41Response, error) {
	rsp, err := c.FindAllTuples41(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples41Response(rsp)
}

// Find35WithResponse request returning *Find35Response
func (c *ClientWithResponses) Find35WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find35Response, error) {
	rsp, err := c.Find35(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind35Response(rsp)
}

// FindAll46WithResponse request returning *FindAll46Response
func (c *ClientWithResponses) FindAll46WithResponse(ctx context.Context, params *FindAll46Params, reqEditors ...RequestEditorFn) (*FindAll46Response, error) {
	rsp, err := c.FindAll46(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll46Response(rsp)
}

// Create53WithBodyWithResponse request with arbitrary body returning *Create53Response
func (c *ClientWithResponses) Create53WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create53Response, error) {
	rsp, err := c.Create53WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate53Response(rsp)
}

func (c *ClientWithResponses) Create53WithResponse(ctx context.Context, body Create53JSONRequestBody, reqEditors ...RequestEditorFn) (*Create53Response, error) {
	rsp, err := c.Create53(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate53Response(rsp)
}

// CountDuplicate11WithResponse request returning *CountDuplicate11Response
func (c *ClientWithResponses) CountDuplicate11WithResponse(ctx context.Context, params *CountDuplicate11Params, reqEditors ...RequestEditorFn) (*CountDuplicate11Response, error) {
	rsp, err := c.CountDuplicate11(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate11Response(rsp)
}

// CreateBulks14WithBodyWithResponse request with arbitrary body returning *CreateBulks14Response
func (c *ClientWithResponses) CreateBulks14WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks14Response, error) {
	rsp, err := c.CreateBulks14WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks14Response(rsp)
}

func (c *ClientWithResponses) CreateBulks14WithResponse(ctx context.Context, body CreateBulks14JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks14Response, error) {
	rsp, err := c.CreateBulks14(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks14Response(rsp)
}

// FindAllHistory32WithResponse request returning *FindAllHistory32Response
func (c *ClientWithResponses) FindAllHistory32WithResponse(ctx context.Context, params *FindAllHistory32Params, reqEditors ...RequestEditorFn) (*FindAllHistory32Response, error) {
	rsp, err := c.FindAllHistory32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory32Response(rsp)
}

// FindAllHistoryAodr31WithResponse request returning *FindAllHistoryAodr31Response
func (c *ClientWithResponses) FindAllHistoryAodr31WithResponse(ctx context.Context, params *FindAllHistoryAodr31Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr31Response, error) {
	rsp, err := c.FindAllHistoryAodr31(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr31Response(rsp)
}

// CountHistory32WithResponse request returning *CountHistory32Response
func (c *ClientWithResponses) CountHistory32WithResponse(ctx context.Context, params *CountHistory32Params, reqEditors ...RequestEditorFn) (*CountHistory32Response, error) {
	rsp, err := c.CountHistory32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory32Response(rsp)
}

// Queryhelp56WithResponse request returning *Queryhelp56Response
func (c *ClientWithResponses) Queryhelp56WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp56Response, error) {
	rsp, err := c.Queryhelp56(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp56Response(rsp)
}

// FindAllTuples54WithResponse request returning *FindAllTuples54Response
func (c *ClientWithResponses) FindAllTuples54WithResponse(ctx context.Context, params *FindAllTuples54Params, reqEditors ...RequestEditorFn) (*FindAllTuples54Response, error) {
	rsp, err := c.FindAllTuples54(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples54Response(rsp)
}

// FindAll47WithResponse request returning *FindAll47Response
func (c *ClientWithResponses) FindAll47WithResponse(ctx context.Context, params *FindAll47Params, reqEditors ...RequestEditorFn) (*FindAll47Response, error) {
	rsp, err := c.FindAll47(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll47Response(rsp)
}

// Create54WithBodyWithResponse request with arbitrary body returning *Create54Response
func (c *ClientWithResponses) Create54WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create54Response, error) {
	rsp, err := c.Create54WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate54Response(rsp)
}

func (c *ClientWithResponses) Create54WithResponse(ctx context.Context, body Create54JSONRequestBody, reqEditors ...RequestEditorFn) (*Create54Response, error) {
	rsp, err := c.Create54(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate54Response(rsp)
}

// CountREST43WithResponse request returning *CountREST43Response
func (c *ClientWithResponses) CountREST43WithResponse(ctx context.Context, params *CountREST43Params, reqEditors ...RequestEditorFn) (*CountREST43Response, error) {
	rsp, err := c.CountREST43(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST43Response(rsp)
}

// MissionAssignmentCreateBulkWithBodyWithResponse request with arbitrary body returning *MissionAssignmentCreateBulkResponse
func (c *ClientWithResponses) MissionAssignmentCreateBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MissionAssignmentCreateBulkResponse, error) {
	rsp, err := c.MissionAssignmentCreateBulkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMissionAssignmentCreateBulkResponse(rsp)
}

func (c *ClientWithResponses) MissionAssignmentCreateBulkWithResponse(ctx context.Context, body MissionAssignmentCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*MissionAssignmentCreateBulkResponse, error) {
	rsp, err := c.MissionAssignmentCreateBulk(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMissionAssignmentCreateBulkResponse(rsp)
}

// FindAllHistory33WithResponse request returning *FindAllHistory33Response
func (c *ClientWithResponses) FindAllHistory33WithResponse(ctx context.Context, params *FindAllHistory33Params, reqEditors ...RequestEditorFn) (*FindAllHistory33Response, error) {
	rsp, err := c.FindAllHistory33(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory33Response(rsp)
}

// FindAllHistoryAodr32WithResponse request returning *FindAllHistoryAodr32Response
func (c *ClientWithResponses) FindAllHistoryAodr32WithResponse(ctx context.Context, params *FindAllHistoryAodr32Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr32Response, error) {
	rsp, err := c.FindAllHistoryAodr32(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr32Response(rsp)
}

// CountHistory33WithResponse request returning *CountHistory33Response
func (c *ClientWithResponses) CountHistory33WithResponse(ctx context.Context, params *CountHistory33Params, reqEditors ...RequestEditorFn) (*CountHistory33Response, error) {
	rsp, err := c.CountHistory33(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory33Response(rsp)
}

// Queryhelp57WithResponse request returning *Queryhelp57Response
func (c *ClientWithResponses) Queryhelp57WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp57Response, error) {
	rsp, err := c.Queryhelp57(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp57Response(rsp)
}

// FindAllTuples55WithResponse request returning *FindAllTuples55Response
func (c *ClientWithResponses) FindAllTuples55WithResponse(ctx context.Context, params *FindAllTuples55Params, reqEditors ...RequestEditorFn) (*FindAllTuples55Response, error) {
	rsp, err := c.FindAllTuples55(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples55Response(rsp)
}

// Remove27WithResponse request returning *Remove27Response
func (c *ClientWithResponses) Remove27WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove27Response, error) {
	rsp, err := c.Remove27(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemove27Response(rsp)
}

// Find48WithResponse request returning *Find48Response
func (c *ClientWithResponses) Find48WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find48Response, error) {
	rsp, err := c.Find48(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind48Response(rsp)
}

// Edit29WithBodyWithResponse request with arbitrary body returning *Edit29Response
func (c *ClientWithResponses) Edit29WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit29Response, error) {
	rsp, err := c.Edit29WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit29Response(rsp)
}

func (c *ClientWithResponses) Edit29WithResponse(ctx context.Context, id string, body Edit29JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit29Response, error) {
	rsp, err := c.Edit29(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit29Response(rsp)
}

// FindAll62WithResponse request returning *FindAll62Response
func (c *ClientWithResponses) FindAll62WithResponse(ctx context.Context, params *FindAll62Params, reqEditors ...RequestEditorFn) (*FindAll62Response, error) {
	rsp, err := c.FindAll62(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll62Response(rsp)
}

// Create68WithBodyWithResponse request with arbitrary body returning *Create68Response
func (c *ClientWithResponses) Create68WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create68Response, error) {
	rsp, err := c.Create68WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate68Response(rsp)
}

func (c *ClientWithResponses) Create68WithResponse(ctx context.Context, body Create68JSONRequestBody, reqEditors ...RequestEditorFn) (*Create68Response, error) {
	rsp, err := c.Create68(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate68Response(rsp)
}

// CountDuplicate15WithResponse request returning *CountDuplicate15Response
func (c *ClientWithResponses) CountDuplicate15WithResponse(ctx context.Context, params *CountDuplicate15Params, reqEditors ...RequestEditorFn) (*CountDuplicate15Response, error) {
	rsp, err := c.CountDuplicate15(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate15Response(rsp)
}

// CreateBulks18WithBodyWithResponse request with arbitrary body returning *CreateBulks18Response
func (c *ClientWithResponses) CreateBulks18WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks18Response, error) {
	rsp, err := c.CreateBulks18WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks18Response(rsp)
}

func (c *ClientWithResponses) CreateBulks18WithResponse(ctx context.Context, body CreateBulks18JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks18Response, error) {
	rsp, err := c.CreateBulks18(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks18Response(rsp)
}

// FindAllHistory38WithResponse request returning *FindAllHistory38Response
func (c *ClientWithResponses) FindAllHistory38WithResponse(ctx context.Context, params *FindAllHistory38Params, reqEditors ...RequestEditorFn) (*FindAllHistory38Response, error) {
	rsp, err := c.FindAllHistory38(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory38Response(rsp)
}

// FindAllHistoryAodr37WithResponse request returning *FindAllHistoryAodr37Response
func (c *ClientWithResponses) FindAllHistoryAodr37WithResponse(ctx context.Context, params *FindAllHistoryAodr37Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr37Response, error) {
	rsp, err := c.FindAllHistoryAodr37(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr37Response(rsp)
}

// CountHistory38WithResponse request returning *CountHistory38Response
func (c *ClientWithResponses) CountHistory38WithResponse(ctx context.Context, params *CountHistory38Params, reqEditors ...RequestEditorFn) (*CountHistory38Response, error) {
	rsp, err := c.CountHistory38(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory38Response(rsp)
}

// Queryhelp68WithResponse request returning *Queryhelp68Response
func (c *ClientWithResponses) Queryhelp68WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp68Response, error) {
	rsp, err := c.Queryhelp68(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp68Response(rsp)
}

// FindAllTuples66WithResponse request returning *FindAllTuples66Response
func (c *ClientWithResponses) FindAllTuples66WithResponse(ctx context.Context, params *FindAllTuples66Params, reqEditors ...RequestEditorFn) (*FindAllTuples66Response, error) {
	rsp, err := c.FindAllTuples66(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples66Response(rsp)
}

// FindAll65WithResponse request returning *FindAll65Response
func (c *ClientWithResponses) FindAll65WithResponse(ctx context.Context, params *FindAll65Params, reqEditors ...RequestEditorFn) (*FindAll65Response, error) {
	rsp, err := c.FindAll65(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll65Response(rsp)
}

// Create71WithBodyWithResponse request with arbitrary body returning *Create71Response
func (c *ClientWithResponses) Create71WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create71Response, error) {
	rsp, err := c.Create71WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate71Response(rsp)
}

func (c *ClientWithResponses) Create71WithResponse(ctx context.Context, body Create71JSONRequestBody, reqEditors ...RequestEditorFn) (*Create71Response, error) {
	rsp, err := c.Create71(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate71Response(rsp)
}

// CountREST51WithResponse request returning *CountREST51Response
func (c *ClientWithResponses) CountREST51WithResponse(ctx context.Context, params *CountREST51Params, reqEditors ...RequestEditorFn) (*CountREST51Response, error) {
	rsp, err := c.CountREST51(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST51Response(rsp)
}

// CreateBulks19WithBodyWithResponse request with arbitrary body returning *CreateBulks19Response
func (c *ClientWithResponses) CreateBulks19WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks19Response, error) {
	rsp, err := c.CreateBulks19WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks19Response(rsp)
}

func (c *ClientWithResponses) CreateBulks19WithResponse(ctx context.Context, body CreateBulks19JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks19Response, error) {
	rsp, err := c.CreateBulks19(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks19Response(rsp)
}

// FindAllHistory39WithResponse request returning *FindAllHistory39Response
func (c *ClientWithResponses) FindAllHistory39WithResponse(ctx context.Context, params *FindAllHistory39Params, reqEditors ...RequestEditorFn) (*FindAllHistory39Response, error) {
	rsp, err := c.FindAllHistory39(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory39Response(rsp)
}

// FindAllHistoryAodr38WithResponse request returning *FindAllHistoryAodr38Response
func (c *ClientWithResponses) FindAllHistoryAodr38WithResponse(ctx context.Context, params *FindAllHistoryAodr38Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr38Response, error) {
	rsp, err := c.FindAllHistoryAodr38(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr38Response(rsp)
}

// CountHistory39WithResponse request returning *CountHistory39Response
func (c *ClientWithResponses) CountHistory39WithResponse(ctx context.Context, params *CountHistory39Params, reqEditors ...RequestEditorFn) (*CountHistory39Response, error) {
	rsp, err := c.CountHistory39(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory39Response(rsp)
}

// Queryhelp70WithResponse request returning *Queryhelp70Response
func (c *ClientWithResponses) Queryhelp70WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp70Response, error) {
	rsp, err := c.Queryhelp70(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp70Response(rsp)
}

// FindAllTuples68WithResponse request returning *FindAllTuples68Response
func (c *ClientWithResponses) FindAllTuples68WithResponse(ctx context.Context, params *FindAllTuples68Params, reqEditors ...RequestEditorFn) (*FindAllTuples68Response, error) {
	rsp, err := c.FindAllTuples68(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples68Response(rsp)
}

// Find63WithResponse request returning *Find63Response
func (c *ClientWithResponses) Find63WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find63Response, error) {
	rsp, err := c.Find63(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind63Response(rsp)
}

// FindAll85WithResponse request returning *FindAll85Response
func (c *ClientWithResponses) FindAll85WithResponse(ctx context.Context, params *FindAll85Params, reqEditors ...RequestEditorFn) (*FindAll85Response, error) {
	rsp, err := c.FindAll85(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll85Response(rsp)
}

// Create91WithBodyWithResponse request with arbitrary body returning *Create91Response
func (c *ClientWithResponses) Create91WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create91Response, error) {
	rsp, err := c.Create91WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate91Response(rsp)
}

func (c *ClientWithResponses) Create91WithResponse(ctx context.Context, body Create91JSONRequestBody, reqEditors ...RequestEditorFn) (*Create91Response, error) {
	rsp, err := c.Create91(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate91Response(rsp)
}

// CountDuplicate16WithResponse request returning *CountDuplicate16Response
func (c *ClientWithResponses) CountDuplicate16WithResponse(ctx context.Context, params *CountDuplicate16Params, reqEditors ...RequestEditorFn) (*CountDuplicate16Response, error) {
	rsp, err := c.CountDuplicate16(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate16Response(rsp)
}

// FindAllHistory46WithResponse request returning *FindAllHistory46Response
func (c *ClientWithResponses) FindAllHistory46WithResponse(ctx context.Context, params *FindAllHistory46Params, reqEditors ...RequestEditorFn) (*FindAllHistory46Response, error) {
	rsp, err := c.FindAllHistory46(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory46Response(rsp)
}

// CountHistory46WithResponse request returning *CountHistory46Response
func (c *ClientWithResponses) CountHistory46WithResponse(ctx context.Context, params *CountHistory46Params, reqEditors ...RequestEditorFn) (*CountHistory46Response, error) {
	rsp, err := c.CountHistory46(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory46Response(rsp)
}

// Queryhelp92WithResponse request returning *Queryhelp92Response
func (c *ClientWithResponses) Queryhelp92WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp92Response, error) {
	rsp, err := c.Queryhelp92(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp92Response(rsp)
}

// FindAllTuples88WithResponse request returning *FindAllTuples88Response
func (c *ClientWithResponses) FindAllTuples88WithResponse(ctx context.Context, params *FindAllTuples88Params, reqEditors ...RequestEditorFn) (*FindAllTuples88Response, error) {
	rsp, err := c.FindAllTuples88(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples88Response(rsp)
}

// FindAll86WithResponse request returning *FindAll86Response
func (c *ClientWithResponses) FindAll86WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FindAll86Response, error) {
	rsp, err := c.FindAll86(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll86Response(rsp)
}

// Create92WithBodyWithResponse request with arbitrary body returning *Create92Response
func (c *ClientWithResponses) Create92WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create92Response, error) {
	rsp, err := c.Create92WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate92Response(rsp)
}

func (c *ClientWithResponses) Create92WithResponse(ctx context.Context, body Create92JSONRequestBody, reqEditors ...RequestEditorFn) (*Create92Response, error) {
	rsp, err := c.Create92(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate92Response(rsp)
}

// CountREST70WithResponse request returning *CountREST70Response
func (c *ClientWithResponses) CountREST70WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CountREST70Response, error) {
	rsp, err := c.CountREST70(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST70Response(rsp)
}

// Queryhelp93WithResponse request returning *Queryhelp93Response
func (c *ClientWithResponses) Queryhelp93WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp93Response, error) {
	rsp, err := c.Queryhelp93(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp93Response(rsp)
}

// FindAllTuples89WithResponse request returning *FindAllTuples89Response
func (c *ClientWithResponses) FindAllTuples89WithResponse(ctx context.Context, params *FindAllTuples89Params, reqEditors ...RequestEditorFn) (*FindAllTuples89Response, error) {
	rsp, err := c.FindAllTuples89(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples89Response(rsp)
}

// Find84WithResponse request returning *Find84Response
func (c *ClientWithResponses) Find84WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find84Response, error) {
	rsp, err := c.Find84(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind84Response(rsp)
}

// Edit59WithBodyWithResponse request with arbitrary body returning *Edit59Response
func (c *ClientWithResponses) Edit59WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit59Response, error) {
	rsp, err := c.Edit59WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit59Response(rsp)
}

func (c *ClientWithResponses) Edit59WithResponse(ctx context.Context, id string, body Edit59JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit59Response, error) {
	rsp, err := c.Edit59(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit59Response(rsp)
}

// FindAll87WithResponse request returning *FindAll87Response
func (c *ClientWithResponses) FindAll87WithResponse(ctx context.Context, params *FindAll87Params, reqEditors ...RequestEditorFn) (*FindAll87Response, error) {
	rsp, err := c.FindAll87(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll87Response(rsp)
}

// Create93WithBodyWithResponse request with arbitrary body returning *Create93Response
func (c *ClientWithResponses) Create93WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create93Response, error) {
	rsp, err := c.Create93WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate93Response(rsp)
}

func (c *ClientWithResponses) Create93WithResponse(ctx context.Context, body Create93JSONRequestBody, reqEditors ...RequestEditorFn) (*Create93Response, error) {
	rsp, err := c.Create93(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate93Response(rsp)
}

// CountREST71WithResponse request returning *CountREST71Response
func (c *ClientWithResponses) CountREST71WithResponse(ctx context.Context, params *CountREST71Params, reqEditors ...RequestEditorFn) (*CountREST71Response, error) {
	rsp, err := c.CountREST71(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountREST71Response(rsp)
}

// FindAllHistory47WithResponse request returning *FindAllHistory47Response
func (c *ClientWithResponses) FindAllHistory47WithResponse(ctx context.Context, params *FindAllHistory47Params, reqEditors ...RequestEditorFn) (*FindAllHistory47Response, error) {
	rsp, err := c.FindAllHistory47(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory47Response(rsp)
}

// CountHistory47WithResponse request returning *CountHistory47Response
func (c *ClientWithResponses) CountHistory47WithResponse(ctx context.Context, params *CountHistory47Params, reqEditors ...RequestEditorFn) (*CountHistory47Response, error) {
	rsp, err := c.CountHistory47(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory47Response(rsp)
}

// Queryhelp94WithResponse request returning *Queryhelp94Response
func (c *ClientWithResponses) Queryhelp94WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp94Response, error) {
	rsp, err := c.Queryhelp94(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp94Response(rsp)
}

// FindAllTuples90WithResponse request returning *FindAllTuples90Response
func (c *ClientWithResponses) FindAllTuples90WithResponse(ctx context.Context, params *FindAllTuples90Params, reqEditors ...RequestEditorFn) (*FindAllTuples90Response, error) {
	rsp, err := c.FindAllTuples90(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples90Response(rsp)
}

// Remove56WithResponse request returning *Remove56Response
func (c *ClientWithResponses) Remove56WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Remove56Response, error) {
	rsp, err := c.Remove56(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemove56Response(rsp)
}

// Find85WithResponse request returning *Find85Response
func (c *ClientWithResponses) Find85WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find85Response, error) {
	rsp, err := c.Find85(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind85Response(rsp)
}

// Edit60WithBodyWithResponse request with arbitrary body returning *Edit60Response
func (c *ClientWithResponses) Edit60WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Edit60Response, error) {
	rsp, err := c.Edit60WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit60Response(rsp)
}

func (c *ClientWithResponses) Edit60WithResponse(ctx context.Context, id string, body Edit60JSONRequestBody, reqEditors ...RequestEditorFn) (*Edit60Response, error) {
	rsp, err := c.Edit60(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEdit60Response(rsp)
}

// FindAll99WithResponse request returning *FindAll99Response
func (c *ClientWithResponses) FindAll99WithResponse(ctx context.Context, params *FindAll99Params, reqEditors ...RequestEditorFn) (*FindAll99Response, error) {
	rsp, err := c.FindAll99(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll99Response(rsp)
}

// CountDuplicate18WithResponse request returning *CountDuplicate18Response
func (c *ClientWithResponses) CountDuplicate18WithResponse(ctx context.Context, params *CountDuplicate18Params, reqEditors ...RequestEditorFn) (*CountDuplicate18Response, error) {
	rsp, err := c.CountDuplicate18(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate18Response(rsp)
}

// CreateBulks26WithBodyWithResponse request with arbitrary body returning *CreateBulks26Response
func (c *ClientWithResponses) CreateBulks26WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks26Response, error) {
	rsp, err := c.CreateBulks26WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks26Response(rsp)
}

func (c *ClientWithResponses) CreateBulks26WithResponse(ctx context.Context, body CreateBulks26JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks26Response, error) {
	rsp, err := c.CreateBulks26(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks26Response(rsp)
}

// FindAllHistory54WithResponse request returning *FindAllHistory54Response
func (c *ClientWithResponses) FindAllHistory54WithResponse(ctx context.Context, params *FindAllHistory54Params, reqEditors ...RequestEditorFn) (*FindAllHistory54Response, error) {
	rsp, err := c.FindAllHistory54(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory54Response(rsp)
}

// FindAllHistoryAodr50WithResponse request returning *FindAllHistoryAodr50Response
func (c *ClientWithResponses) FindAllHistoryAodr50WithResponse(ctx context.Context, params *FindAllHistoryAodr50Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr50Response, error) {
	rsp, err := c.FindAllHistoryAodr50(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr50Response(rsp)
}

// CountHistory54WithResponse request returning *CountHistory54Response
func (c *ClientWithResponses) CountHistory54WithResponse(ctx context.Context, params *CountHistory54Params, reqEditors ...RequestEditorFn) (*CountHistory54Response, error) {
	rsp, err := c.CountHistory54(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory54Response(rsp)
}

// Queryhelp106WithResponse request returning *Queryhelp106Response
func (c *ClientWithResponses) Queryhelp106WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp106Response, error) {
	rsp, err := c.Queryhelp106(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp106Response(rsp)
}

// FindAllTuples102WithResponse request returning *FindAllTuples102Response
func (c *ClientWithResponses) FindAllTuples102WithResponse(ctx context.Context, params *FindAllTuples102Params, reqEditors ...RequestEditorFn) (*FindAllTuples102Response, error) {
	rsp, err := c.FindAllTuples102(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples102Response(rsp)
}

// FindAll98WithResponse request returning *FindAll98Response
func (c *ClientWithResponses) FindAll98WithResponse(ctx context.Context, params *FindAll98Params, reqEditors ...RequestEditorFn) (*FindAll98Response, error) {
	rsp, err := c.FindAll98(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll98Response(rsp)
}

// CountDuplicate17WithResponse request returning *CountDuplicate17Response
func (c *ClientWithResponses) CountDuplicate17WithResponse(ctx context.Context, params *CountDuplicate17Params, reqEditors ...RequestEditorFn) (*CountDuplicate17Response, error) {
	rsp, err := c.CountDuplicate17(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountDuplicate17Response(rsp)
}

// CreateBulks25WithBodyWithResponse request with arbitrary body returning *CreateBulks25Response
func (c *ClientWithResponses) CreateBulks25WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBulks25Response, error) {
	rsp, err := c.CreateBulks25WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks25Response(rsp)
}

func (c *ClientWithResponses) CreateBulks25WithResponse(ctx context.Context, body CreateBulks25JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBulks25Response, error) {
	rsp, err := c.CreateBulks25(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBulks25Response(rsp)
}

// FindAllHistory53WithResponse request returning *FindAllHistory53Response
func (c *ClientWithResponses) FindAllHistory53WithResponse(ctx context.Context, params *FindAllHistory53Params, reqEditors ...RequestEditorFn) (*FindAllHistory53Response, error) {
	rsp, err := c.FindAllHistory53(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory53Response(rsp)
}

// FindAllHistoryAodr49WithResponse request returning *FindAllHistoryAodr49Response
func (c *ClientWithResponses) FindAllHistoryAodr49WithResponse(ctx context.Context, params *FindAllHistoryAodr49Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr49Response, error) {
	rsp, err := c.FindAllHistoryAodr49(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr49Response(rsp)
}

// CountHistory53WithResponse request returning *CountHistory53Response
func (c *ClientWithResponses) CountHistory53WithResponse(ctx context.Context, params *CountHistory53Params, reqEditors ...RequestEditorFn) (*CountHistory53Response, error) {
	rsp, err := c.CountHistory53(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory53Response(rsp)
}

// Queryhelp105WithResponse request returning *Queryhelp105Response
func (c *ClientWithResponses) Queryhelp105WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp105Response, error) {
	rsp, err := c.Queryhelp105(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp105Response(rsp)
}

// FindAllTuples101WithResponse request returning *FindAllTuples101Response
func (c *ClientWithResponses) FindAllTuples101WithResponse(ctx context.Context, params *FindAllTuples101Params, reqEditors ...RequestEditorFn) (*FindAllTuples101Response, error) {
	rsp, err := c.FindAllTuples101(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples101Response(rsp)
}

// FindAll102WithResponse request returning *FindAll102Response
func (c *ClientWithResponses) FindAll102WithResponse(ctx context.Context, params *FindAll102Params, reqEditors ...RequestEditorFn) (*FindAll102Response, error) {
	rsp, err := c.FindAll102(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAll102Response(rsp)
}

// Create106WithBodyWithResponse request with arbitrary body returning *Create106Response
func (c *ClientWithResponses) Create106WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Create106Response, error) {
	rsp, err := c.Create106WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate106Response(rsp)
}

func (c *ClientWithResponses) Create106WithResponse(ctx context.Context, body Create106JSONRequestBody, reqEditors ...RequestEditorFn) (*Create106Response, error) {
	rsp, err := c.Create106(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreate106Response(rsp)
}

// Count2WithResponse request returning *Count2Response
func (c *ClientWithResponses) Count2WithResponse(ctx context.Context, params *Count2Params, reqEditors ...RequestEditorFn) (*Count2Response, error) {
	rsp, err := c.Count2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCount2Response(rsp)
}

// FindAllHistory56WithResponse request returning *FindAllHistory56Response
func (c *ClientWithResponses) FindAllHistory56WithResponse(ctx context.Context, params *FindAllHistory56Params, reqEditors ...RequestEditorFn) (*FindAllHistory56Response, error) {
	rsp, err := c.FindAllHistory56(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistory56Response(rsp)
}

// FindAllHistoryAodr51WithResponse request returning *FindAllHistoryAodr51Response
func (c *ClientWithResponses) FindAllHistoryAodr51WithResponse(ctx context.Context, params *FindAllHistoryAodr51Params, reqEditors ...RequestEditorFn) (*FindAllHistoryAodr51Response, error) {
	rsp, err := c.FindAllHistoryAodr51(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllHistoryAodr51Response(rsp)
}

// CountHistory56WithResponse request returning *CountHistory56Response
func (c *ClientWithResponses) CountHistory56WithResponse(ctx context.Context, params *CountHistory56Params, reqEditors ...RequestEditorFn) (*CountHistory56Response, error) {
	rsp, err := c.CountHistory56(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountHistory56Response(rsp)
}

// Queryhelp109WithResponse request returning *Queryhelp109Response
func (c *ClientWithResponses) Queryhelp109WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*Queryhelp109Response, error) {
	rsp, err := c.Queryhelp109(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryhelp109Response(rsp)
}

// FindAllTuples105WithResponse request returning *FindAllTuples105Response
func (c *ClientWithResponses) FindAllTuples105WithResponse(ctx context.Context, params *FindAllTuples105Params, reqEditors ...RequestEditorFn) (*FindAllTuples105Response, error) {
	rsp, err := c.FindAllTuples105(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAllTuples105Response(rsp)
}

// Find99WithResponse request returning *Find99Response
func (c *ClientWithResponses) Find99WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*Find99Response, error) {
	rsp, err := c.Find99(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFind99Response(rsp)
}

// ParseFiledropEphemPostIdResponse parses an HTTP response from a FiledropEphemPostIdWithResponse call
func ParseFiledropEphemPostIdResponse(rsp *http.Response) (*FiledropEphemPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropEphemPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAircraftsortiePostIdResponse parses an HTTP response from a FiledropUdlAircraftsortiePostIdWithResponse call
func ParseFiledropUdlAircraftsortiePostIdResponse(rsp *http.Response) (*FiledropUdlAircraftsortiePostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAircraftsortiePostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAisPostIdResponse parses an HTTP response from a FiledropUdlAisPostIdWithResponse call
func ParseFiledropUdlAisPostIdResponse(rsp *http.Response) (*FiledropUdlAisPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAisPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAnalyticimageryPostIdResponse parses an HTTP response from a FiledropUdlAnalyticimageryPostIdWithResponse call
func ParseFiledropUdlAnalyticimageryPostIdResponse(rsp *http.Response) (*FiledropUdlAnalyticimageryPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAnalyticimageryPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlAttitudesetPostIdResponse parses an HTTP response from a FiledropUdlAttitudesetPostIdWithResponse call
func ParseFiledropUdlAttitudesetPostIdResponse(rsp *http.Response) (*FiledropUdlAttitudesetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlAttitudesetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlElsetPostIdResponse parses an HTTP response from a FiledropUdlElsetPostIdWithResponse call
func ParseFiledropUdlElsetPostIdResponse(rsp *http.Response) (*FiledropUdlElsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlElsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlEphsetPostIdResponse parses an HTTP response from a FiledropUdlEphsetPostIdWithResponse call
func ParseFiledropUdlEphsetPostIdResponse(rsp *http.Response) (*FiledropUdlEphsetPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlEphsetPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlEventevolutionPostIdResponse parses an HTTP response from a FiledropUdlEventevolutionPostIdWithResponse call
func ParseFiledropUdlEventevolutionPostIdResponse(rsp *http.Response) (*FiledropUdlEventevolutionPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlEventevolutionPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlOrbittrackPostIdResponse parses an HTTP response from a FiledropUdlOrbittrackPostIdWithResponse call
func ParseFiledropUdlOrbittrackPostIdResponse(rsp *http.Response) (*FiledropUdlOrbittrackPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlOrbittrackPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlPoiPostIdResponse parses an HTTP response from a FiledropUdlPoiPostIdWithResponse call
func ParseFiledropUdlPoiPostIdResponse(rsp *http.Response) (*FiledropUdlPoiPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlPoiPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlSigactPostIdResponse parses an HTTP response from a FiledropUdlSigactPostIdWithResponse call
func ParseFiledropUdlSigactPostIdResponse(rsp *http.Response) (*FiledropUdlSigactPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlSigactPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropUdlTracksPostIdResponse parses an HTTP response from a FiledropUdlTracksPostIdWithResponse call
func ParseFiledropUdlTracksPostIdResponse(rsp *http.Response) (*FiledropUdlTracksPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropUdlTracksPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiledropWeatherreportPostIdResponse parses an HTTP response from a FiledropWeatherreportPostIdWithResponse call
func ParseFiledropWeatherreportPostIdResponse(rsp *http.Response) (*FiledropWeatherreportPostIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiledropWeatherreportPostIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAll2Response parses an HTTP response from a FindAll2WithResponse call
func ParseFindAll2Response(rsp *http.Response) (*FindAll2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate2Response parses an HTTP response from a Create2WithResponse call
func ParseCreate2Response(rsp *http.Response) (*Create2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountRESTResponse parses an HTTP response from a CountRESTWithResponse call
func ParseCountRESTResponse(rsp *http.Response) (*CountRESTResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountRESTResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp2Response parses an HTTP response from a Queryhelp2WithResponse call
func ParseQueryhelp2Response(rsp *http.Response) (*Queryhelp2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples2Response parses an HTTP response from a FindAllTuples2WithResponse call
func ParseFindAllTuples2Response(rsp *http.Response) (*FindAllTuples2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindResponse parses an HTTP response from a FindWithResponse call
func ParseFindResponse(rsp *http.Response) (*FindResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AircraftFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditResponse parses an HTTP response from a EditWithResponse call
func ParseEditResponse(rsp *http.Response) (*EditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllWithStreamResponse parses an HTTP response from a FindAllWithStreamWithResponse call
func ParseFindAllWithStreamResponse(rsp *http.Response) (*FindAllWithStreamResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftSortieAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate3Response parses an HTTP response from a Create3WithResponse call
func ParseCreate3Response(rsp *http.Response) (*Create3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST1Response parses an HTTP response from a CountREST1WithResponse call
func ParseCountREST1Response(rsp *http.Response) (*CountREST1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks1Response parses an HTTP response from a CreateBulks1WithResponse call
func ParseCreateBulks1Response(rsp *http.Response) (*CreateBulks1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory2Response parses an HTTP response from a FindAllHistory2WithResponse call
func ParseFindAllHistory2Response(rsp *http.Response) (*FindAllHistory2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftSortieFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr2Response parses an HTTP response from a FindAllHistoryAodr2WithResponse call
func ParseFindAllHistoryAodr2Response(rsp *http.Response) (*FindAllHistoryAodr2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory2Response parses an HTTP response from a CountHistory2WithResponse call
func ParseCountHistory2Response(rsp *http.Response) (*CountHistory2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp3Response parses an HTTP response from a Queryhelp3WithResponse call
func ParseQueryhelp3Response(rsp *http.Response) (*Queryhelp3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples3Response parses an HTTP response from a FindAllTuples3WithResponse call
func ParseFindAllTuples3Response(rsp *http.Response) (*FindAllTuples3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftSortieFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveResponse parses an HTTP response from a RemoveWithResponse call
func ParseRemoveResponse(rsp *http.Response) (*RemoveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFind1Response parses an HTTP response from a Find1WithResponse call
func ParseFind1Response(rsp *http.Response) (*Find1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AircraftSortieFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEdit1Response parses an HTTP response from a Edit1WithResponse call
func ParseEdit1Response(rsp *http.Response) (*Edit1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Edit1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAll3Response parses an HTTP response from a FindAll3WithResponse call
func ParseFindAll3Response(rsp *http.Response) (*FindAll3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftStatusAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate4Response parses an HTTP response from a Create4WithResponse call
func ParseCreate4Response(rsp *http.Response) (*Create4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST2Response parses an HTTP response from a CountREST2WithResponse call
func ParseCountREST2Response(rsp *http.Response) (*CountREST2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp4Response parses an HTTP response from a Queryhelp4WithResponse call
func ParseQueryhelp4Response(rsp *http.Response) (*Queryhelp4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples4Response parses an HTTP response from a FindAllTuples4WithResponse call
func ParseFindAllTuples4Response(rsp *http.Response) (*FindAllTuples4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AircraftStatusFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemove1Response parses an HTTP response from a Remove1WithResponse call
func ParseRemove1Response(rsp *http.Response) (*Remove1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Remove1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFind2Response parses an HTTP response from a Find2WithResponse call
func ParseFind2Response(rsp *http.Response) (*Find2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AircraftStatusFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEdit2Response parses an HTTP response from a Edit2WithResponse call
func ParseEdit2Response(rsp *http.Response) (*Edit2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Edit2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllResponse parses an HTTP response from a FindAllWithResponse call
func ParseFindAllResponse(rsp *http.Response) (*FindAllResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResponse parses an HTTP response from a CreateWithResponse call
func ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountDuplicateResponse parses an HTTP response from a CountDuplicateWithResponse call
func ParseCountDuplicateResponse(rsp *http.Response) (*CountDuplicateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulksResponse parses an HTTP response from a CreateBulksWithResponse call
func ParseCreateBulksResponse(rsp *http.Response) (*CreateBulksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistoryResponse parses an HTTP response from a FindAllHistoryWithResponse call
func ParseFindAllHistoryResponse(rsp *http.Response) (*FindAllHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodrResponse parses an HTTP response from a FindAllHistoryAodrWithResponse call
func ParseFindAllHistoryAodrResponse(rsp *http.Response) (*FindAllHistoryAodrResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistoryResponse parses an HTTP response from a CountHistoryWithResponse call
func ParseCountHistoryResponse(rsp *http.Response) (*CountHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelpResponse parses an HTTP response from a QueryhelpWithResponse call
func ParseQueryhelpResponse(rsp *http.Response) (*QueryhelpResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryhelpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuplesResponse parses an HTTP response from a FindAllTuplesWithResponse call
func ParseFindAllTuplesResponse(rsp *http.Response) (*FindAllTuplesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AISFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll4Response parses an HTTP response from a FindAll4WithResponse call
func ParseFindAll4Response(rsp *http.Response) (*FindAll4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnalyticImageryAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountREST3Response parses an HTTP response from a CountREST3WithResponse call
func ParseCountREST3Response(rsp *http.Response) (*CountREST3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory3Response parses an HTTP response from a FindAllHistory3WithResponse call
func ParseFindAllHistory3Response(rsp *http.Response) (*FindAllHistory3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnalyticImageryFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr3Response parses an HTTP response from a FindAllHistoryAodr3WithResponse call
func ParseFindAllHistoryAodr3Response(rsp *http.Response) (*FindAllHistoryAodr3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory3Response parses an HTTP response from a CountHistory3WithResponse call
func ParseCountHistory3Response(rsp *http.Response) (*CountHistory3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp5Response parses an HTTP response from a Queryhelp5WithResponse call
func ParseQueryhelp5Response(rsp *http.Response) (*Queryhelp5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples5Response parses an HTTP response from a FindAllTuples5WithResponse call
func ParseFindAllTuples5Response(rsp *http.Response) (*FindAllTuples5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AnalyticImageryFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind3Response parses an HTTP response from a Find3WithResponse call
func ParseFind3Response(rsp *http.Response) (*Find3Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnalyticImageryFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream1Response parses an HTTP response from a FindAllWithStream1WithResponse call
func ParseFindAllWithStream1Response(rsp *http.Response) (*FindAllWithStream1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate2Response parses an HTTP response from a CountDuplicate2WithResponse call
func ParseCountDuplicate2Response(rsp *http.Response) (*CountDuplicate2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory4Response parses an HTTP response from a FindAllHistory4WithResponse call
func ParseFindAllHistory4Response(rsp *http.Response) (*FindAllHistory4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr4Response parses an HTTP response from a FindAllHistoryAodr4WithResponse call
func ParseFindAllHistoryAodr4Response(rsp *http.Response) (*FindAllHistoryAodr4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory4Response parses an HTTP response from a CountHistory4WithResponse call
func ParseCountHistory4Response(rsp *http.Response) (*CountHistory4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp7Response parses an HTTP response from a Queryhelp7WithResponse call
func ParseQueryhelp7Response(rsp *http.Response) (*Queryhelp7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples7Response parses an HTTP response from a FindAllTuples7WithResponse call
func ParseFindAllTuples7Response(rsp *http.Response) (*FindAllTuples7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeDataFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream2Response parses an HTTP response from a FindAllWithStream2WithResponse call
func ParseFindAllWithStream2Response(rsp *http.Response) (*FindAllWithStream2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate7Response parses an HTTP response from a Create7WithResponse call
func ParseCreate7Response(rsp *http.Response) (*Create7Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST5Response parses an HTTP response from a CountREST5WithResponse call
func ParseCountREST5Response(rsp *http.Response) (*CountREST5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory5Response parses an HTTP response from a FindAllHistory5WithResponse call
func ParseFindAllHistory5Response(rsp *http.Response) (*FindAllHistory5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr5Response parses an HTTP response from a FindAllHistoryAodr5WithResponse call
func ParseFindAllHistoryAodr5Response(rsp *http.Response) (*FindAllHistoryAodr5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory5Response parses an HTTP response from a CountHistory5WithResponse call
func ParseCountHistory5Response(rsp *http.Response) (*CountHistory5Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp8Response parses an HTTP response from a Queryhelp8WithResponse call
func ParseQueryhelp8Response(rsp *http.Response) (*Queryhelp8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples8Response parses an HTTP response from a FindAllTuples8WithResponse call
func ParseFindAllTuples8Response(rsp *http.Response) (*FindAllTuples8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind6Response parses an HTTP response from a Find6WithResponse call
func ParseFind6Response(rsp *http.Response) (*Find6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttitudeSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCotToBluestaqTakServerResponse parses an HTTP response from a PostCotToBluestaqTakServerWithResponse call
func ParsePostCotToBluestaqTakServerResponse(rsp *http.Response) (*PostCotToBluestaqTakServerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCotToBluestaqTakServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentResponse parses an HTTP response from a CurrentWithResponse call
func ParseCurrentResponse(rsp *http.Response) (*CurrentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseQueryhelp21Response parses an HTTP response from a Queryhelp21WithResponse call
func ParseQueryhelp21Response(rsp *http.Response) (*Queryhelp21Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllWithStream8Response parses an HTTP response from a FindAllWithStream8WithResponse call
func ParseFindAllWithStream8Response(rsp *http.Response) (*FindAllWithStream8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate28Response parses an HTTP response from a Create28WithResponse call
func ParseCreate28Response(rsp *http.Response) (*Create28Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create28Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST24Response parses an HTTP response from a CountREST24WithResponse call
func ParseCountREST24Response(rsp *http.Response) (*CountREST24Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST24Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks8Response parses an HTTP response from a CreateBulks8WithResponse call
func ParseCreateBulks8Response(rsp *http.Response) (*CreateBulks8Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulkFromTLEResponse parses an HTTP response from a CreateBulkFromTLEWithResponse call
func ParseCreateBulkFromTLEResponse(rsp *http.Response) (*CreateBulkFromTLEResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulkFromTLEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrent1Response parses an HTTP response from a Current1WithResponse call
func ParseCurrent1Response(rsp *http.Response) (*Current1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Current1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCurrentTupleResponse parses an HTTP response from a CurrentTupleWithResponse call
func ParseCurrentTupleResponse(rsp *http.Response) (*CurrentTupleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentTupleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistory16Response parses an HTTP response from a FindAllHistory16WithResponse call
func ParseFindAllHistory16Response(rsp *http.Response) (*FindAllHistory16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr16Response parses an HTTP response from a FindAllHistoryAodr16WithResponse call
func ParseFindAllHistoryAodr16Response(rsp *http.Response) (*FindAllHistoryAodr16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory16Response parses an HTTP response from a CountHistory16WithResponse call
func ParseCountHistory16Response(rsp *http.Response) (*CountHistory16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp31Response parses an HTTP response from a Queryhelp31WithResponse call
func ParseQueryhelp31Response(rsp *http.Response) (*Queryhelp31Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp31Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples29Response parses an HTTP response from a FindAllTuples29WithResponse call
func ParseFindAllTuples29Response(rsp *http.Response) (*FindAllTuples29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind25Response parses an HTTP response from a Find25WithResponse call
func ParseFind25Response(rsp *http.Response) (*Find25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElsetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream9Response parses an HTTP response from a FindAllWithStream9WithResponse call
func ParseFindAllWithStream9Response(rsp *http.Response) (*FindAllWithStream9Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream9Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate6Response parses an HTTP response from a CountDuplicate6WithResponse call
func ParseCountDuplicate6Response(rsp *http.Response) (*CountDuplicate6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory17Response parses an HTTP response from a FindAllHistory17WithResponse call
func ParseFindAllHistory17Response(rsp *http.Response) (*FindAllHistory17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr17Response parses an HTTP response from a FindAllHistoryAodr17WithResponse call
func ParseFindAllHistoryAodr17Response(rsp *http.Response) (*FindAllHistoryAodr17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory17Response parses an HTTP response from a CountHistory17WithResponse call
func ParseCountHistory17Response(rsp *http.Response) (*CountHistory17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp34Response parses an HTTP response from a Queryhelp34WithResponse call
func ParseQueryhelp34Response(rsp *http.Response) (*Queryhelp34Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp34Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples32Response parses an HTTP response from a FindAllTuples32WithResponse call
func ParseFindAllTuples32Response(rsp *http.Response) (*FindAllTuples32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllWithStream10Response parses an HTTP response from a FindAllWithStream10WithResponse call
func ParseFindAllWithStream10Response(rsp *http.Response) (*FindAllWithStream10Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllWithStream10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate32Response parses an HTTP response from a Create32WithResponse call
func ParseCreate32Response(rsp *http.Response) (*Create32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST27Response parses an HTTP response from a CountREST27WithResponse call
func ParseCountREST27Response(rsp *http.Response) (*CountREST27Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST27Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFile1Response parses an HTTP response from a GetFile1WithResponse call
func ParseGetFile1Response(rsp *http.Response) (*GetFile1Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFile1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory18Response parses an HTTP response from a FindAllHistory18WithResponse call
func ParseFindAllHistory18Response(rsp *http.Response) (*FindAllHistory18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr18Response parses an HTTP response from a FindAllHistoryAodr18WithResponse call
func ParseFindAllHistoryAodr18Response(rsp *http.Response) (*FindAllHistoryAodr18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory18Response parses an HTTP response from a CountHistory18WithResponse call
func ParseCountHistory18Response(rsp *http.Response) (*CountHistory18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp35Response parses an HTTP response from a Queryhelp35WithResponse call
func ParseQueryhelp35Response(rsp *http.Response) (*Queryhelp35Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp35Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples33Response parses an HTTP response from a FindAllTuples33WithResponse call
func ParseFindAllTuples33Response(rsp *http.Response) (*FindAllTuples33Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples33Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind29Response parses an HTTP response from a Find29WithResponse call
func ParseFind29Response(rsp *http.Response) (*Find29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EphemerisSetFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll27Response parses an HTTP response from a FindAll27WithResponse call
func ParseFindAll27Response(rsp *http.Response) (*FindAll27Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll27Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventEvolutionAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate34Response parses an HTTP response from a Create34WithResponse call
func ParseCreate34Response(rsp *http.Response) (*Create34Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create34Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountResponse parses an HTTP response from a CountWithResponse call
func ParseCountResponse(rsp *http.Response) (*CountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulk4Response parses an HTTP response from a CreateBulk4WithResponse call
func ParseCreateBulk4Response(rsp *http.Response) (*CreateBulk4Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulk4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory20Response parses an HTTP response from a FindAllHistory20WithResponse call
func ParseFindAllHistory20Response(rsp *http.Response) (*FindAllHistory20Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory20Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventEvolutionFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr19Response parses an HTTP response from a FindAllHistoryAodr19WithResponse call
func ParseFindAllHistoryAodr19Response(rsp *http.Response) (*FindAllHistoryAodr19Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr19Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory20Response parses an HTTP response from a CountHistory20WithResponse call
func ParseCountHistory20Response(rsp *http.Response) (*CountHistory20Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory20Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp37Response parses an HTTP response from a Queryhelp37WithResponse call
func ParseQueryhelp37Response(rsp *http.Response) (*Queryhelp37Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp37Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples35Response parses an HTTP response from a FindAllTuples35WithResponse call
func ParseFindAllTuples35Response(rsp *http.Response) (*FindAllTuples35Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples35Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EventEvolutionFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind30Response parses an HTTP response from a Find30WithResponse call
func ParseFind30Response(rsp *http.Response) (*Find30Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find30Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventEvolutionFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll33Response parses an HTTP response from a FindAll33WithResponse call
func ParseFindAll33Response(rsp *http.Response) (*FindAll33Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll33Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HazardAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate38Response parses an HTTP response from a Create38WithResponse call
func ParseCreate38Response(rsp *http.Response) (*Create38Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create38Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST32Response parses an HTTP response from a CountREST32WithResponse call
func ParseCountREST32Response(rsp *http.Response) (*CountREST32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks10Response parses an HTTP response from a CreateBulks10WithResponse call
func ParseCreateBulks10Response(rsp *http.Response) (*CreateBulks10Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory26Response parses an HTTP response from a FindAllHistory26WithResponse call
func ParseFindAllHistory26Response(rsp *http.Response) (*FindAllHistory26Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory26Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HazardFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr25Response parses an HTTP response from a FindAllHistoryAodr25WithResponse call
func ParseFindAllHistoryAodr25Response(rsp *http.Response) (*FindAllHistoryAodr25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory26Response parses an HTTP response from a CountHistory26WithResponse call
func ParseCountHistory26Response(rsp *http.Response) (*CountHistory26Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory26Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp43Response parses an HTTP response from a Queryhelp43WithResponse call
func ParseQueryhelp43Response(rsp *http.Response) (*Queryhelp43Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp43Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples41Response parses an HTTP response from a FindAllTuples41WithResponse call
func ParseFindAllTuples41Response(rsp *http.Response) (*FindAllTuples41Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples41Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HazardFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind35Response parses an HTTP response from a Find35WithResponse call
func ParseFind35Response(rsp *http.Response) (*Find35Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find35Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HazardFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll46Response parses an HTTP response from a FindAll46WithResponse call
func ParseFindAll46Response(rsp *http.Response) (*FindAll46Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll46Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissileTrackAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate53Response parses an HTTP response from a Create53WithResponse call
func ParseCreate53Response(rsp *http.Response) (*Create53Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create53Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountDuplicate11Response parses an HTTP response from a CountDuplicate11WithResponse call
func ParseCountDuplicate11Response(rsp *http.Response) (*CountDuplicate11Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate11Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks14Response parses an HTTP response from a CreateBulks14WithResponse call
func ParseCreateBulks14Response(rsp *http.Response) (*CreateBulks14Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks14Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory32Response parses an HTTP response from a FindAllHistory32WithResponse call
func ParseFindAllHistory32Response(rsp *http.Response) (*FindAllHistory32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissileTrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr31Response parses an HTTP response from a FindAllHistoryAodr31WithResponse call
func ParseFindAllHistoryAodr31Response(rsp *http.Response) (*FindAllHistoryAodr31Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr31Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory32Response parses an HTTP response from a CountHistory32WithResponse call
func ParseCountHistory32Response(rsp *http.Response) (*CountHistory32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp56Response parses an HTTP response from a Queryhelp56WithResponse call
func ParseQueryhelp56Response(rsp *http.Response) (*Queryhelp56Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp56Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples54Response parses an HTTP response from a FindAllTuples54WithResponse call
func ParseFindAllTuples54Response(rsp *http.Response) (*FindAllTuples54Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples54Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissileTrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll47Response parses an HTTP response from a FindAll47WithResponse call
func ParseFindAll47Response(rsp *http.Response) (*FindAll47Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll47Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissionAssignmentAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate54Response parses an HTTP response from a Create54WithResponse call
func ParseCreate54Response(rsp *http.Response) (*Create54Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create54Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST43Response parses an HTTP response from a CountREST43WithResponse call
func ParseCountREST43Response(rsp *http.Response) (*CountREST43Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST43Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMissionAssignmentCreateBulkResponse parses an HTTP response from a MissionAssignmentCreateBulkWithResponse call
func ParseMissionAssignmentCreateBulkResponse(rsp *http.Response) (*MissionAssignmentCreateBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MissionAssignmentCreateBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory33Response parses an HTTP response from a FindAllHistory33WithResponse call
func ParseFindAllHistory33Response(rsp *http.Response) (*FindAllHistory33Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory33Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissionAssignmentFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr32Response parses an HTTP response from a FindAllHistoryAodr32WithResponse call
func ParseFindAllHistoryAodr32Response(rsp *http.Response) (*FindAllHistoryAodr32Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr32Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory33Response parses an HTTP response from a CountHistory33WithResponse call
func ParseCountHistory33Response(rsp *http.Response) (*CountHistory33Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory33Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp57Response parses an HTTP response from a Queryhelp57WithResponse call
func ParseQueryhelp57Response(rsp *http.Response) (*Queryhelp57Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp57Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples55Response parses an HTTP response from a FindAllTuples55WithResponse call
func ParseFindAllTuples55Response(rsp *http.Response) (*FindAllTuples55Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples55Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MissionAssignmentFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemove27Response parses an HTTP response from a Remove27WithResponse call
func ParseRemove27Response(rsp *http.Response) (*Remove27Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Remove27Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFind48Response parses an HTTP response from a Find48WithResponse call
func ParseFind48Response(rsp *http.Response) (*Find48Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find48Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MissionAssignmentFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEdit29Response parses an HTTP response from a Edit29WithResponse call
func ParseEdit29Response(rsp *http.Response) (*Edit29Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Edit29Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAll62Response parses an HTTP response from a FindAll62WithResponse call
func ParseFindAll62Response(rsp *http.Response) (*FindAll62Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll62Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrbitTrackAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate68Response parses an HTTP response from a Create68WithResponse call
func ParseCreate68Response(rsp *http.Response) (*Create68Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create68Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountDuplicate15Response parses an HTTP response from a CountDuplicate15WithResponse call
func ParseCountDuplicate15Response(rsp *http.Response) (*CountDuplicate15Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate15Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks18Response parses an HTTP response from a CreateBulks18WithResponse call
func ParseCreateBulks18Response(rsp *http.Response) (*CreateBulks18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory38Response parses an HTTP response from a FindAllHistory38WithResponse call
func ParseFindAllHistory38Response(rsp *http.Response) (*FindAllHistory38Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory38Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrbitTrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr37Response parses an HTTP response from a FindAllHistoryAodr37WithResponse call
func ParseFindAllHistoryAodr37Response(rsp *http.Response) (*FindAllHistoryAodr37Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr37Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory38Response parses an HTTP response from a CountHistory38WithResponse call
func ParseCountHistory38Response(rsp *http.Response) (*CountHistory38Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory38Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp68Response parses an HTTP response from a Queryhelp68WithResponse call
func ParseQueryhelp68Response(rsp *http.Response) (*Queryhelp68Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp68Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples66Response parses an HTTP response from a FindAllTuples66WithResponse call
func ParseFindAllTuples66Response(rsp *http.Response) (*FindAllTuples66Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples66Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrbitTrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll65Response parses an HTTP response from a FindAll65WithResponse call
func ParseFindAll65Response(rsp *http.Response) (*FindAll65Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll65Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []POIAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate71Response parses an HTTP response from a Create71WithResponse call
func ParseCreate71Response(rsp *http.Response) (*Create71Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create71Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST51Response parses an HTTP response from a CountREST51WithResponse call
func ParseCountREST51Response(rsp *http.Response) (*CountREST51Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST51Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks19Response parses an HTTP response from a CreateBulks19WithResponse call
func ParseCreateBulks19Response(rsp *http.Response) (*CreateBulks19Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks19Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory39Response parses an HTTP response from a FindAllHistory39WithResponse call
func ParseFindAllHistory39Response(rsp *http.Response) (*FindAllHistory39Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory39Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []POIFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr38Response parses an HTTP response from a FindAllHistoryAodr38WithResponse call
func ParseFindAllHistoryAodr38Response(rsp *http.Response) (*FindAllHistoryAodr38Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr38Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory39Response parses an HTTP response from a CountHistory39WithResponse call
func ParseCountHistory39Response(rsp *http.Response) (*CountHistory39Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory39Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp70Response parses an HTTP response from a Queryhelp70WithResponse call
func ParseQueryhelp70Response(rsp *http.Response) (*Queryhelp70Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp70Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples68Response parses an HTTP response from a FindAllTuples68WithResponse call
func ParseFindAllTuples68Response(rsp *http.Response) (*FindAllTuples68Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples68Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []POIFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind63Response parses an HTTP response from a Find63WithResponse call
func ParseFind63Response(rsp *http.Response) (*Find63Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find63Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest POIFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll85Response parses an HTTP response from a FindAll85WithResponse call
func ParseFindAll85Response(rsp *http.Response) (*FindAll85Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll85Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SigActAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate91Response parses an HTTP response from a Create91WithResponse call
func ParseCreate91Response(rsp *http.Response) (*Create91Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create91Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountDuplicate16Response parses an HTTP response from a CountDuplicate16WithResponse call
func ParseCountDuplicate16Response(rsp *http.Response) (*CountDuplicate16Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate16Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory46Response parses an HTTP response from a FindAllHistory46WithResponse call
func ParseFindAllHistory46Response(rsp *http.Response) (*FindAllHistory46Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory46Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SigActFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountHistory46Response parses an HTTP response from a CountHistory46WithResponse call
func ParseCountHistory46Response(rsp *http.Response) (*CountHistory46Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory46Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp92Response parses an HTTP response from a Queryhelp92WithResponse call
func ParseQueryhelp92Response(rsp *http.Response) (*Queryhelp92Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp92Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples88Response parses an HTTP response from a FindAllTuples88WithResponse call
func ParseFindAllTuples88Response(rsp *http.Response) (*FindAllTuples88Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples88Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SigActFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll86Response parses an HTTP response from a FindAll86WithResponse call
func ParseFindAll86Response(rsp *http.Response) (*FindAll86Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll86Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate92Response parses an HTTP response from a Create92WithResponse call
func ParseCreate92Response(rsp *http.Response) (*Create92Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create92Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST70Response parses an HTTP response from a CountREST70WithResponse call
func ParseCountREST70Response(rsp *http.Response) (*CountREST70Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST70Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp93Response parses an HTTP response from a Queryhelp93WithResponse call
func ParseQueryhelp93Response(rsp *http.Response) (*Queryhelp93Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp93Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples89Response parses an HTTP response from a FindAllTuples89WithResponse call
func ParseFindAllTuples89Response(rsp *http.Response) (*FindAllTuples89Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples89Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind84Response parses an HTTP response from a Find84WithResponse call
func ParseFind84Response(rsp *http.Response) (*Find84Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find84Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SiteFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEdit59Response parses an HTTP response from a Edit59WithResponse call
func ParseEdit59Response(rsp *http.Response) (*Edit59Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Edit59Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAll87Response parses an HTTP response from a FindAll87WithResponse call
func ParseFindAll87Response(rsp *http.Response) (*FindAll87Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll87Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteStatusAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate93Response parses an HTTP response from a Create93WithResponse call
func ParseCreate93Response(rsp *http.Response) (*Create93Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create93Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountREST71Response parses an HTTP response from a CountREST71WithResponse call
func ParseCountREST71Response(rsp *http.Response) (*CountREST71Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountREST71Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory47Response parses an HTTP response from a FindAllHistory47WithResponse call
func ParseFindAllHistory47Response(rsp *http.Response) (*FindAllHistory47Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory47Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteStatusFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountHistory47Response parses an HTTP response from a CountHistory47WithResponse call
func ParseCountHistory47Response(rsp *http.Response) (*CountHistory47Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory47Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp94Response parses an HTTP response from a Queryhelp94WithResponse call
func ParseQueryhelp94Response(rsp *http.Response) (*Queryhelp94Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp94Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples90Response parses an HTTP response from a FindAllTuples90WithResponse call
func ParseFindAllTuples90Response(rsp *http.Response) (*FindAllTuples90Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples90Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SiteStatusFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemove56Response parses an HTTP response from a Remove56WithResponse call
func ParseRemove56Response(rsp *http.Response) (*Remove56Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Remove56Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFind85Response parses an HTTP response from a Find85WithResponse call
func ParseFind85Response(rsp *http.Response) (*Find85Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find85Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SiteStatusFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEdit60Response parses an HTTP response from a Edit60WithResponse call
func ParseEdit60Response(rsp *http.Response) (*Edit60Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Edit60Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAll99Response parses an HTTP response from a FindAll99WithResponse call
func ParseFindAll99Response(rsp *http.Response) (*FindAll99Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll99Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate18Response parses an HTTP response from a CountDuplicate18WithResponse call
func ParseCountDuplicate18Response(rsp *http.Response) (*CountDuplicate18Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate18Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks26Response parses an HTTP response from a CreateBulks26WithResponse call
func ParseCreateBulks26Response(rsp *http.Response) (*CreateBulks26Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks26Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory54Response parses an HTTP response from a FindAllHistory54WithResponse call
func ParseFindAllHistory54Response(rsp *http.Response) (*FindAllHistory54Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory54Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr50Response parses an HTTP response from a FindAllHistoryAodr50WithResponse call
func ParseFindAllHistoryAodr50Response(rsp *http.Response) (*FindAllHistoryAodr50Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr50Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory54Response parses an HTTP response from a CountHistory54WithResponse call
func ParseCountHistory54Response(rsp *http.Response) (*CountHistory54Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory54Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp106Response parses an HTTP response from a Queryhelp106WithResponse call
func ParseQueryhelp106Response(rsp *http.Response) (*Queryhelp106Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp106Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples102Response parses an HTTP response from a FindAllTuples102WithResponse call
func ParseFindAllTuples102Response(rsp *http.Response) (*FindAllTuples102Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples102Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll98Response parses an HTTP response from a FindAll98WithResponse call
func ParseFindAll98Response(rsp *http.Response) (*FindAll98Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll98Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackDetailsAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountDuplicate17Response parses an HTTP response from a CountDuplicate17WithResponse call
func ParseCountDuplicate17Response(rsp *http.Response) (*CountDuplicate17Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountDuplicate17Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBulks25Response parses an HTTP response from a CreateBulks25WithResponse call
func ParseCreateBulks25Response(rsp *http.Response) (*CreateBulks25Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBulks25Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory53Response parses an HTTP response from a FindAllHistory53WithResponse call
func ParseFindAllHistory53Response(rsp *http.Response) (*FindAllHistory53Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory53Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackDetailsFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr49Response parses an HTTP response from a FindAllHistoryAodr49WithResponse call
func ParseFindAllHistoryAodr49Response(rsp *http.Response) (*FindAllHistoryAodr49Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr49Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory53Response parses an HTTP response from a CountHistory53WithResponse call
func ParseCountHistory53Response(rsp *http.Response) (*CountHistory53Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory53Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp105Response parses an HTTP response from a Queryhelp105WithResponse call
func ParseQueryhelp105Response(rsp *http.Response) (*Queryhelp105Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp105Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples101Response parses an HTTP response from a FindAllTuples101WithResponse call
func ParseFindAllTuples101Response(rsp *http.Response) (*FindAllTuples101Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples101Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TrackDetailsFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAll102Response parses an HTTP response from a FindAll102WithResponse call
func ParseFindAll102Response(rsp *http.Response) (*FindAll102Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAll102Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WeatherReportAbridged
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreate106Response parses an HTTP response from a Create106WithResponse call
func ParseCreate106Response(rsp *http.Response) (*Create106Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Create106Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCount2Response parses an HTTP response from a Count2WithResponse call
func ParseCount2Response(rsp *http.Response) (*Count2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Count2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllHistory56Response parses an HTTP response from a FindAllHistory56WithResponse call
func ParseFindAllHistory56Response(rsp *http.Response) (*FindAllHistory56Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistory56Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WeatherReportFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindAllHistoryAodr51Response parses an HTTP response from a FindAllHistoryAodr51WithResponse call
func ParseFindAllHistoryAodr51Response(rsp *http.Response) (*FindAllHistoryAodr51Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllHistoryAodr51Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountHistory56Response parses an HTTP response from a CountHistory56WithResponse call
func ParseCountHistory56Response(rsp *http.Response) (*CountHistory56Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountHistory56Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryhelp109Response parses an HTTP response from a Queryhelp109WithResponse call
func ParseQueryhelp109Response(rsp *http.Response) (*Queryhelp109Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Queryhelp109Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFindAllTuples105Response parses an HTTP response from a FindAllTuples105WithResponse call
func ParseFindAllTuples105Response(rsp *http.Response) (*FindAllTuples105Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAllTuples105Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WeatherReportFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFind99Response parses an HTTP response from a Find99WithResponse call
func ParseFind99Response(rsp *http.Response) (*Find99Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Find99Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WeatherReportFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
